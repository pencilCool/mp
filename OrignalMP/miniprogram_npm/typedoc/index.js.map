{"version":3,"sources":["index.js","lib/utils/events.js","lib/models/reflections/abstract.js","lib/models/reflections/utils.js","lib/models/reflections/kind.js","lib/utils/fs.js","lib/models/index.js","lib/models/reflections/index.js","lib/models/reflections/container.js","lib/models/reflections/declaration.js","lib/models/types.js","lib/models/reflections/parameter.js","lib/models/reflections/project.js","lib/models/sources/index.js","lib/models/sources/directory.js","lib/utils/array.js","lib/models/sources/file.js","lib/models/sources/repository.js","lib/models/reflections/reference.js","lib/utils/index.js","lib/utils/component.js","lib/utils/loggers.js","lib/utils/options/index.js","lib/utils/options/options.js","lib/utils/options/declaration.js","lib/utils/options/sources/index.js","lib/utils/options/sources/typedoc.js","lib/utils/sort.js","lib/utils/options/readers/index.js","lib/utils/options/readers/arguments.js","lib/utils/options/readers/tsconfig.js","lib/utils/options/readers/typedoc.js","lib/utils/hooks.js","lib/utils/jsx.js","lib/utils/jsx.elements.js","lib/models/reflections/signature.js","lib/models/reflections/type-parameter.js","lib/models/comments/index.js","lib/models/comments/comment.js","lib/models/comments/tag.js","lib/models/ReflectionGroup.js","lib/models/ReflectionCategory.js","lib/converter/index.js","lib/converter/converter.js","lib/converter/components.js","lib/converter/types.js","lib/converter/converter-events.js","lib/converter/factories/index-signature.js","lib/converter/factories/signature.js","lib/converter/convert-expression.js","lib/converter/utils/reflections.js","lib/converter/symbols.js","lib/utils/enum.js","lib/converter/jsdoc.js","lib/converter/utils/nodes.js","lib/utils/paths.js","lib/converter/utils/symbols.js","lib/converter/plugins/index.js","lib/converter/plugins/CategoryPlugin.js","lib/converter/plugins/CommentPlugin.js","lib/converter/factories/comment.js","lib/converter/plugins/DecoratorPlugin.js","lib/converter/plugins/SourceLinkPlugin.js","lib/converter/utils/base-path.js","lib/converter/plugins/GroupPlugin.js","lib/converter/plugins/ImplementsPlugin.js","lib/converter/plugins/PackagePlugin.js","lib/converter/plugins/SourcePlugin.js","lib/converter/plugins/TypePlugin.js","lib/converter/plugins/InheritDocPlugin.js","lib/output/index.js","lib/output/events.js","lib/output/models/UrlMapping.js","lib/output/renderer.js","lib/output/themes/default/DefaultTheme.js","lib/output/theme.js","lib/output/components.js","lib/output/themes/default/DefaultThemeRenderContext.js","lib/output/themes/default/layouts/default.js","lib/output/themes/default/partials/index.js","lib/output/themes/lib.js","lib/output/themes/default/partials/analytics.js","lib/output/themes/default/partials/breadcrumb.js","lib/output/themes/default/partials/comment.js","lib/output/themes/default/partials/footer.js","lib/output/themes/default/partials/header.js","lib/output/themes/default/partials/hierarchy.js","lib/output/themes/default/partials/member.js","lib/output/themes/default/partials/anchor-icon.js","lib/output/themes/default/partials/member.declaration.js","lib/output/themes/default/partials/member.getterSetter.js","lib/output/themes/default/partials/member.reference.js","lib/output/themes/default/partials/member.signature.body.js","lib/output/themes/default/partials/member.signature.title.js","lib/output/themes/default/partials/member.signatures.js","lib/output/themes/default/partials/member.sources.js","lib/output/themes/default/partials/members.js","lib/output/themes/default/partials/members.group.js","lib/output/themes/default/partials/navigation.js","lib/output/themes/default/partials/parameter.js","lib/output/themes/default/partials/type.js","lib/output/themes/default/partials/typeAndParent.js","lib/output/themes/default/partials/typeParameters.js","lib/output/themes/default/templates/index.js","lib/output/themes/default/templates/reflection.js","lib/utils/highlighter.js","lib/output/plugins/index.js","lib/output/plugins/AssetsPlugin.js","lib/output/plugins/JavascriptIndexPlugin.js","lib/output/plugins/MarkedLinksPlugin.js","lib/output/themes/MarkedPlugin.js","lib/output/plugins/LegendPlugin.js","lib/serialization/index.js","lib/serialization/components.js","lib/serialization/events.js","lib/serialization/serializer.js","lib/serialization/serializers/index.js","lib/serialization/serializers/reflections/index.js","lib/serialization/serializers/reflections/abstract.js","lib/serialization/serializers/models/index.js","lib/serialization/serializers/models/source-reference-wrapper.js","lib/serialization/serializers/models/decorator-wrapper.js","lib/serialization/serializers/reflections/container.js","lib/serialization/serializers/reflections/declaration.js","lib/serialization/serializers/reflections/parameter.js","lib/serialization/serializers/reflections/reference.js","lib/serialization/serializers/reflections/signature.js","lib/serialization/serializers/reflections/type-parameter.js","lib/serialization/serializers/types/index.js","lib/serialization/serializers/types/abstract.js","lib/serialization/serializers/types/array.js","lib/serialization/serializers/types/conditional.js","lib/serialization/serializers/types/indexed-access.js","lib/serialization/serializers/types/inferred.js","lib/serialization/serializers/types/intersection.js","lib/serialization/serializers/types/intrinsic.js","lib/serialization/serializers/types/literal.js","lib/serialization/serializers/types/mapped.js","lib/serialization/serializers/types/optional.js","lib/serialization/serializers/types/predicate.js","lib/serialization/serializers/types/query.js","lib/serialization/serializers/types/reference.js","lib/serialization/serializers/types/reflection.js","lib/serialization/serializers/types/rest.js","lib/serialization/serializers/types/template-literal.js","lib/serialization/serializers/types/tuple.js","lib/serialization/serializers/types/type-operator.js","lib/serialization/serializers/types/union.js","lib/serialization/serializers/types/unknown.js","lib/serialization/serializers/comments/index.js","lib/serialization/serializers/comments/comment.js","lib/serialization/serializers/comments/comment-tag.js","lib/serialization/serializers/sources/index.js","lib/serialization/serializers/sources/source-reference.js","lib/serialization/serializers/decorator.js","lib/serialization/serializers/reflection-group.js","lib/serialization/serializers/reflection-category.js","lib/serialization/schema.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA,AIZA;ALgBA,AENA,AENA,ADGA,AFMA,AIZA;ALgBA,AENA,AENA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AENA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AENA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AENA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AKfA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AKfA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AKfA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ADGA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ADGA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ADGA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,ADGA,AFMA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,ADGA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,ADGA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,ADGA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ARwBA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ARwBA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ARwBA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AT2BA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AT2BA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AT2BA,AOrBA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,ACHA,AHSA,AT2BA,AIZA;ALgBA,AMlBA,AJYA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,ACHA,AHSA,AT2BA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,ACHA,AHSA,AT2BA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,ADGA,AHSA,AT2BA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,ADGA,AHSA,AT2BA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,ADGA,AHSA,AT2BA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,ADGA,AHSA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,ADGA,AHSA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,ADGA,AHSA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,AFMA,AHSA,AOrBA,ACHA,AENA,AENA,AHSA,AHSA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AENA,AENA,ANkBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AENA,AENA,ANkBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AENA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AENA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AENA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AMlBA,ACHA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA;ALgBA,AENA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA,Ac1CA;AnB0DA,AENA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA,Ac1CA;AnB0DA,AENA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,Ad0CA,AIZA,Ac1CA;AjBoDA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ACHA,APqBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA;AjBoDA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA;AjBoDA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA;AjBoDA,AOrBA,ALeA,AOrBA,ACHA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA;AnB0DA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA;AnB0DA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA;AnB0DA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,ACHA;ApB6DA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,ACHA;ApB6DA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,ACHA;ApB6DA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,ACHA,ACHA;ArBgEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,ACHA,ACHA;ArBgEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,ACHA,ACHA;ArBgEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA;ArBgEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA;ArBgEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA;ArBgEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA,AENA;AvBsEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA,AENA;AvBsEA,AOrBA,ALeA,AQxBA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA,AENA;AvBsEA,AOrBA,AGTA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA,AENA,ACHA;AxByEA,AOrBA,AGTA,AMlBA,AJYA,AENA,ANkBA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA,AENA,ACHA;AxByEA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,AFMA,ACHA,AENA,ACHA;AxByEA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AGTA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AGTA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AGTA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AKfA,AFMA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AKfA,AFMA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AKfA,AFMA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AFMA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AFMA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AFMA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AENA,AJYA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AENA,AJYA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AENA,AJYA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ADGA,AENA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,Ac1CA,AENA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,AENA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,AENA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,AENA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AJYA,AJYA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ae7CA,ADGA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,ARwBA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ae7CA,ADGA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,ARwBA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ae7CA,ADGA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ae7CA,ADGA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ae7CA,ADGA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AzB4EA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AU7BA,AnCyGA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AU7BA,AnCyGA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AU7BA,AnCyGA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AWhCA,ADGA,AnCyGA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AWhCA,ADGA,AnCyGA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AWhCA,ADGA,AnCyGA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AWhCA,ADGA,AENA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AWhCA,ADGA,AENA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AWhCA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AatCA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AatCA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AatCA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AczCA,ADGA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AczCA,ADGA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,AbuCA,Ac1CA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AczCA,ADGA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;Ae5CA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;Ae5CA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AOrBA,AGTA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;Ae5CA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AgB/CA,ADGA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AgB/CA,ADGA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AgB/CA,ADGA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,ACHA,A1B8EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,ADGA,ADGA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,ADGA,ADGA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,ADGA,ADGA,ADGA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,ADGA,ADGA,AGTA,AJYA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,ADGA,ADGA,AGTA,AJYA,ADGA,AFMA,ACHA,ArC+GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,ADGA,ADGA,AGTA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,AENA,AHSA,AENA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,AENA,AHSA,AENA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AiBlDA,AENA,AHSA,AENA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AmBxDA,AHSA,AIZA,AFMA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AmBxDA,AHSA,AIZA,AFMA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AmBxDA,AHSA,AIZA,AFMA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AmBxDA,AHSA,AIZA,ACHA,AHSA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AmBxDA,AHSA,AIZA,ACHA,AHSA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AmBxDA,AHSA,AIZA,ACHA,AHSA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,AHSA,AHSA,AIZA,ACHA,AHSA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,AHSA,AHSA,AIZA,ACHA,AHSA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,AHSA,AHSA,AIZA,ACHA,AHSA,AJYA,ADGA,AFMA,ApC4GA,AU9BA,AMlBA,AiBnDA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,AHSA,AHSA,AIZA,ACHA,AHSA,AKfA,AT2BA,ADGA,AFMA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,AHSA,AHSA,AIZA,ACHA,AHSA,AKfA,AT2BA,ADGA,AFMA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,AHSA,AHSA,AIZA,ACHA,AHSA,AKfA,AT2BA,ADGA,AFMA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AGTA,ANkBA,AKfA,AT2BA,ADGA,AFMA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AGTA,ANkBA,AKfA,AT2BA,AHSA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AGTA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AnByDA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AGTA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AgChGA,AnDyJA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AGTA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AgChGA,AnDyJA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AGTA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AgChGA,AnDyJA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AgChGA,AnDyJA,AIZA,A2BjFA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AKfA,AZoCA,ApC4GA,AU9BA,AuBrEA,AzB2EA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,ACHA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AFMA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AIZA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AIZA,ACHA,AKfA,AIZA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AIZA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AKfA,ADGA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AKfA,ADGA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AKfA,ADGA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,ACHA,ACHA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AKfA,ACHA,AFMA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AMlBA,AENA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AKfA,ACHA,AFMA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AKfA,AKfA,AKfA,ACHA,AFMA,ANkBA,ANkBA,AS3BA,AJYA,AMlBA,AlBsDA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AFMA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AFMA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AFMA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AgChGA,AnDyJA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AJYA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AJYA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AJYA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,ACHA,ALeA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,ACHA,ALeA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,ACHA,ALeA,ANkBA,ANkBA,AS3BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AQxBA,ALeA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,ACHA,ALeA,ANkBA,ANkBA,AkBtDA,AT2BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,ACHA,ALeA,ANkBA,ANkBA,AkBtDA,AT2BA,AJYA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,ACHA,ALeA,ANkBA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,AFMA,ALeA,ANkBA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,AFMA,ALeA,ANkBA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,AFMA,ALeA,ANkBA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AHSA,AXiCA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AKfA,AKfA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,A6BvFA,A5BoFA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AHSA,AXiCA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AHSA,AXiCA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AXiCA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,A+B7FA,ACHA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AXiCA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AXiCA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,AhBgDA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,AhBgDA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,AhBgDA,ANkBA,AkBtDA,AbuCA,AZoCA,ApC4GA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AsBjEA,ANkBA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AU9BA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A4DpLA,AlDsJA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A4DpLA,AlDsJA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A4DpLA,AlDsJA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AlDsJA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AlDsJA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AlDsJA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ApD4JA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA,ACHA;AgB/CA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ApD4JA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ApD4JA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,ArD+JA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,ArD+JA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,ArD+JA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,ACHA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,ACHA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,ACHA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,AENA,ADGA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,AENA,ADGA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,A6DvLA,ADGA,AENA,ACHA,AENA,ADGA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AtDkKA,AnByDA,AgChGA,AZoCA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AKfA,AKfA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AtDkKA,AnByDA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,AzD2KA,AnByDA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,AzD2KA,AnByDA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,AzD2KA,AnByDA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,A1D8KA,AnByDA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,A7EuOA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,A7EuOA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,AbuCA,AhDgJA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,ACHA,A9E0OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,ACHA,A9E0OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,ACHA,A9E0OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,ACHA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,AHSA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AU9BA,AFMA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,AHSA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,AHSA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,AJYA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,AJYA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,AJYA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ALeA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ALeA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ALeA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ANkBA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ANkBA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ANkBA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,AENA,ADGA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,APqBA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,APqBA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,APqBA,ACHA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,APqBA,AQxBA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,APqBA,AQxBA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,APqBA,AQxBA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AGTA,AOrBA,ALeA,ACHA,ACHA,ACHA,APqBA,AQxBA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,ALeA,ACHA,ACHA,ACHA,APqBA,AQxBA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,ALeA,ACHA,ACHA,ACHA,APqBA,AQxBA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,ALeA,ACHA,ACHA,AIZA,AFMA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,ALeA,ACHA,ACHA,AIZA,AFMA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,ALeA,ACHA,ACHA,AIZA,AFMA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,ALeA,ACHA,ACHA,AIZA,ACHA,AHSA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,AJYA,ACHA,AIZA,ACHA,AHSA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,AJYA,ACHA,AIZA,ACHA,AHSA,APqBA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,AJYA,ACHA,AIZA,ACHA,AHSA,AIZA,AXiCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,ACHA,AU9BA,AJYA,ACHA,AIZA,ACHA,AHSA,AIZA,AXiCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,AXiCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,AZoCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,AZoCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,AkBtDA,A7DuLA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,AZoCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,AbuCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,AbuCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,AbuCA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,Ad0CA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,Ad0CA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AOrBA,ACHA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,Ad0CA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,AIZA,AHSA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,Af6CA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,Af6CA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhBgDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhBgDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhBgDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AhBgDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AhBgDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AhBgDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,AENA,ACHA,ACHA,AENA,AENA,ADGA,AENA,AlBsDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AENA,AGTA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,AGTA,ACHA,AENA,AENA,ADGA,AENA,AlBsDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AIZA,AGTA,ACHA,AENA,AENA,ADGA,AENA,AlBsDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ADGA,AENA,ACHA,AnByDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AkEtMA,ALeA,AENA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ADGA,AENA,ACHA,AnByDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ADGA,AENA,ACHA,AnByDA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ApB4DA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ApB4DA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ApB4DA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ArB+DA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ArB+DA,A/E6OA,AoB5DA,AGTA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ArB+DA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AGTA,Ae7CA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AkBtDA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,A/E6OA,AuBrEA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,ACHA,AJYA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,A/E6OA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,A+D7LA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AgGhSA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AgGhSA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AgGhSA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,ACHA,AjBmDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ADGA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ADGA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ADGA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AFMA,AjCmGA,ACHA,AqB/DA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,AvGqTA,AwGxTA,AjFmPA,ADGA,AGTA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AFMA,AjCmGA,ACHA,AwBxEA,ACHA,ACHA,ACHA,AGTA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AFMA,AjCmGA,ACHA,AwBxEA,ACHA,ACHA,ACHA,AGTA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,ACHA,AHSA,AjCmGA,ACHA,AwBxEA,ACHA,ACHA,ACHA,AGTA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,ACHA,AHSA,AjCmGA,ACHA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,ACHA,AHSA,AjCmGA,ACHA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,ACHA,AHSA,AjCmGA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,ACHA,AHSA,AjCmGA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,ACHA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AvGqTA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AQxBA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AQxBA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AQxBA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ADGA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ADGA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ADGA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,A/G6UA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,AlHsVA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AZoCA,AU9BA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,AlHsVA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,AlHsVA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,AnHyVA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,AnHyVA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,AnHyVA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,ACHA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,ACHA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,ACHA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,AENA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AIZA,AS3BA,ACHA,AFMA,AGTA,ACHA,AENA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ACHA,AFMA,AGTA,ACHA,AENA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ACHA,AFMA,AGTA,ACHA,AGTA,ADGA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ACHA,AFMA,AGTA,ACHA,AGTA,ADGA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ACHA,AFMA,AGTA,ACHA,AGTA,ADGA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AKfA,AhBgDA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ACHA,AFMA,AGTA,ACHA,AGTA,ACHA,AFMA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ACHA,AFMA,AGTA,ACHA,AGTA,ACHA,AFMA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AGTA,ACHA,AFMA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,AFMA,ACHA,AFMA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,AFMA,ACHA,AFMA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ALeA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ALeA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ALeA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ACHA,ANkBA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ACHA,ANkBA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ACHA,ANkBA,ApH4VA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,ACHA,AKfA,ADGA,AFMA,AIZA,ACHA,ANkBA,AOrBA,A3HiXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,ACHA,ACHA,AavCA,ADGA,AGTA,AMlBA,ADGA,AFMA,AIZA,ACHA,ANkBA,AOrBA,A3HiXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AKfA,ACHA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,ADGA,AGTA,AMlBA,AHSA,AIZA,ACHA,ANkBA,AOrBA,A3HiXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AMlBA,AHSA,AIZA,ACHA,ACHA,ACHA,A5HoXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AMlBA,AHSA,AIZA,ACHA,ACHA,ACHA,A5HoXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,A5HoXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,A7HuXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,A7HuXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,A7HuXA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,AwBxEA,AENA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,A9H0XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,A9H0XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,A9H0XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AiGnSA,ACHA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AFMA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,A3CiIA,AQxBA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AavCA,AENA,AGTA,AIZA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AHSA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AHSA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AHSA,A/H6XA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AHSA,AIZA,AnIyYA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AHSA,AIZA,AnIyYA,AwGxTA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AHSA,AIZA,A3BiFA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AHSA,AIZA,ACHA,A5BoFA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AHSA,AIZA,ACHA,A5BoFA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AMlBA,ACHA,ACHA,AHSA,AIZA,ACHA,A5BoFA,AjFmPA,AENA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AMlBA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,A7BuFA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AGTA,AKfA,AMlBA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,A7BuFA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AQxBA,AMlBA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,A7BuFA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AQxBA,AMlBA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,A9B0FA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AQxBA,AOrBA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,A9B0FA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AQxBA,AOrBA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,A9B0FA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,Ae7CA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,A/B6FA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,Ae7CA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,A/B6FA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,Ae7CA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,A/B6FA,A/E6OA;AiBlDA,AiBnDA,AFMA,ACHA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,Ae7CA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,Ae7CA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AgBhDA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlCsGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlCsGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlCsGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AavCA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmBzDA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmBzDA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmBzDA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApC4GA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmBzDA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApC4GA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoB5DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApC4GA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AkGtSA,AGTA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoB5DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArC+GA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoB5DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArC+GA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArC+GA,A/E6OA;AiBlDA,AiBnDA,ADGA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtCkHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtCkHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtCkHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvCqHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvCqHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AqB/DA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvCqHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AuBrEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxCwHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AuBrEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxCwHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AwBxEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxCwHA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AwBxEA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AzC2HA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,ACHA,ACHA,ACHA,ACHA,ACHA,AzC2HA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,ACHA,ACHA,ACHA,ACHA,ACHA,AzC2HA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1C8HA,A/E6OA;AiBlDA,AgBhDA,AMlBA,AHSA,AXiCA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1C8HA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1C8HA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,A0B9EA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AkCtGA,ARwBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AkCtGA,ARwBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AkCtGA,ARwBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmCzGA,ADGA,ARwBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmCzGA,ADGA,ANkBA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AmCzGA,ADGA,ALeA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,ADGA,ALeA,ACHA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,ADGA,AJYA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,ALeA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AENA,APqBA,ACHA,ACHA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AENA,APqBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AENA,APqBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AENA,ACHA,ARwBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AENA,ACHA,ARwBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AENA,ACHA,ARwBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,ADGA,ARwBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,ADGA,ARwBA,AENA,ACHA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,ADGA,ARwBA,AGTA,A3CiIA,A/E6OA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,ACHA,AFMA,ARwBA,AGTA,A1H8WA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,ACHA,AFMA,ARwBA,AGTA,A1H8WA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,ACHA,AFMA,ARwBA,AvHqWA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,Ae7CA,AoC5GA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,A1C8HA,AoC5GA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA,A/H6XA;AiBlDA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ANkBA,ADGA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,APqBA,AIZA,AENA,ADGA,AFMA;A9G2UA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,APqBA,AIZA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AHSA,AENA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ADGA,ADGA;AhHiVA,AgBhDA,AMlBA,Ad0CA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ADGA,ADGA;AhHiVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,ADGA,ADGA;AhHiVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA,AFMA;AhHiVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA;AlHuVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA;AlHuVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA;AlHuVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA;AlHuVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA,AyD3KA;AlHuVA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,ApC4GA,A0B9EA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AFMA,ApC4GA,AqC/GA,AV8BA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AtCkHA,AqC/GA,AV8BA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AtCkHA,AqC/GA,AV8BA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AtCkHA,AqC/GA,AV8BA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AtCkHA,AqC/GA,AV8BA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,ADGA,AV8BA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzD4KA,AgBhDA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AzC4HA,ARwBA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA,AXiCA;AjDoJA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA,AqG/SA;A5DqLA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AyC1HA,ANkBA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AmCxGA,AnCyGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeScript = exports.SerializeEvent = exports.SerializerComponent = exports.Serializer = exports.JSONOutput = exports.EventHooks = exports.EntryPointStrategy = exports.TypeDocReader = exports.TSConfigReader = exports.ParameterType = exports.ParameterHint = exports.Options = exports.Logger = exports.LogLevel = exports.JSX = exports.BindOption = exports.ArgumentsReader = exports.MarkdownEvent = exports.RendererEvent = exports.PageEvent = exports.Theme = exports.UrlMapping = exports.DefaultThemeRenderContext = exports.DefaultTheme = exports.Renderer = exports.Context = exports.Converter = exports.normalizePath = exports.resetReflectionID = exports.Event = exports.EventDispatcher = exports.Application = void 0;\nvar application_1 = require(\"./lib/application\");\nObject.defineProperty(exports, \"Application\", { enumerable: true, get: function () { return application_1.Application; } });\nvar events_1 = require(\"./lib/utils/events\");\nObject.defineProperty(exports, \"EventDispatcher\", { enumerable: true, get: function () { return events_1.EventDispatcher; } });\nObject.defineProperty(exports, \"Event\", { enumerable: true, get: function () { return events_1.Event; } });\nvar abstract_1 = require(\"./lib/models/reflections/abstract\");\nObject.defineProperty(exports, \"resetReflectionID\", { enumerable: true, get: function () { return abstract_1.resetReflectionID; } });\nvar fs_1 = require(\"./lib/utils/fs\");\nObject.defineProperty(exports, \"normalizePath\", { enumerable: true, get: function () { return fs_1.normalizePath; } });\n__exportStar(require(\"./lib/models\"), exports);\nvar converter_1 = require(\"./lib/converter\");\nObject.defineProperty(exports, \"Converter\", { enumerable: true, get: function () { return converter_1.Converter; } });\nObject.defineProperty(exports, \"Context\", { enumerable: true, get: function () { return converter_1.Context; } });\nvar output_1 = require(\"./lib/output\");\nObject.defineProperty(exports, \"Renderer\", { enumerable: true, get: function () { return output_1.Renderer; } });\nObject.defineProperty(exports, \"DefaultTheme\", { enumerable: true, get: function () { return output_1.DefaultTheme; } });\nObject.defineProperty(exports, \"DefaultThemeRenderContext\", { enumerable: true, get: function () { return output_1.DefaultThemeRenderContext; } });\nObject.defineProperty(exports, \"UrlMapping\", { enumerable: true, get: function () { return output_1.UrlMapping; } });\nObject.defineProperty(exports, \"Theme\", { enumerable: true, get: function () { return output_1.Theme; } });\nObject.defineProperty(exports, \"PageEvent\", { enumerable: true, get: function () { return output_1.PageEvent; } });\nObject.defineProperty(exports, \"RendererEvent\", { enumerable: true, get: function () { return output_1.RendererEvent; } });\nObject.defineProperty(exports, \"MarkdownEvent\", { enumerable: true, get: function () { return output_1.MarkdownEvent; } });\nvar utils_1 = require(\"./lib/utils\");\nObject.defineProperty(exports, \"ArgumentsReader\", { enumerable: true, get: function () { return utils_1.ArgumentsReader; } });\nObject.defineProperty(exports, \"BindOption\", { enumerable: true, get: function () { return utils_1.BindOption; } });\nObject.defineProperty(exports, \"JSX\", { enumerable: true, get: function () { return utils_1.JSX; } });\nObject.defineProperty(exports, \"LogLevel\", { enumerable: true, get: function () { return utils_1.LogLevel; } });\nObject.defineProperty(exports, \"Logger\", { enumerable: true, get: function () { return utils_1.Logger; } });\nObject.defineProperty(exports, \"Options\", { enumerable: true, get: function () { return utils_1.Options; } });\nObject.defineProperty(exports, \"ParameterHint\", { enumerable: true, get: function () { return utils_1.ParameterHint; } });\nObject.defineProperty(exports, \"ParameterType\", { enumerable: true, get: function () { return utils_1.ParameterType; } });\nObject.defineProperty(exports, \"TSConfigReader\", { enumerable: true, get: function () { return utils_1.TSConfigReader; } });\nObject.defineProperty(exports, \"TypeDocReader\", { enumerable: true, get: function () { return utils_1.TypeDocReader; } });\nObject.defineProperty(exports, \"EntryPointStrategy\", { enumerable: true, get: function () { return utils_1.EntryPointStrategy; } });\nObject.defineProperty(exports, \"EventHooks\", { enumerable: true, get: function () { return utils_1.EventHooks; } });\nvar serialization_1 = require(\"./lib/serialization\");\nObject.defineProperty(exports, \"JSONOutput\", { enumerable: true, get: function () { return serialization_1.JSONOutput; } });\nObject.defineProperty(exports, \"Serializer\", { enumerable: true, get: function () { return serialization_1.Serializer; } });\nObject.defineProperty(exports, \"SerializerComponent\", { enumerable: true, get: function () { return serialization_1.SerializerComponent; } });\nObject.defineProperty(exports, \"SerializeEvent\", { enumerable: true, get: function () { return serialization_1.SerializeEvent; } });\nconst TypeScript = require(\"typescript\");\nexports.TypeScript = TypeScript;\n","\n// Backbone.js 1.2.3\n// (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n// Backbone may be freely distributed under the MIT license.\n// For all details and documentation:\n// https://backbonejs.org\n//\n// The Events object is a typesafe conversion of Backbones Events object:\n// https://github.com/jashkenas/backbone/blob/05fde9e201f7e2137796663081105cd6dad12a98/backbone.js#L119-L374\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventDispatcher = exports.Event = void 0;\nconst uniqueId = (function () {\n    const prefixes = Object.create(null);\n    return function (prefix) {\n        const unique = prefixes[prefix] || 1;\n        prefixes[prefix] = unique + 1;\n        return `${prefix}${unique}`;\n    };\n})();\nfunction once(cb) {\n    let hasRun = false;\n    let result;\n    return function (...args) {\n        if (hasRun === false) {\n            hasRun = true;\n            result = cb.apply(this, args);\n        }\n        return result;\n    };\n}\n// Regular expression used to split event strings.\nconst eventSplitter = /\\s+/;\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple\n * space-separated events `\"change blur\", callback` and jQuery-style event\n * maps `{event: callback}`).\n */\nfunction eventsApi(iteratee, events, name, callback, options) {\n    let i = 0, names;\n    const anyOptions = options;\n    if (name && typeof name === \"object\") {\n        // Handle event maps.\n        if (callback !== void 0 &&\n            \"context\" in options &&\n            anyOptions[\"context\"] === void 0) {\n            anyOptions[\"context\"] = callback;\n        }\n        for (names = Object.keys(name); i < names.length; i++) {\n            events = eventsApi(iteratee, events, names[i], name[names[i]], options);\n        }\n    }\n    else if (name && typeof name === \"string\" && eventSplitter.test(name)) {\n        // Handle space separated event names by delegating them individually.\n        for (names = name.split(eventSplitter); i < names.length; i++) {\n            events = iteratee(events, names[i], callback, options);\n        }\n    }\n    else {\n        // Finally, standard events.\n        events = iteratee(events, name, callback, options);\n    }\n    return events;\n}\n/**\n * The reducing API that adds a callback to the `events` object.\n */\nfunction onApi(events, name, callback, options) {\n    if (callback) {\n        const handlers = events[name] || (events[name] = []);\n        const context = options.context, ctx = options.ctx, listening = options.listening, priority = options.priority;\n        if (listening) {\n            listening.count++;\n        }\n        handlers.push({\n            callback: callback,\n            context: context,\n            ctx: context || ctx,\n            listening: listening,\n            priority: priority,\n        });\n        handlers.sort((a, b) => b.priority - a.priority);\n    }\n    return events;\n}\n/**\n * The reducing API that removes a callback from the `events` object.\n */\nfunction offApi(events, name, callback, options) {\n    if (!events) {\n        return;\n    }\n    let i = 0, listening;\n    const context = options.context, listeners = options.listeners;\n    // Delete all events listeners and \"drop\" events.\n    if (!name && !callback && !context) {\n        const ids = Object.keys(listeners || {});\n        for (; i < ids.length; i++) {\n            listening = listeners[ids[i]];\n            delete listeners[listening.id];\n            delete listening.listeningTo[listening.objId];\n        }\n        return;\n    }\n    const names = name ? [name] : Object.keys(events || {});\n    for (; i < names.length; i++) {\n        name = names[i];\n        const handlers = events[name];\n        // Bail out if there are no events stored.\n        if (!handlers) {\n            break;\n        }\n        // Replace events if there are any remaining.  Otherwise, clean up.\n        const remaining = [];\n        for (let j = 0; j < handlers.length; j++) {\n            const handler = handlers[j];\n            if ((callback &&\n                callback !== handler.callback &&\n                callback !== handler.callback._callback) ||\n                (context && context !== handler.context)) {\n                remaining.push(handler);\n            }\n            else {\n                listening = handler.listening;\n                if (listening && --listening.count === 0) {\n                    delete listeners[listening.id];\n                    delete listening.listeningTo[listening.objId];\n                }\n            }\n        }\n        // Update tail event if the list has any events.  Otherwise, clean up.\n        if (remaining.length) {\n            events[name] = remaining;\n        }\n        else {\n            delete events[name];\n        }\n    }\n    if (Object.keys(events || {}).length !== 0) {\n        return events;\n    }\n}\n/**\n * Reduces the event callbacks into a map of `{event: onceWrapper`.}\n * `offer` unbinds the `onceWrapper` after it has been called.\n */\nfunction onceMap(map, name, callback, offer) {\n    if (callback) {\n        const listener = (map[name] = once(function (...args) {\n            offer(name, listener);\n            callback.apply(this, args);\n        }));\n        listener._callback = callback;\n    }\n    return map;\n}\n/**\n * Handles triggering the appropriate event callbacks.\n */\nfunction triggerApi(objEvents, name, _callback, args, triggerer = triggerEvents) {\n    if (objEvents) {\n        const events = objEvents[name];\n        let allEvents = objEvents[\"all\"];\n        if (events && allEvents) {\n            allEvents = allEvents.slice();\n        }\n        if (events) {\n            triggerer(events, args);\n        }\n        if (allEvents) {\n            triggerer(allEvents, [name].concat(args));\n        }\n    }\n    return objEvents;\n}\n/**\n * A difficult-to-believe, but optimized internal dispatch function for\n * triggering events. Tries to keep the usual cases speedy (most internal\n * Backbone events have 3 arguments).\n */\nfunction triggerEvents(events, args) {\n    let ev, i = -1;\n    const l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n        case 0:\n            while (++i < l) {\n                (ev = events[i]).callback.call(ev.ctx);\n            }\n            return;\n        case 1:\n            while (++i < l) {\n                (ev = events[i]).callback.call(ev.ctx, a1);\n            }\n            return;\n        case 2:\n            while (++i < l) {\n                (ev = events[i]).callback.call(ev.ctx, a1, a2);\n            }\n            return;\n        case 3:\n            while (++i < l) {\n                (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n            }\n            return;\n        default:\n            while (++i < l) {\n                (ev = events[i]).callback.apply(ev.ctx, args);\n            }\n            return;\n    }\n}\n/**\n * An event object.\n */\nclass Event {\n    /**\n     * Create a new Event instance.\n     */\n    constructor(name) {\n        /**\n         * Has {@link Event.stopPropagation} been called?\n         */\n        this._isPropagationStopped = false;\n        /**\n         * Has {@link Event.preventDefault} been called?\n         */\n        this._isDefaultPrevented = false;\n        this._name = name;\n    }\n    /**\n     * Stop the propagation of this event. Remaining event handlers will not be executed.\n     */\n    stopPropagation() {\n        this._isPropagationStopped = true;\n    }\n    /**\n     * Prevent the default action associated with this event from being executed.\n     */\n    preventDefault() {\n        this._isDefaultPrevented = true;\n    }\n    /**\n     * Return the event name.\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * Has {@link Event.stopPropagation} been called?\n     */\n    get isPropagationStopped() {\n        return this._isPropagationStopped;\n    }\n    /**\n     * Has {@link Event.preventDefault} been called?\n     */\n    get isDefaultPrevented() {\n        return this._isDefaultPrevented;\n    }\n}\nexports.Event = Event;\n/**\n * A class that provides a custom event channel.\n *\n * You may bind a callback to an event with `on` or remove with `off`;\n * `trigger`-ing an event fires all callbacks in succession.\n */\nclass EventDispatcher {\n    /**\n     * A unique id that identifies this instance.\n     */\n    get _listenId() {\n        return this._savedListenId || (this._savedListenId = uniqueId(\"l\"));\n    }\n    on(nameOrMap, callback, context, priority) {\n        this.internalOn(nameOrMap, callback, context, priority);\n        return this;\n    }\n    /**\n     * Guard the `listening` argument from the public API.\n     */\n    internalOn(name, callback, context, priority = 0, listening) {\n        this._events = eventsApi(onApi, this._events || {}, name, callback, {\n            context: context,\n            ctx: this,\n            listening: listening,\n            priority: priority,\n        });\n        if (listening) {\n            const listeners = this._listeners || (this._listeners = {});\n            listeners[listening.id] = listening;\n        }\n    }\n    once(name, callback, context, priority) {\n        // Map the event into a `{event: once}` object.\n        const events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n        return this.on(events, void 0, context, priority);\n    }\n    off(name, callback, context) {\n        if (!this._events) {\n            return this;\n        }\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: context,\n            listeners: this._listeners,\n        });\n        return this;\n    }\n    /**\n     * Inversion-of-control versions of `on`. Tell *this* object to listen to\n     * an event in another object... keeping track of what it's listening to\n     * for easier unbinding later.\n     */\n    listenTo(obj, name, callback, priority) {\n        if (!obj) {\n            return this;\n        }\n        const id = obj._listenId;\n        const listeningTo = this._listeningTo || (this._listeningTo = {});\n        let listening = listeningTo[id];\n        // This object is not listening to any other events on `obj` yet.\n        // Setup the necessary references to track the listening callbacks.\n        if (!listening) {\n            const thisId = this._listenId;\n            listening = listeningTo[id] = {\n                obj: obj,\n                objId: id,\n                id: thisId,\n                listeningTo: listeningTo,\n                count: 0,\n            };\n        }\n        // Bind callbacks on obj, and keep track of them on listening.\n        obj.internalOn(name, callback, this, priority, listening);\n        return this;\n    }\n    listenToOnce(obj, name, callback, priority) {\n        // Map the event into a `{event: once}` object.\n        const events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n        return this.listenTo(obj, events, void 0, priority);\n    }\n    /**\n     * Tell this object to stop listening to either specific events ... or\n     * to every object it's currently listening to.\n     */\n    stopListening(obj, name, callback) {\n        const listeningTo = this._listeningTo;\n        if (!listeningTo) {\n            return this;\n        }\n        const ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n        for (let i = 0; i < ids.length; i++) {\n            const listening = listeningTo[ids[i]];\n            // If listening doesn't exist, this object is not currently\n            // listening to obj. Break out early.\n            if (!listening) {\n                break;\n            }\n            listening.obj.off(name, callback, this);\n        }\n        if (Object.keys(listeningTo).length === 0) {\n            this._listeningTo = void 0;\n        }\n        return this;\n    }\n    /**\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\n     * passed the same arguments as `trigger` is, apart from the event name\n     * (unless you're listening on `\"all\"`, which will cause your callback to\n     * receive the true name of the event as the first argument).\n     */\n    trigger(name, ...args) {\n        if (!this._events) {\n            return this;\n        }\n        if (name instanceof Event) {\n            triggerApi(this._events, name.name, void 0, [name], (events, args) => {\n                let ev, i = -1;\n                const l = events.length;\n                while (++i < l) {\n                    if (name.isPropagationStopped) {\n                        return;\n                    }\n                    ev = events[i];\n                    ev.callback.apply(ev.ctx, args);\n                }\n            });\n        }\n        else {\n            eventsApi(triggerApi, this._events, name, void 0, args);\n        }\n        return this;\n    }\n}\nexports.EventDispatcher = EventDispatcher;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Reflection = exports.TraverseProperty = exports.ReflectionFlags = exports.ReflectionFlag = exports.resetReflectionID = void 0;\nconst assert_1 = require(\"assert\");\nconst utils_1 = require(\"./utils\");\nconst kind_1 = require(\"./kind\");\n/**\n * Holds all data models used by TypeDoc.\n *\n * The {@link BaseReflection} is base class of all reflection models. The subclass {@link ProjectReflection}\n * serves as the root container for the current project while {@link DeclarationReflection} instances\n * form the structure of the project. Most of the other classes in this namespace are referenced by this\n * two base classes.\n *\n * The models {@link NavigationItem} and {@link UrlMapping} are special as they are only used by the {@link Renderer}\n * while creating the final output.\n */\n/**\n * Current reflection id.\n */\nlet REFLECTION_ID = 0;\n/**\n * Reset the reflection id.\n *\n * Used by the test cases to ensure the reflection ids won't change between runs.\n */\nfunction resetReflectionID() {\n    REFLECTION_ID = 0;\n}\nexports.resetReflectionID = resetReflectionID;\nvar ReflectionFlag;\n(function (ReflectionFlag) {\n    ReflectionFlag[ReflectionFlag[\"None\"] = 0] = \"None\";\n    ReflectionFlag[ReflectionFlag[\"Private\"] = 1] = \"Private\";\n    ReflectionFlag[ReflectionFlag[\"Protected\"] = 2] = \"Protected\";\n    ReflectionFlag[ReflectionFlag[\"Public\"] = 4] = \"Public\";\n    ReflectionFlag[ReflectionFlag[\"Static\"] = 8] = \"Static\";\n    ReflectionFlag[ReflectionFlag[\"ExportAssignment\"] = 16] = \"ExportAssignment\";\n    ReflectionFlag[ReflectionFlag[\"External\"] = 32] = \"External\";\n    ReflectionFlag[ReflectionFlag[\"Optional\"] = 64] = \"Optional\";\n    ReflectionFlag[ReflectionFlag[\"DefaultValue\"] = 128] = \"DefaultValue\";\n    ReflectionFlag[ReflectionFlag[\"Rest\"] = 256] = \"Rest\";\n    ReflectionFlag[ReflectionFlag[\"Abstract\"] = 512] = \"Abstract\";\n    ReflectionFlag[ReflectionFlag[\"Const\"] = 1024] = \"Const\";\n    ReflectionFlag[ReflectionFlag[\"Let\"] = 2048] = \"Let\";\n    ReflectionFlag[ReflectionFlag[\"Readonly\"] = 4096] = \"Readonly\";\n})(ReflectionFlag = exports.ReflectionFlag || (exports.ReflectionFlag = {}));\nconst relevantFlags = [\n    ReflectionFlag.Private,\n    ReflectionFlag.Protected,\n    ReflectionFlag.Static,\n    ReflectionFlag.ExportAssignment,\n    ReflectionFlag.Optional,\n    ReflectionFlag.DefaultValue,\n    ReflectionFlag.Rest,\n    ReflectionFlag.Abstract,\n    ReflectionFlag.Const,\n    ReflectionFlag.Readonly,\n];\n/**\n * This must extend Array in order to work with Handlebar's each helper.\n */\nclass ReflectionFlags extends Array {\n    constructor() {\n        super(...arguments);\n        this.flags = ReflectionFlag.None;\n    }\n    hasFlag(flag) {\n        return (flag & this.flags) !== 0;\n    }\n    /**\n     * Is this a private member?\n     */\n    get isPrivate() {\n        return this.hasFlag(ReflectionFlag.Private);\n    }\n    /**\n     * Is this a protected member?\n     */\n    get isProtected() {\n        return this.hasFlag(ReflectionFlag.Protected);\n    }\n    /**\n     * Is this a public member?\n     */\n    get isPublic() {\n        return this.hasFlag(ReflectionFlag.Public);\n    }\n    /**\n     * Is this a static member?\n     */\n    get isStatic() {\n        return this.hasFlag(ReflectionFlag.Static);\n    }\n    /**\n     * Is this a declaration from an external document?\n     */\n    get isExternal() {\n        return this.hasFlag(ReflectionFlag.External);\n    }\n    /**\n     * Whether this reflection is an optional component or not.\n     *\n     * Applies to function parameters and object members.\n     */\n    get isOptional() {\n        return this.hasFlag(ReflectionFlag.Optional);\n    }\n    /**\n     * Whether it's a rest parameter, like `foo(...params);`.\n     */\n    get isRest() {\n        return this.hasFlag(ReflectionFlag.Rest);\n    }\n    get hasExportAssignment() {\n        return this.hasFlag(ReflectionFlag.ExportAssignment);\n    }\n    get isAbstract() {\n        return this.hasFlag(ReflectionFlag.Abstract);\n    }\n    get isConst() {\n        return this.hasFlag(ReflectionFlag.Const);\n    }\n    get isReadonly() {\n        return this.hasFlag(ReflectionFlag.Readonly);\n    }\n    setFlag(flag, set) {\n        switch (flag) {\n            case ReflectionFlag.Private:\n                this.setSingleFlag(ReflectionFlag.Private, set);\n                if (set) {\n                    this.setFlag(ReflectionFlag.Protected, false);\n                    this.setFlag(ReflectionFlag.Public, false);\n                }\n                break;\n            case ReflectionFlag.Protected:\n                this.setSingleFlag(ReflectionFlag.Protected, set);\n                if (set) {\n                    this.setFlag(ReflectionFlag.Private, false);\n                    this.setFlag(ReflectionFlag.Public, false);\n                }\n                break;\n            case ReflectionFlag.Public:\n                this.setSingleFlag(ReflectionFlag.Public, set);\n                if (set) {\n                    this.setFlag(ReflectionFlag.Private, false);\n                    this.setFlag(ReflectionFlag.Protected, false);\n                }\n                break;\n            default:\n                this.setSingleFlag(flag, set);\n        }\n    }\n    setSingleFlag(flag, set) {\n        const name = ReflectionFlag[flag].replace(/(.)([A-Z])/g, (_m, a, b) => a + \" \" + b.toLowerCase());\n        if (!set && this.hasFlag(flag)) {\n            if (relevantFlags.includes(flag)) {\n                this.splice(this.indexOf(name), 1);\n            }\n            this.flags ^= flag;\n        }\n        else if (set && !this.hasFlag(flag)) {\n            if (relevantFlags.includes(flag)) {\n                this.push(name);\n            }\n            this.flags |= flag;\n        }\n    }\n}\nexports.ReflectionFlags = ReflectionFlags;\nvar TraverseProperty;\n(function (TraverseProperty) {\n    TraverseProperty[TraverseProperty[\"Children\"] = 0] = \"Children\";\n    TraverseProperty[TraverseProperty[\"Parameters\"] = 1] = \"Parameters\";\n    TraverseProperty[TraverseProperty[\"TypeLiteral\"] = 2] = \"TypeLiteral\";\n    TraverseProperty[TraverseProperty[\"TypeParameter\"] = 3] = \"TypeParameter\";\n    TraverseProperty[TraverseProperty[\"Signatures\"] = 4] = \"Signatures\";\n    TraverseProperty[TraverseProperty[\"IndexSignature\"] = 5] = \"IndexSignature\";\n    TraverseProperty[TraverseProperty[\"GetSignature\"] = 6] = \"GetSignature\";\n    TraverseProperty[TraverseProperty[\"SetSignature\"] = 7] = \"SetSignature\";\n})(TraverseProperty = exports.TraverseProperty || (exports.TraverseProperty = {}));\n/**\n * Base class for all reflection classes.\n *\n * While generating a documentation, TypeDoc generates an instance of {@link ProjectReflection}\n * as the root for all reflections within the project. All other reflections are represented\n * by the {@link DeclarationReflection} class.\n *\n * This base class exposes the basic properties one may use to traverse the reflection tree.\n * You can use the {@link ContainerReflection.children} and {@link parent} properties to walk the tree. The {@link groups} property\n * contains a list of all children grouped and sorted for being rendered.\n */\nclass Reflection {\n    /**\n     * Create a new BaseReflection instance.\n     */\n    constructor(name, kind, parent) {\n        this.flags = new ReflectionFlags();\n        this.id = REFLECTION_ID++;\n        this.parent = parent;\n        this.name = name;\n        this.originalName = name;\n        this.kind = kind;\n        // If our parent is external, we are too.\n        if (parent === null || parent === void 0 ? void 0 : parent.flags.isExternal) {\n            this.setFlag(ReflectionFlag.External);\n        }\n    }\n    get project() {\n        if (this.isProject())\n            return this;\n        (0, assert_1.ok)(this.parent, \"Tried to get the project on a reflection not in a project\");\n        return this.parent.project;\n    }\n    /**\n     * Test whether this reflection is of the given kind.\n     */\n    kindOf(kind) {\n        const kindArray = Array.isArray(kind) ? kind : [kind];\n        return kindArray.some((kind) => (this.kind & kind) !== 0);\n    }\n    /**\n     * Return the full name of this reflection. Intended for use in debugging. For log messages\n     * intended to be displayed to the user for them to fix, prefer {@link getFriendlyFullName} instead.\n     *\n     * The full name contains the name of this reflection and the names of all parent reflections.\n     *\n     * @param separator  Separator used to join the names of the reflections.\n     * @returns The full name of this reflection.\n     */\n    getFullName(separator = \".\") {\n        if (this.parent && !this.parent.isProject()) {\n            return this.parent.getFullName(separator) + separator + this.name;\n        }\n        else {\n            return this.name;\n        }\n    }\n    /**\n     * Return the full name of this reflection, with signature names dropped if possible without\n     * introducing ambiguity in the name.\n     */\n    getFriendlyFullName() {\n        if (this.parent && !this.parent.isProject()) {\n            if (this.kindOf(kind_1.ReflectionKind.ConstructorSignature |\n                kind_1.ReflectionKind.CallSignature |\n                kind_1.ReflectionKind.GetSignature |\n                kind_1.ReflectionKind.SetSignature)) {\n                return this.parent.getFriendlyFullName();\n            }\n            return this.parent.getFriendlyFullName() + \".\" + this.name;\n        }\n        else {\n            return this.name;\n        }\n    }\n    /**\n     * Set a flag on this reflection.\n     */\n    setFlag(flag, value = true) {\n        this.flags.setFlag(flag, value);\n    }\n    /**\n     * Return an url safe alias for this reflection.\n     */\n    getAlias() {\n        if (!this._alias) {\n            let alias = this.name.replace(/[^a-z0-9]/gi, \"_\");\n            if (alias === \"\") {\n                alias = \"reflection-\" + this.id;\n            }\n            let target = this;\n            while (target.parent &&\n                !target.parent.isProject() &&\n                !target.hasOwnDocument) {\n                target = target.parent;\n            }\n            if (!target._aliases) {\n                target._aliases = new Map();\n            }\n            let suffix = \"\";\n            if (!target._aliases.has(alias)) {\n                target._aliases.set(alias, 1);\n            }\n            else {\n                const count = target._aliases.get(alias);\n                suffix = \"-\" + count.toString();\n                target._aliases.set(alias, count + 1);\n            }\n            alias += suffix;\n            this._alias = alias;\n        }\n        return this._alias;\n    }\n    /**\n     * Has this reflection a visible comment?\n     *\n     * @returns TRUE when this reflection has a visible comment.\n     */\n    hasComment() {\n        return this.comment ? this.comment.hasVisibleComponent() : false;\n    }\n    hasGetterOrSetter() {\n        return false;\n    }\n    /**\n     * Return a child by its name.\n     *\n     * @param names The name hierarchy of the child to look for.\n     * @returns The found child or undefined.\n     */\n    getChildByName(arg) {\n        const names = Array.isArray(arg)\n            ? arg\n            : (0, utils_1.splitUnquotedString)(arg, \".\");\n        const name = names[0];\n        let result;\n        this.traverse((child) => {\n            if (child.name === name) {\n                if (names.length <= 1) {\n                    result = child;\n                }\n                else {\n                    result = child.getChildByName(names.slice(1));\n                }\n                return false;\n            }\n            return true;\n        });\n        return result;\n    }\n    /**\n     * Return whether this reflection is the root / project reflection.\n     */\n    isProject() {\n        return false;\n    }\n    /**\n     * Try to find a reflection by its name.\n     *\n     * @return The found reflection or null.\n     */\n    findReflectionByName(arg) {\n        const names = Array.isArray(arg)\n            ? arg\n            : (0, utils_1.splitUnquotedString)(arg, \".\");\n        const reflection = this.getChildByName(names);\n        if (reflection) {\n            return reflection;\n        }\n        else if (this.parent) {\n            return this.parent.findReflectionByName(names);\n        }\n    }\n    /**\n     * Traverse all potential child reflections of this reflection.\n     *\n     * The given callback will be invoked for all children, signatures and type parameters\n     * attached to this reflection.\n     *\n     * @param callback  The callback function that should be applied for each child reflection.\n     */\n    traverse(_callback) {\n        // do nothing here, overridden by child classes\n    }\n    /**\n     * Return a string representation of this reflection.\n     */\n    toString() {\n        return kind_1.ReflectionKind[this.kind] + \" \" + this.name;\n    }\n    /**\n     * Return a string representation of this reflection and all of its children.\n     *\n     * @param indent  Used internally to indent child reflections.\n     */\n    toStringHierarchy(indent = \"\") {\n        const lines = [indent + this.toString()];\n        indent += \"  \";\n        this.traverse((child) => {\n            lines.push(child.toStringHierarchy(indent));\n            return true;\n        });\n        return lines.join(\"\\n\");\n    }\n}\nexports.Reflection = Reflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.splitUnquotedString = void 0;\nfunction splitUnquotedString(input, delimiter) {\n    if (input.startsWith(delimiter)) {\n        return splitUnquotedString(input.substring(delimiter.length), delimiter);\n    }\n    if (input.startsWith('\"')) {\n        // the part inside the quotes should not be split, the rest should\n        const closingQuoteIndex = input.indexOf('\"', 1);\n        if (closingQuoteIndex === -1) {\n            // Unmatched quotes, just split it\n            return input.split(delimiter);\n        }\n        if (closingQuoteIndex === input.length - 1) {\n            return [input];\n        }\n        else {\n            const remainder = input.substring(closingQuoteIndex + 1);\n            const result = [input.substring(0, closingQuoteIndex + 1)];\n            result.push(...splitUnquotedString(remainder, delimiter));\n            return result;\n        }\n    }\n    else {\n        return input.split(delimiter);\n    }\n}\nexports.splitUnquotedString = splitUnquotedString;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionKind = void 0;\n/**\n * Defines the available reflection kinds.\n */\nvar ReflectionKind;\n(function (ReflectionKind) {\n    ReflectionKind[ReflectionKind[\"Project\"] = 1] = \"Project\";\n    ReflectionKind[ReflectionKind[\"Module\"] = 2] = \"Module\";\n    ReflectionKind[ReflectionKind[\"Namespace\"] = 4] = \"Namespace\";\n    ReflectionKind[ReflectionKind[\"Enum\"] = 8] = \"Enum\";\n    ReflectionKind[ReflectionKind[\"EnumMember\"] = 16] = \"EnumMember\";\n    ReflectionKind[ReflectionKind[\"Variable\"] = 32] = \"Variable\";\n    ReflectionKind[ReflectionKind[\"Function\"] = 64] = \"Function\";\n    ReflectionKind[ReflectionKind[\"Class\"] = 128] = \"Class\";\n    ReflectionKind[ReflectionKind[\"Interface\"] = 256] = \"Interface\";\n    ReflectionKind[ReflectionKind[\"Constructor\"] = 512] = \"Constructor\";\n    ReflectionKind[ReflectionKind[\"Property\"] = 1024] = \"Property\";\n    ReflectionKind[ReflectionKind[\"Method\"] = 2048] = \"Method\";\n    ReflectionKind[ReflectionKind[\"CallSignature\"] = 4096] = \"CallSignature\";\n    ReflectionKind[ReflectionKind[\"IndexSignature\"] = 8192] = \"IndexSignature\";\n    ReflectionKind[ReflectionKind[\"ConstructorSignature\"] = 16384] = \"ConstructorSignature\";\n    ReflectionKind[ReflectionKind[\"Parameter\"] = 32768] = \"Parameter\";\n    ReflectionKind[ReflectionKind[\"TypeLiteral\"] = 65536] = \"TypeLiteral\";\n    ReflectionKind[ReflectionKind[\"TypeParameter\"] = 131072] = \"TypeParameter\";\n    ReflectionKind[ReflectionKind[\"Accessor\"] = 262144] = \"Accessor\";\n    ReflectionKind[ReflectionKind[\"GetSignature\"] = 524288] = \"GetSignature\";\n    ReflectionKind[ReflectionKind[\"SetSignature\"] = 1048576] = \"SetSignature\";\n    ReflectionKind[ReflectionKind[\"ObjectLiteral\"] = 2097152] = \"ObjectLiteral\";\n    ReflectionKind[ReflectionKind[\"TypeAlias\"] = 4194304] = \"TypeAlias\";\n    ReflectionKind[ReflectionKind[\"Event\"] = 8388608] = \"Event\";\n    ReflectionKind[ReflectionKind[\"Reference\"] = 16777216] = \"Reference\";\n})(ReflectionKind = exports.ReflectionKind || (exports.ReflectionKind = {}));\n/** @hidden */\n(function (ReflectionKind) {\n    ReflectionKind.All = ReflectionKind.Reference * 2 - 1;\n    ReflectionKind.ClassOrInterface = ReflectionKind.Class | ReflectionKind.Interface;\n    ReflectionKind.VariableOrProperty = ReflectionKind.Variable | ReflectionKind.Property;\n    ReflectionKind.FunctionOrMethod = ReflectionKind.Function | ReflectionKind.Method;\n    ReflectionKind.ClassMember = ReflectionKind.Accessor |\n        ReflectionKind.Constructor |\n        ReflectionKind.Method |\n        ReflectionKind.Property |\n        ReflectionKind.Event;\n    ReflectionKind.SomeSignature = ReflectionKind.CallSignature |\n        ReflectionKind.IndexSignature |\n        ReflectionKind.ConstructorSignature |\n        ReflectionKind.GetSignature |\n        ReflectionKind.SetSignature;\n    ReflectionKind.SomeModule = ReflectionKind.Namespace | ReflectionKind.Module;\n    ReflectionKind.SomeType = ReflectionKind.Interface |\n        ReflectionKind.TypeLiteral |\n        ReflectionKind.TypeParameter |\n        ReflectionKind.TypeAlias;\n    ReflectionKind.SomeValue = ReflectionKind.Variable |\n        ReflectionKind.Function |\n        ReflectionKind.ObjectLiteral;\n    /** @internal */\n    ReflectionKind.Inheritable = ReflectionKind.Accessor |\n        ReflectionKind.IndexSignature |\n        ReflectionKind.Property |\n        ReflectionKind.Method |\n        ReflectionKind.Constructor;\n})(ReflectionKind = exports.ReflectionKind || (exports.ReflectionKind = {}));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.remove = exports.copySync = exports.copy = exports.writeFile = exports.writeFileSync = exports.readFile = exports.normalizePath = exports.getCommonDirectory = void 0;\nconst fs = require(\"fs\");\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\n/**\n * Get the longest directory path common to all files.\n */\nfunction getCommonDirectory(files) {\n    if (!files.length) {\n        return \"\";\n    }\n    const roots = files.map((f) => f.split(/\\\\|\\//));\n    if (roots.length === 1) {\n        return roots[0].slice(0, -1).join(\"/\");\n    }\n    let i = 0;\n    while (new Set(roots.map((part) => part[i])).size === 1) {\n        i++;\n    }\n    return roots[0].slice(0, i).join(\"/\");\n}\nexports.getCommonDirectory = getCommonDirectory;\n/**\n * Normalize the given path.\n *\n * @param path  The path that should be normalized.\n * @returns The normalized path.\n */\nfunction normalizePath(path) {\n    return path.replace(/\\\\/g, \"/\");\n}\nexports.normalizePath = normalizePath;\n/**\n * Load the given file and return its contents.\n *\n * @param file  The path of the file to read.\n * @returns The files contents.\n */\nfunction readFile(file) {\n    const buffer = fs.readFileSync(file);\n    switch (buffer[0]) {\n        case 0xfe:\n            if (buffer[1] === 0xff) {\n                let i = 0;\n                while (i + 1 < buffer.length) {\n                    const temp = buffer[i];\n                    buffer[i] = buffer[i + 1];\n                    buffer[i + 1] = temp;\n                    i += 2;\n                }\n                return buffer.toString(\"ucs2\", 2);\n            }\n            break;\n        case 0xff:\n            if (buffer[1] === 0xfe) {\n                return buffer.toString(\"ucs2\", 2);\n            }\n            break;\n        case 0xef:\n            if (buffer[1] === 0xbb) {\n                return buffer.toString(\"utf8\", 3);\n            }\n    }\n    return buffer.toString(\"utf8\", 0);\n}\nexports.readFile = readFile;\n/**\n * Write a file to disc.\n *\n * If the containing directory does not exist it will be created.\n *\n * @param fileName  The name of the file that should be written.\n * @param data  The contents of the file.\n */\nfunction writeFileSync(fileName, data) {\n    fs.mkdirSync((0, path_1.dirname)(normalizePath(fileName)), { recursive: true });\n    fs.writeFileSync(normalizePath(fileName), data);\n}\nexports.writeFileSync = writeFileSync;\n/**\n * Write a file to disc.\n *\n * If the containing directory does not exist it will be created.\n *\n * @param fileName  The name of the file that should be written.\n * @param data  The contents of the file.\n */\nasync function writeFile(fileName, data) {\n    await fs_1.promises.mkdir((0, path_1.dirname)(normalizePath(fileName)), {\n        recursive: true,\n    });\n    await fs_1.promises.writeFile(normalizePath(fileName), data);\n}\nexports.writeFile = writeFile;\n/**\n * Copy a file or directory recursively.\n */\nasync function copy(src, dest) {\n    const stat = await fs_1.promises.stat(src);\n    if (stat.isDirectory()) {\n        const contained = await fs_1.promises.readdir(src);\n        await Promise.all(contained.map((file) => copy((0, path_1.join)(src, file), (0, path_1.join)(dest, file))));\n    }\n    else if (stat.isFile()) {\n        await fs_1.promises.mkdir((0, path_1.dirname)(dest), { recursive: true });\n        await fs_1.promises.copyFile(src, dest);\n    }\n    else {\n        // Do nothing for FIFO, special devices.\n    }\n}\nexports.copy = copy;\nfunction copySync(src, dest) {\n    const stat = fs.statSync(src);\n    if (stat.isDirectory()) {\n        const contained = fs.readdirSync(src);\n        contained.forEach((file) => copySync((0, path_1.join)(src, file), (0, path_1.join)(dest, file)));\n    }\n    else if (stat.isFile()) {\n        fs.mkdirSync((0, path_1.dirname)(dest), { recursive: true });\n        fs.copyFileSync(src, dest);\n    }\n    else {\n        // Do nothing for FIFO, special devices.\n    }\n}\nexports.copySync = copySync;\n/**\n * Equivalent to rm -rf\n * @param target\n */\nasync function remove(target) {\n    // Since v14.14\n    if (fs_1.promises.rm) {\n        await fs_1.promises.rm(target, { recursive: true, force: true });\n    }\n    else if (fs.existsSync(target)) {\n        // Ew. We shouldn't need the exists check... Can't wait for Node 14.\n        await fs_1.promises.rmdir(target, { recursive: true });\n    }\n}\nexports.remove = remove;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./reflections/index\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./comments/index\"), exports);\n__exportStar(require(\"./sources/index\"), exports);\n__exportStar(require(\"./ReflectionGroup\"), exports);\n__exportStar(require(\"./ReflectionCategory\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.splitUnquotedString = exports.VarianceModifier = exports.TypeParameterReflection = exports.SignatureReflection = exports.ReferenceReflection = exports.ProjectReflection = exports.ParameterReflection = exports.ReflectionKind = exports.DeclarationReflection = exports.ContainerReflection = exports.TraverseProperty = exports.ReflectionFlags = exports.ReflectionFlag = exports.Reflection = void 0;\nvar abstract_1 = require(\"./abstract\");\nObject.defineProperty(exports, \"Reflection\", { enumerable: true, get: function () { return abstract_1.Reflection; } });\nObject.defineProperty(exports, \"ReflectionFlag\", { enumerable: true, get: function () { return abstract_1.ReflectionFlag; } });\nObject.defineProperty(exports, \"ReflectionFlags\", { enumerable: true, get: function () { return abstract_1.ReflectionFlags; } });\nObject.defineProperty(exports, \"TraverseProperty\", { enumerable: true, get: function () { return abstract_1.TraverseProperty; } });\nvar container_1 = require(\"./container\");\nObject.defineProperty(exports, \"ContainerReflection\", { enumerable: true, get: function () { return container_1.ContainerReflection; } });\nvar declaration_1 = require(\"./declaration\");\nObject.defineProperty(exports, \"DeclarationReflection\", { enumerable: true, get: function () { return declaration_1.DeclarationReflection; } });\nvar kind_1 = require(\"./kind\");\nObject.defineProperty(exports, \"ReflectionKind\", { enumerable: true, get: function () { return kind_1.ReflectionKind; } });\nvar parameter_1 = require(\"./parameter\");\nObject.defineProperty(exports, \"ParameterReflection\", { enumerable: true, get: function () { return parameter_1.ParameterReflection; } });\nvar project_1 = require(\"./project\");\nObject.defineProperty(exports, \"ProjectReflection\", { enumerable: true, get: function () { return project_1.ProjectReflection; } });\nvar reference_1 = require(\"./reference\");\nObject.defineProperty(exports, \"ReferenceReflection\", { enumerable: true, get: function () { return reference_1.ReferenceReflection; } });\nvar signature_1 = require(\"./signature\");\nObject.defineProperty(exports, \"SignatureReflection\", { enumerable: true, get: function () { return signature_1.SignatureReflection; } });\nvar type_parameter_1 = require(\"./type-parameter\");\nObject.defineProperty(exports, \"TypeParameterReflection\", { enumerable: true, get: function () { return type_parameter_1.TypeParameterReflection; } });\nObject.defineProperty(exports, \"VarianceModifier\", { enumerable: true, get: function () { return type_parameter_1.VarianceModifier; } });\nvar utils_1 = require(\"./utils\");\nObject.defineProperty(exports, \"splitUnquotedString\", { enumerable: true, get: function () { return utils_1.splitUnquotedString; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerReflection = void 0;\nconst abstract_1 = require(\"./abstract\");\nclass ContainerReflection extends abstract_1.Reflection {\n    /**\n     * Return a list of all children of a certain kind.\n     *\n     * @param kind  The desired kind of children.\n     * @returns     An array containing all children with the desired kind.\n     */\n    getChildrenByKind(kind) {\n        return (this.children || []).filter((child) => child.kindOf(kind));\n    }\n    /**\n     * Traverse all potential child reflections of this reflection.\n     *\n     * The given callback will be invoked for all children, signatures and type parameters\n     * attached to this reflection.\n     *\n     * @param callback  The callback function that should be applied for each child reflection.\n     */\n    traverse(callback) {\n        var _a;\n        for (const child of ((_a = this.children) === null || _a === void 0 ? void 0 : _a.slice()) || []) {\n            if (callback(child, abstract_1.TraverseProperty.Children) === false) {\n                return;\n            }\n        }\n    }\n}\nexports.ContainerReflection = ContainerReflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeclarationReflection = void 0;\nconst types_1 = require(\"../types\");\nconst abstract_1 = require(\"./abstract\");\nconst container_1 = require(\"./container\");\n/**\n * A reflection that represents a single declaration emitted by the TypeScript compiler.\n *\n * All parts of a project are represented by DeclarationReflection instances. The actual\n * kind of a reflection is stored in its kind member.\n */\nclass DeclarationReflection extends container_1.ContainerReflection {\n    hasGetterOrSetter() {\n        return !!this.getSignature || !!this.setSignature;\n    }\n    getAllSignatures() {\n        let result = [];\n        if (this.signatures) {\n            result = result.concat(this.signatures);\n        }\n        if (this.indexSignature) {\n            result.push(this.indexSignature);\n        }\n        if (this.getSignature) {\n            result.push(this.getSignature);\n        }\n        if (this.setSignature) {\n            result.push(this.setSignature);\n        }\n        return result;\n    }\n    /** @internal */\n    getNonIndexSignatures() {\n        var _a, _b, _c;\n        return [].concat((_a = this.signatures) !== null && _a !== void 0 ? _a : [], (_b = this.setSignature) !== null && _b !== void 0 ? _b : [], (_c = this.getSignature) !== null && _c !== void 0 ? _c : []);\n    }\n    /**\n     * Traverse all potential child reflections of this reflection.\n     *\n     * The given callback will be invoked for all children, signatures and type parameters\n     * attached to this reflection.\n     *\n     * @param callback  The callback function that should be applied for each child reflection.\n     */\n    traverse(callback) {\n        var _a, _b;\n        for (const parameter of ((_a = this.typeParameters) === null || _a === void 0 ? void 0 : _a.slice()) || []) {\n            if (callback(parameter, abstract_1.TraverseProperty.TypeParameter) === false) {\n                return;\n            }\n        }\n        if (this.type instanceof types_1.ReflectionType) {\n            if (callback(this.type.declaration, abstract_1.TraverseProperty.TypeLiteral) === false) {\n                return;\n            }\n        }\n        for (const signature of ((_b = this.signatures) === null || _b === void 0 ? void 0 : _b.slice()) || []) {\n            if (callback(signature, abstract_1.TraverseProperty.Signatures) === false) {\n                return;\n            }\n        }\n        if (this.indexSignature) {\n            if (callback(this.indexSignature, abstract_1.TraverseProperty.IndexSignature) === false) {\n                return;\n            }\n        }\n        if (this.getSignature) {\n            if (callback(this.getSignature, abstract_1.TraverseProperty.GetSignature) ===\n                false) {\n                return;\n            }\n        }\n        if (this.setSignature) {\n            if (callback(this.setSignature, abstract_1.TraverseProperty.SetSignature) ===\n                false) {\n                return;\n            }\n        }\n        super.traverse(callback);\n    }\n    /**\n     * Return a string representation of this reflection.\n     */\n    toString() {\n        let result = super.toString();\n        if (this.typeParameters) {\n            const parameters = [];\n            this.typeParameters.forEach((parameter) => {\n                parameters.push(parameter.name);\n            });\n            result += \"<\" + parameters.join(\", \") + \">\";\n        }\n        if (this.type) {\n            result += \":\" + this.type.toString();\n        }\n        return result;\n    }\n}\nexports.DeclarationReflection = DeclarationReflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnknownType = exports.UnionType = exports.TypeOperatorType = exports.NamedTupleMember = exports.TupleType = exports.TemplateLiteralType = exports.RestType = exports.ReflectionType = exports.ReferenceType = exports.QueryType = exports.PredicateType = exports.OptionalType = exports.MappedType = exports.LiteralType = exports.IntrinsicType = exports.IntersectionType = exports.InferredType = exports.IndexedAccessType = exports.ConditionalType = exports.ArrayType = exports.TypeContext = exports.makeRecursiveVisitor = exports.Type = void 0;\nconst abstract_1 = require(\"./reflections/abstract\");\n/**\n * Base class of all type definitions.\n */\nclass Type {\n    /**\n     * Return a string representation of this type.\n     */\n    toString() {\n        return this.stringify(exports.TypeContext.none);\n    }\n    visit(visitor) {\n        var _a;\n        return (_a = visitor[this.type]) === null || _a === void 0 ? void 0 : _a.call(visitor, this);\n    }\n    stringify(context) {\n        if (this.needsParenthesis(context)) {\n            return `(${this.getTypeString()})`;\n        }\n        return this.getTypeString();\n    }\n}\nexports.Type = Type;\nfunction makeRecursiveVisitor(visitor) {\n    const recursiveVisitor = {\n        \"named-tuple-member\"(type) {\n            var _a;\n            (_a = visitor[\"named-tuple-member\"]) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.element.visit(recursiveVisitor);\n        },\n        \"template-literal\"(type) {\n            var _a;\n            (_a = visitor[\"template-literal\"]) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            for (const [h] of type.tail) {\n                h.visit(recursiveVisitor);\n            }\n        },\n        array(type) {\n            var _a;\n            (_a = visitor.array) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.elementType.visit(recursiveVisitor);\n        },\n        conditional(type) {\n            var _a;\n            (_a = visitor.conditional) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.checkType.visit(recursiveVisitor);\n            type.extendsType.visit(recursiveVisitor);\n            type.trueType.visit(recursiveVisitor);\n            type.falseType.visit(recursiveVisitor);\n        },\n        indexedAccess(type) {\n            var _a;\n            (_a = visitor.indexedAccess) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.indexType.visit(recursiveVisitor);\n            type.objectType.visit(recursiveVisitor);\n        },\n        inferred(type) {\n            var _a, _b;\n            (_a = visitor.inferred) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            (_b = type.constraint) === null || _b === void 0 ? void 0 : _b.visit(recursiveVisitor);\n        },\n        intersection(type) {\n            var _a;\n            (_a = visitor.intersection) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.types.forEach((t) => t.visit(recursiveVisitor));\n        },\n        intrinsic(type) {\n            var _a;\n            (_a = visitor.intrinsic) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n        },\n        literal(type) {\n            var _a;\n            (_a = visitor.literal) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n        },\n        mapped(type) {\n            var _a, _b;\n            (_a = visitor.mapped) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            (_b = type.nameType) === null || _b === void 0 ? void 0 : _b.visit(recursiveVisitor);\n            type.parameterType.visit(recursiveVisitor);\n            type.templateType.visit(recursiveVisitor);\n        },\n        optional(type) {\n            var _a;\n            (_a = visitor.optional) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.elementType.visit(recursiveVisitor);\n        },\n        predicate(type) {\n            var _a, _b;\n            (_a = visitor.predicate) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            (_b = type.targetType) === null || _b === void 0 ? void 0 : _b.visit(recursiveVisitor);\n        },\n        query(type) {\n            var _a;\n            (_a = visitor.query) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.queryType.visit(recursiveVisitor);\n        },\n        reference(type) {\n            var _a, _b;\n            (_a = visitor.reference) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            (_b = type.typeArguments) === null || _b === void 0 ? void 0 : _b.forEach((t) => t.visit(recursiveVisitor));\n        },\n        reflection(type) {\n            var _a;\n            (_a = visitor.reflection) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            // Future: This should maybe recurse too?\n            // See the validator in exports.ts for how to do it.\n        },\n        rest(type) {\n            var _a;\n            (_a = visitor.rest) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.elementType.visit(recursiveVisitor);\n        },\n        tuple(type) {\n            var _a;\n            (_a = visitor.tuple) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.elements.forEach((t) => t.visit(recursiveVisitor));\n        },\n        typeOperator(type) {\n            var _a;\n            (_a = visitor.typeOperator) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.target.visit(recursiveVisitor);\n        },\n        union(type) {\n            var _a;\n            (_a = visitor.union) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n            type.types.forEach((t) => t.visit(recursiveVisitor));\n        },\n        unknown(type) {\n            var _a;\n            (_a = visitor.unknown) === null || _a === void 0 ? void 0 : _a.call(visitor, type);\n        },\n    };\n    return recursiveVisitor;\n}\nexports.makeRecursiveVisitor = makeRecursiveVisitor;\n/**\n * Enumeration that can be used when traversing types to track the location of recursion.\n * Used by TypeDoc internally to track when to output parenthesis when rendering.\n * @enum\n */\nexports.TypeContext = {\n    none: \"none\",\n    templateLiteralElement: \"templateLiteralElement\",\n    arrayElement: \"arrayElement\",\n    indexedAccessElement: \"indexedAccessElement\",\n    conditionalCheck: \"conditionalCheck\",\n    conditionalExtends: \"conditionalExtends\",\n    conditionalTrue: \"conditionalTrue\",\n    conditionalFalse: \"conditionalFalse\",\n    indexedIndex: \"indexedIndex\",\n    indexedObject: \"indexedObject\",\n    inferredConstraint: \"inferredConstraint\",\n    intersectionElement: \"intersectionElement\",\n    mappedName: \"mappedName\",\n    mappedParameter: \"mappedParameter\",\n    mappedTemplate: \"mappedTemplate\",\n    optionalElement: \"optionalElement\",\n    predicateTarget: \"predicateTarget\",\n    queryTypeTarget: \"queryTypeTarget\",\n    typeOperatorTarget: \"typeOperatorTarget\",\n    referenceTypeArgument: \"referenceTypeArgument\",\n    restElement: \"restElement\",\n    tupleElement: \"tupleElement\",\n    unionElement: \"unionElement\", // here | 1\n};\n/**\n * Represents an array type.\n *\n * ```ts\n * let value: string[];\n * ```\n */\nclass ArrayType extends Type {\n    constructor(elementType) {\n        super();\n        this.type = \"array\";\n        this.elementType = elementType;\n    }\n    getTypeString() {\n        return this.elementType.stringify(exports.TypeContext.arrayElement) + \"[]\";\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.ArrayType = ArrayType;\n/**\n * Represents a conditional type.\n *\n * ```ts\n * let value: Check extends Extends ? True : False;\n * ```\n */\nclass ConditionalType extends Type {\n    constructor(checkType, extendsType, trueType, falseType) {\n        super();\n        this.checkType = checkType;\n        this.extendsType = extendsType;\n        this.trueType = trueType;\n        this.falseType = falseType;\n        this.type = \"conditional\";\n    }\n    getTypeString() {\n        return [\n            this.checkType.stringify(exports.TypeContext.conditionalCheck),\n            \"extends\",\n            this.extendsType.stringify(exports.TypeContext.conditionalExtends),\n            \"?\",\n            this.trueType.stringify(exports.TypeContext.conditionalTrue),\n            \":\",\n            this.falseType.stringify(exports.TypeContext.conditionalFalse),\n        ].join(\" \");\n    }\n    needsParenthesis(context) {\n        const map = {\n            none: false,\n            templateLiteralElement: false,\n            arrayElement: true,\n            indexedAccessElement: false,\n            conditionalCheck: true,\n            conditionalExtends: true,\n            conditionalTrue: false,\n            conditionalFalse: false,\n            indexedIndex: false,\n            indexedObject: true,\n            inferredConstraint: true,\n            intersectionElement: true,\n            mappedName: false,\n            mappedParameter: false,\n            mappedTemplate: false,\n            optionalElement: true,\n            predicateTarget: false,\n            queryTypeTarget: false,\n            typeOperatorTarget: true,\n            referenceTypeArgument: false,\n            restElement: true,\n            tupleElement: false,\n            unionElement: true,\n        };\n        return map[context];\n    }\n}\nexports.ConditionalType = ConditionalType;\n/**\n * Represents an indexed access type.\n */\nclass IndexedAccessType extends Type {\n    constructor(objectType, indexType) {\n        super();\n        this.objectType = objectType;\n        this.indexType = indexType;\n        this.type = \"indexedAccess\";\n    }\n    getTypeString() {\n        return [\n            this.objectType.stringify(exports.TypeContext.indexedObject),\n            \"[\",\n            this.indexType.stringify(exports.TypeContext.indexedIndex),\n            \"]\",\n        ].join(\"\");\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.IndexedAccessType = IndexedAccessType;\n/**\n * Represents an inferred type, U in the example below.\n *\n * ```ts\n * type Z = Promise<string> extends Promise<infer U> : never\n * ```\n */\nclass InferredType extends Type {\n    constructor(name, constraint) {\n        super();\n        this.name = name;\n        this.constraint = constraint;\n        this.type = \"inferred\";\n    }\n    getTypeString() {\n        if (this.constraint) {\n            return `infer ${this.name} extends ${this.constraint.stringify(exports.TypeContext.inferredConstraint)}`;\n        }\n        return `infer ${this.name}`;\n    }\n    needsParenthesis(context) {\n        const map = {\n            none: false,\n            templateLiteralElement: false,\n            arrayElement: true,\n            indexedAccessElement: false,\n            conditionalCheck: false,\n            conditionalExtends: false,\n            conditionalTrue: false,\n            conditionalFalse: false,\n            indexedIndex: false,\n            indexedObject: true,\n            inferredConstraint: false,\n            intersectionElement: false,\n            mappedName: false,\n            mappedParameter: false,\n            mappedTemplate: false,\n            optionalElement: true,\n            predicateTarget: false,\n            queryTypeTarget: false,\n            typeOperatorTarget: false,\n            referenceTypeArgument: false,\n            restElement: true,\n            tupleElement: false,\n            unionElement: false,\n        };\n        return map[context];\n    }\n}\nexports.InferredType = InferredType;\n/**\n * Represents an intersection type.\n *\n * ```ts\n * let value: A & B;\n * ```\n */\nclass IntersectionType extends Type {\n    constructor(types) {\n        super();\n        this.types = types;\n        this.type = \"intersection\";\n    }\n    getTypeString() {\n        return this.types\n            .map((t) => t.stringify(exports.TypeContext.intersectionElement))\n            .join(\" & \");\n    }\n    needsParenthesis(context) {\n        const map = {\n            none: false,\n            templateLiteralElement: false,\n            arrayElement: true,\n            indexedAccessElement: false,\n            conditionalCheck: true,\n            conditionalExtends: false,\n            conditionalTrue: false,\n            conditionalFalse: false,\n            indexedIndex: false,\n            indexedObject: true,\n            inferredConstraint: false,\n            intersectionElement: false,\n            mappedName: false,\n            mappedParameter: false,\n            mappedTemplate: false,\n            optionalElement: true,\n            predicateTarget: false,\n            queryTypeTarget: false,\n            typeOperatorTarget: true,\n            referenceTypeArgument: false,\n            restElement: true,\n            tupleElement: false,\n            unionElement: false,\n        };\n        return map[context];\n    }\n}\nexports.IntersectionType = IntersectionType;\n/**\n * Represents an intrinsic type like `string` or `boolean`.\n *\n * ```ts\n * let value: number;\n * ```\n */\nclass IntrinsicType extends Type {\n    constructor(name) {\n        super();\n        this.name = name;\n        this.type = \"intrinsic\";\n    }\n    getTypeString() {\n        return this.name;\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.IntrinsicType = IntrinsicType;\n/**\n * Represents a literal type.\n *\n * ```ts\n * type A = \"A\"\n * type B = 1\n * ```\n */\nclass LiteralType extends Type {\n    constructor(value) {\n        super();\n        this.value = value;\n        this.type = \"literal\";\n    }\n    /**\n     * Return a string representation of this type.\n     */\n    getTypeString() {\n        if (typeof this.value === \"bigint\") {\n            return this.value.toString() + \"n\";\n        }\n        return JSON.stringify(this.value);\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.LiteralType = LiteralType;\n/**\n * Represents a mapped type.\n *\n * ```ts\n * { -readonly [K in Parameter as Name]?: Template }\n * ```\n */\nclass MappedType extends Type {\n    constructor(parameter, parameterType, templateType, readonlyModifier, optionalModifier, nameType) {\n        super();\n        this.parameter = parameter;\n        this.parameterType = parameterType;\n        this.templateType = templateType;\n        this.readonlyModifier = readonlyModifier;\n        this.optionalModifier = optionalModifier;\n        this.nameType = nameType;\n        this.type = \"mapped\";\n    }\n    getTypeString() {\n        var _a, _b;\n        const read = {\n            \"+\": \"readonly \",\n            \"-\": \"-readonly \",\n            \"\": \"\",\n        }[(_a = this.readonlyModifier) !== null && _a !== void 0 ? _a : \"\"];\n        const opt = {\n            \"+\": \"?\",\n            \"-\": \"-?\",\n            \"\": \"\",\n        }[(_b = this.optionalModifier) !== null && _b !== void 0 ? _b : \"\"];\n        const parts = [\n            \"{ \",\n            read,\n            \"[\",\n            this.parameter,\n            \" in \",\n            this.parameterType.stringify(exports.TypeContext.mappedParameter),\n        ];\n        if (this.nameType) {\n            parts.push(\" as \", this.nameType.stringify(exports.TypeContext.mappedName));\n        }\n        parts.push(\"]\", opt, \": \", this.templateType.stringify(exports.TypeContext.mappedTemplate), \" }\");\n        return parts.join(\"\");\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.MappedType = MappedType;\n/**\n * Represents an optional type\n * ```ts\n * type Z = [1, 2?]\n * //           ^^\n * ```\n */\nclass OptionalType extends Type {\n    constructor(elementType) {\n        super();\n        this.type = \"optional\";\n        this.elementType = elementType;\n    }\n    getTypeString() {\n        return this.elementType.stringify(exports.TypeContext.optionalElement) + \"?\";\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.OptionalType = OptionalType;\n/**\n * Represents a type predicate.\n *\n * ```ts\n * function isString(anything: any): anything is string {}\n * function assert(condition: boolean): asserts condition {}\n * ```\n */\nclass PredicateType extends Type {\n    /**\n     * Create a new PredicateType instance.\n     */\n    constructor(name, asserts, targetType) {\n        super();\n        this.type = \"predicate\";\n        this.name = name;\n        this.asserts = asserts;\n        this.targetType = targetType;\n    }\n    /**\n     * Return a string representation of this type.\n     */\n    getTypeString() {\n        const out = this.asserts ? [\"asserts\", this.name] : [this.name];\n        if (this.targetType) {\n            out.push(\"is\", this.targetType.stringify(exports.TypeContext.predicateTarget));\n        }\n        return out.join(\" \");\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.PredicateType = PredicateType;\n/**\n * Represents a type that is constructed by querying the type of a reflection.\n * ```ts\n * const x = 1\n * type Z = typeof x // query on reflection for x\n * ```\n */\nclass QueryType extends Type {\n    constructor(reference) {\n        super();\n        this.type = \"query\";\n        this.queryType = reference;\n    }\n    getTypeString() {\n        return `typeof ${this.queryType.stringify(exports.TypeContext.queryTypeTarget)}`;\n    }\n    /**\n     * @privateRemarks\n     * An argument could be made that this ought to return true for indexedObject\n     * since precedence is different than on the value side... if someone really cares\n     * they can easily use a custom theme to change this.\n     */\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.QueryType = QueryType;\n/**\n * Represents a type that refers to another reflection like a class, interface or enum.\n *\n * ```ts\n * let value: MyClass<T>;\n * ```\n */\nclass ReferenceType extends Type {\n    constructor(name, target, project) {\n        super();\n        this.type = \"reference\";\n        this.name = name;\n        this._target = target instanceof abstract_1.Reflection ? target.id : target;\n        this._project = project;\n    }\n    /**\n     * The resolved reflection.\n     */\n    get reflection() {\n        var _a, _b;\n        if (typeof this._target === \"number\") {\n            return (_a = this._project) === null || _a === void 0 ? void 0 : _a.getReflectionById(this._target);\n        }\n        const resolved = (_b = this._project) === null || _b === void 0 ? void 0 : _b.getReflectionFromSymbol(this._target);\n        if (resolved)\n            this._target = resolved.id;\n        return resolved;\n    }\n    /**\n     * Don't use this if at all possible. It will eventually go away since models may not\n     * retain information from the original TS objects to enable documentation generation from\n     * previously generated JSON.\n     * @internal\n     */\n    getSymbol() {\n        if (typeof this._target === \"number\") {\n            return;\n        }\n        return this._target;\n    }\n    static createResolvedReference(name, target, project) {\n        return new ReferenceType(name, target, project);\n    }\n    static createSymbolReference(symbol, context, name) {\n        var _a, _b;\n        const ref = new ReferenceType(name !== null && name !== void 0 ? name : symbol.name, symbol, context.project);\n        const symbolPath = (_b = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getSourceFile().fileName.replace(/\\\\/g, \"/\");\n        if (!symbolPath)\n            return ref;\n        let startIndex = symbolPath.indexOf(\"node_modules/\");\n        if (startIndex === -1)\n            return ref;\n        startIndex += \"node_modules/\".length;\n        let stopIndex = symbolPath.indexOf(\"/\", startIndex);\n        // Scoped package, e.g. `@types/node`\n        if (symbolPath[startIndex] === \"@\") {\n            stopIndex = symbolPath.indexOf(\"/\", stopIndex + 1);\n        }\n        const packageName = symbolPath.substring(startIndex, stopIndex);\n        ref.package = packageName;\n        const qualifiedName = context.checker.getFullyQualifiedName(symbol);\n        // I think this is less bad than depending on symbol.parent...\n        // https://github.com/microsoft/TypeScript/issues/38344\n        // It will break if someone names a directory with a quote in it, but so will lots\n        // of other things including other parts of TypeDoc. Until it *actually* breaks someone...\n        if (qualifiedName.startsWith('\"')) {\n            ref.qualifiedName = qualifiedName.substring(qualifiedName.indexOf('\".', 1) + 2);\n        }\n        else {\n            ref.qualifiedName = qualifiedName;\n        }\n        return ref;\n    }\n    /** @internal this is used for type parameters, which don't actually point to something */\n    static createBrokenReference(name, project) {\n        return new ReferenceType(name, -1, project);\n    }\n    getTypeString() {\n        const name = this.reflection ? this.reflection.name : this.name;\n        let typeArgs = \"\";\n        if (this.typeArguments && this.typeArguments.length > 0) {\n            typeArgs += \"<\";\n            typeArgs += this.typeArguments\n                .map((arg) => arg.stringify(exports.TypeContext.referenceTypeArgument))\n                .join(\", \");\n            typeArgs += \">\";\n        }\n        return name + typeArgs;\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.ReferenceType = ReferenceType;\n/**\n * Represents a type which has it's own reflection like literal types.\n * This type will likely go away at some point and be replaced by a dedicated\n * `ObjectType`. Allowing reflections to be nested within types causes much\n * pain in the rendering code.\n *\n * ```ts\n * let value: { a: string, b: number };\n * ```\n */\nclass ReflectionType extends Type {\n    constructor(declaration) {\n        super();\n        this.type = \"reflection\";\n        this.declaration = declaration;\n    }\n    // This really ought to do better, but I'm putting off investing effort here until\n    // I'm fully convinced that keeping this is a good idea. Currently, I'd much rather\n    // change object types to not create reflections.\n    getTypeString() {\n        if (!this.declaration.children && this.declaration.signatures) {\n            return \"Function\";\n        }\n        else {\n            return \"Object\";\n        }\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.ReflectionType = ReflectionType;\n/**\n * Represents a rest type\n * ```ts\n * type Z = [1, ...2[]]\n * //           ^^^^^^\n * ```\n */\nclass RestType extends Type {\n    constructor(elementType) {\n        super();\n        this.elementType = elementType;\n        this.type = \"rest\";\n    }\n    getTypeString() {\n        return `...${this.elementType.stringify(exports.TypeContext.restElement)}`;\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.RestType = RestType;\n/**\n * TS 4.1 template literal types\n * ```ts\n * type Z = `${'a' | 'b'}${'a' | 'b'}`\n * ```\n */\nclass TemplateLiteralType extends Type {\n    constructor(head, tail) {\n        super();\n        this.head = head;\n        this.tail = tail;\n        this.type = \"template-literal\";\n    }\n    getTypeString() {\n        return [\n            \"`\",\n            this.head,\n            ...this.tail.map(([type, text]) => {\n                return (\"${\" +\n                    type.stringify(exports.TypeContext.templateLiteralElement) +\n                    \"}\" +\n                    text);\n            }),\n            \"`\",\n        ].join(\"\");\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.TemplateLiteralType = TemplateLiteralType;\n/**\n * Represents a tuple type.\n *\n * ```ts\n * let value: [string, boolean];\n * ```\n */\nclass TupleType extends Type {\n    constructor(elements) {\n        super();\n        this.type = \"tuple\";\n        this.elements = elements;\n    }\n    getTypeString() {\n        return (\"[\" +\n            this.elements\n                .map((t) => t.stringify(exports.TypeContext.tupleElement))\n                .join(\", \") +\n            \"]\");\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.TupleType = TupleType;\n/**\n * Represents a named member of a tuple type.\n *\n * ```ts\n * let value: [name: string];\n * ```\n */\nclass NamedTupleMember extends Type {\n    constructor(name, isOptional, element) {\n        super();\n        this.name = name;\n        this.isOptional = isOptional;\n        this.element = element;\n        this.type = \"named-tuple-member\";\n    }\n    /**\n     * Return a string representation of this type.\n     */\n    getTypeString() {\n        return `${this.name}${this.isOptional ? \"?\" : \"\"}: ${this.element.stringify(exports.TypeContext.tupleElement)}`;\n    }\n    needsParenthesis() {\n        return false;\n    }\n}\nexports.NamedTupleMember = NamedTupleMember;\n/**\n * Represents a type operator type.\n *\n * ```ts\n * class A {}\n * class B<T extends keyof A> {}\n * ```\n */\nclass TypeOperatorType extends Type {\n    constructor(target, operator) {\n        super();\n        this.target = target;\n        this.operator = operator;\n        this.type = \"typeOperator\";\n    }\n    getTypeString() {\n        return `${this.operator} ${this.target.stringify(exports.TypeContext.typeOperatorTarget)}`;\n    }\n    needsParenthesis(context) {\n        const map = {\n            none: false,\n            templateLiteralElement: false,\n            arrayElement: true,\n            indexedAccessElement: false,\n            conditionalCheck: false,\n            conditionalExtends: false,\n            conditionalTrue: false,\n            conditionalFalse: false,\n            indexedIndex: false,\n            indexedObject: true,\n            inferredConstraint: false,\n            intersectionElement: false,\n            mappedName: false,\n            mappedParameter: false,\n            mappedTemplate: false,\n            optionalElement: true,\n            predicateTarget: false,\n            queryTypeTarget: false,\n            typeOperatorTarget: false,\n            referenceTypeArgument: false,\n            restElement: false,\n            tupleElement: false,\n            unionElement: false,\n        };\n        return map[context];\n    }\n}\nexports.TypeOperatorType = TypeOperatorType;\n/**\n * Represents an union type.\n *\n * ```ts\n * let value: string | string[];\n * ```\n */\nclass UnionType extends Type {\n    constructor(types) {\n        super();\n        this.types = types;\n        this.type = \"union\";\n        this.normalize();\n    }\n    getTypeString() {\n        return this.types\n            .map((t) => t.stringify(exports.TypeContext.unionElement))\n            .join(\" | \");\n    }\n    needsParenthesis(context) {\n        const map = {\n            none: false,\n            templateLiteralElement: false,\n            arrayElement: true,\n            indexedAccessElement: false,\n            conditionalCheck: true,\n            conditionalExtends: false,\n            conditionalTrue: false,\n            conditionalFalse: false,\n            indexedIndex: false,\n            indexedObject: true,\n            inferredConstraint: false,\n            intersectionElement: true,\n            mappedName: false,\n            mappedParameter: false,\n            mappedTemplate: false,\n            optionalElement: true,\n            predicateTarget: false,\n            queryTypeTarget: false,\n            typeOperatorTarget: true,\n            referenceTypeArgument: false,\n            restElement: false,\n            tupleElement: false,\n            unionElement: false,\n        };\n        return map[context];\n    }\n    normalize() {\n        let trueIndex = -1;\n        let falseIndex = -1;\n        for (let i = 0; i < this.types.length && (trueIndex === -1 || falseIndex === -1); i++) {\n            const t = this.types[i];\n            if (t instanceof LiteralType) {\n                if (t.value === true) {\n                    trueIndex = i;\n                }\n                if (t.value === false) {\n                    falseIndex = i;\n                }\n            }\n        }\n        if (trueIndex !== -1 && falseIndex !== -1) {\n            this.types.splice(Math.max(trueIndex, falseIndex), 1);\n            this.types.splice(Math.min(trueIndex, falseIndex), 1, new IntrinsicType(\"boolean\"));\n        }\n    }\n}\nexports.UnionType = UnionType;\n/**\n * Represents all unknown types that cannot be converted by TypeDoc.\n */\nclass UnknownType extends Type {\n    constructor(name) {\n        super();\n        this.type = \"unknown\";\n        this.name = name;\n    }\n    getTypeString() {\n        return this.name;\n    }\n    /**\n     * Always returns true if not at the root level, we have no idea what's in here, so wrap it in parenthesis\n     * to be extra safe.\n     */\n    needsParenthesis(context) {\n        return context !== exports.TypeContext.none;\n    }\n}\nexports.UnknownType = UnknownType;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParameterReflection = void 0;\nconst types_1 = require(\"../types\");\nconst abstract_1 = require(\"./abstract\");\nclass ParameterReflection extends abstract_1.Reflection {\n    /**\n     * Traverse all potential child reflections of this reflection.\n     *\n     * The given callback will be invoked for all children, signatures and type parameters\n     * attached to this reflection.\n     *\n     * @param callback  The callback function that should be applied for each child reflection.\n     */\n    traverse(callback) {\n        if (this.type instanceof types_1.ReflectionType) {\n            if (callback(this.type.declaration, abstract_1.TraverseProperty.TypeLiteral) === false) {\n                return;\n            }\n        }\n        super.traverse(callback);\n    }\n    /**\n     * Return a string representation of this reflection.\n     */\n    toString() {\n        return super.toString() + (this.type ? \":\" + this.type.toString() : \"\");\n    }\n}\nexports.ParameterReflection = ParameterReflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectReflection = void 0;\nconst index_1 = require(\"../sources/index\");\nconst abstract_1 = require(\"./abstract\");\nconst container_1 = require(\"./container\");\nconst utils_1 = require(\"./utils\");\nconst reference_1 = require(\"./reference\");\nconst types_1 = require(\"../types\");\nconst utils_2 = require(\"../../utils\");\nconst kind_1 = require(\"./kind\");\n/**\n * A reflection that represents the root of the project.\n *\n * The project reflection acts as a global index, one may receive all reflections\n * and source files of the processed project through this reflection.\n */\nclass ProjectReflection extends container_1.ContainerReflection {\n    /**\n     * Create a new ProjectReflection instance.\n     *\n     * @param name  The name of the project.\n     */\n    constructor(name) {\n        super(name, kind_1.ReflectionKind.Project);\n        // Used to resolve references.\n        this.symbolToReflectionIdMap = new Map();\n        this.reflectionIdToSymbolMap = new Map();\n        /**\n         * A list of all reflections within the project.\n         * @deprecated use {@link getReflectionById}, this will eventually be removed.\n         *   To iterate over all reflections, prefer {@link getReflectionsByKind}.\n         */\n        this.reflections = {};\n        /**\n         * The root directory of the project.\n         */\n        this.directory = new index_1.SourceDirectory();\n        /**\n         * A list of all source files within the project.\n         */\n        this.files = [];\n    }\n    /**\n     * Return whether this reflection is the root / project reflection.\n     */\n    isProject() {\n        return true;\n    }\n    /**\n     * Return a list of all reflections in this project of a certain kind.\n     *\n     * @param kind  The desired kind of reflection.\n     * @returns     An array containing all reflections with the desired kind.\n     */\n    getReflectionsByKind(kind) {\n        return Object.values(this.reflections).filter((reflection) => reflection.kindOf(kind));\n    }\n    /**\n     * Try to find a reflection by its name.\n     *\n     * @param names The name hierarchy to look for, if a string, the name will be split on \".\"\n     * @return The found reflection or undefined.\n     */\n    findReflectionByName(arg) {\n        const names = Array.isArray(arg)\n            ? arg\n            : (0, utils_1.splitUnquotedString)(arg, \".\");\n        const name = names.pop();\n        search: for (const key in this.reflections) {\n            const reflection = this.reflections[key];\n            if (reflection.name !== name) {\n                continue;\n            }\n            let depth = names.length - 1;\n            let target = reflection;\n            while ((target = target.parent) && depth >= 0) {\n                if (target.name !== names[depth]) {\n                    continue search;\n                }\n                depth -= 1;\n            }\n            return reflection;\n        }\n        return undefined;\n    }\n    /**\n     * When excludeNotExported is set, if a symbol is exported only under a different name\n     * there will be a reference which points to the symbol, but the symbol will not be converted\n     * and the rename will point to nothing. Warn the user if this happens.\n     */\n    removeDanglingReferences() {\n        const dangling = new Set();\n        for (const ref of Object.values(this.reflections)) {\n            if (ref instanceof reference_1.ReferenceReflection) {\n                if (!ref.tryGetTargetReflection()) {\n                    dangling.add(ref);\n                }\n            }\n        }\n        for (const refl of dangling) {\n            this.removeReflection(refl);\n        }\n    }\n    /**\n     * Registers the given reflection so that it can be quickly looked up by helper methods.\n     * Should be called for *every* reflection added to the project.\n     */\n    registerReflection(reflection, symbol) {\n        var _a;\n        this.referenceGraph = undefined;\n        this.reflections[reflection.id] = reflection;\n        if (symbol) {\n            this.symbolToReflectionIdMap.set(symbol, (_a = this.symbolToReflectionIdMap.get(symbol)) !== null && _a !== void 0 ? _a : reflection.id);\n            this.reflectionIdToSymbolMap.set(reflection.id, symbol);\n        }\n    }\n    /**\n     * Removes a reflection from the documentation. Can be used by plugins to filter reflections\n     * out of the generated documentation. Has no effect if the reflection is not present in the\n     * project.\n     */\n    removeReflection(reflection) {\n        var _a;\n        // Remove references\n        for (const id of (_a = this.getReferenceGraph().get(reflection.id)) !== null && _a !== void 0 ? _a : []) {\n            const ref = this.getReflectionById(id);\n            if (ref) {\n                this.removeReflection(ref);\n            }\n        }\n        this.getReferenceGraph().delete(reflection.id);\n        reflection.traverse((child) => (this.removeReflection(child), true));\n        const parent = reflection.parent;\n        parent === null || parent === void 0 ? void 0 : parent.traverse((child, property) => {\n            if (child !== reflection) {\n                return true; // Continue iteration\n            }\n            if (property === abstract_1.TraverseProperty.Children) {\n                (0, utils_2.removeIfPresent)(parent.children, reflection);\n            }\n            else if (property === abstract_1.TraverseProperty.GetSignature) {\n                delete parent.getSignature;\n            }\n            else if (property === abstract_1.TraverseProperty.IndexSignature) {\n                delete parent.indexSignature;\n            }\n            else if (property === abstract_1.TraverseProperty.Parameters) {\n                (0, utils_2.removeIfPresent)(reflection.parent.parameters, reflection);\n            }\n            else if (property === abstract_1.TraverseProperty.SetSignature) {\n                delete parent.setSignature;\n            }\n            else if (property === abstract_1.TraverseProperty.Signatures) {\n                (0, utils_2.removeIfPresent)(parent.signatures, reflection);\n            }\n            else if (property === abstract_1.TraverseProperty.TypeLiteral) {\n                parent.type = new types_1.IntrinsicType(\"Object\");\n            }\n            else if (property === abstract_1.TraverseProperty.TypeParameter) {\n                (0, utils_2.removeIfPresent)(parent.typeParameters, reflection);\n            }\n            return false; // Stop iteration\n        });\n        const symbol = this.reflectionIdToSymbolMap.get(reflection.id);\n        if (symbol &&\n            this.symbolToReflectionIdMap.get(symbol) === reflection.id) {\n            this.symbolToReflectionIdMap.delete(symbol);\n        }\n        delete this.reflections[reflection.id];\n    }\n    /**\n     * Gets the reflection registered for the given reflection ID, or undefined if it is not present\n     * in the project.\n     */\n    getReflectionById(id) {\n        return this.reflections[id];\n    }\n    /**\n     * Gets the reflection associated with the given symbol, if it exists.\n     * @internal\n     */\n    getReflectionFromSymbol(symbol) {\n        const id = this.symbolToReflectionIdMap.get(symbol);\n        if (typeof id === \"number\") {\n            return this.getReflectionById(id);\n        }\n    }\n    /** @internal */\n    getSymbolFromReflection(reflection) {\n        return this.reflectionIdToSymbolMap.get(reflection.id);\n    }\n    getReferenceGraph() {\n        var _a;\n        if (!this.referenceGraph) {\n            this.referenceGraph = new Map();\n            for (const ref of Object.values(this.reflections)) {\n                if (ref instanceof reference_1.ReferenceReflection) {\n                    const target = ref.tryGetTargetReflection();\n                    if (target) {\n                        const refs = (_a = this.referenceGraph.get(target.id)) !== null && _a !== void 0 ? _a : [];\n                        refs.push(ref.id);\n                        this.referenceGraph.set(target.id, refs);\n                    }\n                }\n            }\n        }\n        return this.referenceGraph;\n    }\n}\nexports.ProjectReflection = ProjectReflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RepositoryType = exports.SourceFile = exports.SourceDirectory = void 0;\nvar directory_1 = require(\"./directory\");\nObject.defineProperty(exports, \"SourceDirectory\", { enumerable: true, get: function () { return directory_1.SourceDirectory; } });\nvar file_1 = require(\"./file\");\nObject.defineProperty(exports, \"SourceFile\", { enumerable: true, get: function () { return file_1.SourceFile; } });\nvar repository_1 = require(\"./repository\");\nObject.defineProperty(exports, \"RepositoryType\", { enumerable: true, get: function () { return repository_1.RepositoryType; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceDirectory = void 0;\nconst array_1 = require(\"../../utils/array\");\n/**\n * Exposes information about a directory containing source files.\n *\n * One my access the root directory of a project through the {@link ProjectReflection.directory}\n * property. Traverse through directories by utilizing the {@link SourceDirectory.parent} or\n * {@link SourceDirectory.directories} properties.\n */\nclass SourceDirectory {\n    /**\n     * Create a new SourceDirectory instance.\n     *\n     * @param name  The new of directory.\n     * @param parent  The parent directory instance.\n     */\n    constructor(name, parent) {\n        /**\n         * A list of all subdirectories.\n         */\n        this.directories = {};\n        /**\n         * A list of all files in this directory.\n         */\n        this.files = [];\n        if (name && parent) {\n            this.name = name;\n            this.dirName = (parent.dirName ? parent.dirName + \"/\" : \"\") + name;\n            this.parent = parent;\n        }\n    }\n    /**\n     * Return a string describing this directory and its contents.\n     *\n     * @param indent  Used internally for indention.\n     * @returns A string representing this directory and all of its children.\n     */\n    toString(indent = \"\") {\n        let res = indent + this.name;\n        for (const dir of Object.values(this.directories)) {\n            res += \"\\n\" + dir.toString(indent + \"  \");\n        }\n        this.files.forEach((file) => {\n            res += \"\\n\" + indent + \"  \" + file.fileName;\n        });\n        return res;\n    }\n    /**\n     * Return a list of all reflections exposed by the files within this directory.\n     *\n     * @returns An aggregated list of all {@link DeclarationReflection} defined in the\n     * files of this directory.\n     */\n    getAllReflections() {\n        return (0, array_1.flatMap)(this.files, (file) => file.reflections);\n    }\n}\nexports.SourceDirectory = SourceDirectory;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.flatMap = exports.filterMap = exports.zip = exports.toArray = exports.partition = exports.unique = exports.removeIf = exports.removeIfPresent = exports.binaryFindPartition = exports.insertOrderSorted = exports.insertPrioritySorted = void 0;\n/**\n * Inserts an item into an array sorted by priority. If two items have the same priority,\n * the item will be inserted later will be placed earlier in the array.\n * @param arr modified by inserting item.\n * @param item\n * @deprecated this is confusing, it sorts with lower priority being placed earlier. Prefer insertOrderSorted, which is nearly the same.\n */\nfunction insertPrioritySorted(arr, item) {\n    const index = binaryFindPartition(arr, (v) => v.priority >= item.priority);\n    arr.splice(index === -1 ? arr.length : index, 0, item);\n    return arr;\n}\nexports.insertPrioritySorted = insertPrioritySorted;\n/**\n * Inserts an item into an array sorted by order. If two items have the same order,\n * the item inserted later will be placed later in the array.\n * The array will be sorted with lower order being placed sooner.\n * @param arr modified by inserting item.\n * @param item\n */\nfunction insertOrderSorted(arr, item) {\n    const index = binaryFindPartition(arr, (v) => v.order > item.order);\n    arr.splice(index === -1 ? arr.length : index, 0, item);\n    return arr;\n}\nexports.insertOrderSorted = insertOrderSorted;\n/**\n * Performs a binary search of a given array, returning the index of the first item\n * for which `partition` returns true. Returns the -1 if there are no items in `arr`\n * such that `partition(item)` is true.\n * @param arr\n * @param partition should return true while less than the partition point.\n */\nfunction binaryFindPartition(arr, partition) {\n    if (arr.length === 0) {\n        return -1;\n    }\n    let low = 0, high = arr.length - 1;\n    while (high > low) {\n        const mid = low + Math.floor((high - low) / 2);\n        if (partition(arr[mid])) {\n            high = mid;\n        }\n        else {\n            low = mid + 1;\n        }\n    }\n    return partition(arr[low]) ? low : -1;\n}\nexports.binaryFindPartition = binaryFindPartition;\n/**\n * Removes an item from the array if the array exists and the item is included\n * within it.\n * @param arr\n * @param item\n */\nfunction removeIfPresent(arr, item) {\n    if (!arr) {\n        return;\n    }\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\nexports.removeIfPresent = removeIfPresent;\n/**\n * Remove items in an array which match a predicate.\n * @param arr\n * @param predicate\n */\nfunction removeIf(arr, predicate) {\n    const indices = filterMap(arr, (item, index) => predicate(item) ? index : void 0);\n    for (const index of indices.reverse()) {\n        arr.splice(index, 1);\n    }\n}\nexports.removeIf = removeIf;\n/**\n * Filters out duplicate values from the given iterable.\n * @param arr\n */\nfunction unique(arr) {\n    return Array.from(new Set(arr));\n}\nexports.unique = unique;\nfunction partition(iter, predicate) {\n    const left = [];\n    const right = [];\n    for (const item of iter) {\n        if (predicate(item)) {\n            left.push(item);\n        }\n        else {\n            right.push(item);\n        }\n    }\n    return [left, right];\n}\nexports.partition = partition;\n/**\n * Ensures the given item is an array.\n * @param item\n */\nfunction toArray(item) {\n    if (item === void 0) {\n        return [];\n    }\n    return Array.isArray(item) ? [...item] : [item];\n}\nexports.toArray = toArray;\nfunction* zip(...args) {\n    const iterators = args.map((x) => x[Symbol.iterator]());\n    while (true) {\n        const next = iterators.map((i) => i.next());\n        if (next.some((v) => v.done)) {\n            break;\n        }\n        yield next.map((v) => v.value);\n    }\n}\nexports.zip = zip;\nfunction filterMap(arr, fn) {\n    const result = [];\n    arr.forEach((item, index) => {\n        const newItem = fn(item, index);\n        if (newItem !== void 0) {\n            result.push(newItem);\n        }\n    });\n    return result;\n}\nexports.filterMap = filterMap;\nfunction flatMap(arr, fn) {\n    const result = [];\n    for (const item of arr) {\n        const newItem = fn(item);\n        if (newItem instanceof Array) {\n            result.push(...newItem);\n        }\n        else if (newItem != null) {\n            result.push(newItem);\n        }\n    }\n    return result;\n}\nexports.flatMap = flatMap;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceFile = void 0;\nconst Path = require(\"path\");\n/**\n * Exposes information about a source file.\n *\n * One may access a list of all source files through the {@link ProjectReflection.files} property or as\n * a tree structure through the {@link ProjectReflection.directory} property.\n *\n * Furthermore each reflection carries references to the related SourceFile with their\n * {@link DeclarationReflection.sources} property. It is an array of of {@link SourceReference} instances\n * containing the reference in their {@link SourceReference.file} field.\n */\nclass SourceFile {\n    /**\n     * Create a new SourceFile instance.\n     *\n     * @param fullFileName  The full file name.\n     */\n    constructor(fullFileName) {\n        /**\n         * A list of all reflections that are declared in this file.\n         */\n        this.reflections = [];\n        this.fileName = fullFileName;\n        this.fullFileName = fullFileName;\n        this.name = Path.basename(fullFileName);\n    }\n}\nexports.SourceFile = SourceFile;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RepositoryType = void 0;\nvar RepositoryType;\n(function (RepositoryType) {\n    RepositoryType[\"GitHub\"] = \"github\";\n    RepositoryType[\"Bitbucket\"] = \"bitbucket\";\n    RepositoryType[\"GitLab\"] = \"gitlab\";\n})(RepositoryType = exports.RepositoryType || (exports.RepositoryType = {}));\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReferenceReflection = void 0;\nconst abstract_1 = require(\"./abstract\");\nconst declaration_1 = require(\"./declaration\");\nconst kind_1 = require(\"./kind\");\n/**\n * Describes a reflection which does not exist at this location, but is referenced. Used for imported reflections.\n *\n * ```ts\n * // a.ts\n * export const a = 1;\n * // b.ts\n * import { a } from './a';\n * // Here to avoid extra work we create a reference to the original reflection in module a instead\n * // of copying the reflection.\n * export { a };\n * ```\n */\nclass ReferenceReflection extends declaration_1.DeclarationReflection {\n    /**\n     * Creates a reference reflection. Should only be used within the factory function.\n     * @param name\n     * @param state\n     * @param parent\n     *\n     * @internal\n     */\n    constructor(name, state, parent) {\n        super(name, kind_1.ReflectionKind.Reference, parent);\n        this._target = state;\n    }\n    /**\n     * Tries to get the reflection that is referenced. This may be another reference reflection.\n     * To fully resolve any references, use {@link tryGetTargetReflectionDeep}.\n     */\n    tryGetTargetReflection() {\n        this._ensureProject();\n        if (this._target instanceof abstract_1.Reflection) {\n            return this._target;\n        }\n        const target = this._project.getReflectionFromSymbol(this._target);\n        if (target)\n            this._target = target;\n        return target;\n    }\n    /**\n     * Tries to get the reflection that is referenced, this will fully resolve references.\n     * To only resolve one reference, use {@link tryGetTargetReflection}.\n     */\n    tryGetTargetReflectionDeep() {\n        let result = this.tryGetTargetReflection();\n        while (result instanceof ReferenceReflection) {\n            result = result.tryGetTargetReflection();\n        }\n        return result;\n    }\n    /**\n     * Gets the reflection that is referenced. This may be another reference reflection.\n     * To fully resolve any references, use {@link getTargetReflectionDeep}.\n     */\n    getTargetReflection() {\n        this._ensureProject();\n        const target = this.tryGetTargetReflection();\n        if (!target) {\n            throw new Error(\"Reference was unresolved.\");\n        }\n        return target;\n    }\n    /**\n     * Gets the reflection that is referenced, this will fully resolve references.\n     * To only resolve one reference, use {@link getTargetReflection}.\n     */\n    getTargetReflectionDeep() {\n        let result = this.getTargetReflection();\n        while (result instanceof ReferenceReflection) {\n            result = result.getTargetReflection();\n        }\n        return result;\n    }\n    _ensureProject() {\n        if (this._project) {\n            return;\n        }\n        let project = this.parent;\n        while (project && !project.isProject()) {\n            project = project.parent;\n        }\n        this._project = project;\n        if (!this._project) {\n            throw new Error(\"Reference reflection has no project and is unable to resolve.\");\n        }\n    }\n}\nexports.ReferenceReflection = ReferenceReflection;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderElement = exports.Raw = exports.Fragment = exports.JSX = exports.EventHooks = exports.sortReflections = exports.loadPlugins = exports.discoverPlugins = exports.TypeDocReader = exports.TSConfigReader = exports.ParameterType = exports.ParameterHint = exports.Options = exports.BindOption = exports.ArgumentsReader = exports.LogLevel = exports.Logger = exports.ConsoleLogger = exports.CallbackLogger = exports.writeFileSync = exports.writeFile = exports.remove = exports.readFile = exports.normalizePath = exports.getCommonDirectory = exports.copySync = exports.copy = exports.EventDispatcher = exports.Event = exports.Component = exports.ChildableComponent = exports.AbstractComponent = exports.unique = exports.removeIfPresent = exports.removeIf = exports.partition = exports.insertPrioritySorted = exports.filterMap = void 0;\nvar array_1 = require(\"./array\");\nObject.defineProperty(exports, \"filterMap\", { enumerable: true, get: function () { return array_1.filterMap; } });\nObject.defineProperty(exports, \"insertPrioritySorted\", { enumerable: true, get: function () { return array_1.insertPrioritySorted; } });\nObject.defineProperty(exports, \"partition\", { enumerable: true, get: function () { return array_1.partition; } });\nObject.defineProperty(exports, \"removeIf\", { enumerable: true, get: function () { return array_1.removeIf; } });\nObject.defineProperty(exports, \"removeIfPresent\", { enumerable: true, get: function () { return array_1.removeIfPresent; } });\nObject.defineProperty(exports, \"unique\", { enumerable: true, get: function () { return array_1.unique; } });\nvar component_1 = require(\"./component\");\nObject.defineProperty(exports, \"AbstractComponent\", { enumerable: true, get: function () { return component_1.AbstractComponent; } });\nObject.defineProperty(exports, \"ChildableComponent\", { enumerable: true, get: function () { return component_1.ChildableComponent; } });\nObject.defineProperty(exports, \"Component\", { enumerable: true, get: function () { return component_1.Component; } });\nvar events_1 = require(\"./events\");\nObject.defineProperty(exports, \"Event\", { enumerable: true, get: function () { return events_1.Event; } });\nObject.defineProperty(exports, \"EventDispatcher\", { enumerable: true, get: function () { return events_1.EventDispatcher; } });\nvar fs_1 = require(\"./fs\");\nObject.defineProperty(exports, \"copy\", { enumerable: true, get: function () { return fs_1.copy; } });\nObject.defineProperty(exports, \"copySync\", { enumerable: true, get: function () { return fs_1.copySync; } });\nObject.defineProperty(exports, \"getCommonDirectory\", { enumerable: true, get: function () { return fs_1.getCommonDirectory; } });\nObject.defineProperty(exports, \"normalizePath\", { enumerable: true, get: function () { return fs_1.normalizePath; } });\nObject.defineProperty(exports, \"readFile\", { enumerable: true, get: function () { return fs_1.readFile; } });\nObject.defineProperty(exports, \"remove\", { enumerable: true, get: function () { return fs_1.remove; } });\nObject.defineProperty(exports, \"writeFile\", { enumerable: true, get: function () { return fs_1.writeFile; } });\nObject.defineProperty(exports, \"writeFileSync\", { enumerable: true, get: function () { return fs_1.writeFileSync; } });\nvar loggers_1 = require(\"./loggers\");\nObject.defineProperty(exports, \"CallbackLogger\", { enumerable: true, get: function () { return loggers_1.CallbackLogger; } });\nObject.defineProperty(exports, \"ConsoleLogger\", { enumerable: true, get: function () { return loggers_1.ConsoleLogger; } });\nObject.defineProperty(exports, \"Logger\", { enumerable: true, get: function () { return loggers_1.Logger; } });\nObject.defineProperty(exports, \"LogLevel\", { enumerable: true, get: function () { return loggers_1.LogLevel; } });\nvar options_1 = require(\"./options\");\nObject.defineProperty(exports, \"ArgumentsReader\", { enumerable: true, get: function () { return options_1.ArgumentsReader; } });\nObject.defineProperty(exports, \"BindOption\", { enumerable: true, get: function () { return options_1.BindOption; } });\nObject.defineProperty(exports, \"Options\", { enumerable: true, get: function () { return options_1.Options; } });\nObject.defineProperty(exports, \"ParameterHint\", { enumerable: true, get: function () { return options_1.ParameterHint; } });\nObject.defineProperty(exports, \"ParameterType\", { enumerable: true, get: function () { return options_1.ParameterType; } });\nObject.defineProperty(exports, \"TSConfigReader\", { enumerable: true, get: function () { return options_1.TSConfigReader; } });\nObject.defineProperty(exports, \"TypeDocReader\", { enumerable: true, get: function () { return options_1.TypeDocReader; } });\nvar plugins_1 = require(\"./plugins\");\nObject.defineProperty(exports, \"discoverPlugins\", { enumerable: true, get: function () { return plugins_1.discoverPlugins; } });\nObject.defineProperty(exports, \"loadPlugins\", { enumerable: true, get: function () { return plugins_1.loadPlugins; } });\nvar sort_1 = require(\"./sort\");\nObject.defineProperty(exports, \"sortReflections\", { enumerable: true, get: function () { return sort_1.sortReflections; } });\nvar hooks_1 = require(\"./hooks\");\nObject.defineProperty(exports, \"EventHooks\", { enumerable: true, get: function () { return hooks_1.EventHooks; } });\n__exportStar(require(\"./entry-point\"), exports);\nconst JSX = require(\"./jsx\");\nexports.JSX = JSX;\nvar jsx_1 = require(\"./jsx\");\nObject.defineProperty(exports, \"Fragment\", { enumerable: true, get: function () { return jsx_1.Fragment; } });\nObject.defineProperty(exports, \"Raw\", { enumerable: true, get: function () { return jsx_1.Raw; } });\nObject.defineProperty(exports, \"renderElement\", { enumerable: true, get: function () { return jsx_1.renderElement; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChildableComponent = exports.AbstractComponent = exports.ComponentEvent = exports.Component = void 0;\nconst events_1 = require(\"./events\");\nconst childMappings = [];\n/**\n * Class decorator applied to Components\n */\nfunction Component(options) {\n    return (target) => {\n        const proto = target.prototype;\n        if (!(proto instanceof AbstractComponent)) {\n            throw new Error(\"The `Component` decorator can only be used with a subclass of `AbstractComponent`.\");\n        }\n        if (options.childClass) {\n            if (!(proto instanceof ChildableComponent)) {\n                throw new Error(\"The `Component` decorator accepts the parameter `childClass` only when used with a subclass of `ChildableComponent`.\");\n            }\n            childMappings.push({\n                host: proto,\n                child: options.childClass,\n            });\n        }\n        const name = options.name;\n        if (name) {\n            proto.componentName = name;\n        }\n        // If not marked internal, and if we are a subclass of another component T's declared\n        // childClass, then register ourselves as a _defaultComponents of T.\n        const internal = !!options.internal;\n        if (name && !internal) {\n            for (const childMapping of childMappings) {\n                if (!(proto instanceof childMapping.child)) {\n                    continue;\n                }\n                const host = childMapping.host;\n                host[\"_defaultComponents\"] = host[\"_defaultComponents\"] || {};\n                host[\"_defaultComponents\"][name] = target;\n                break;\n            }\n        }\n    };\n}\nexports.Component = Component;\nclass ComponentEvent extends events_1.Event {\n    constructor(name, owner, component) {\n        super(name);\n        this.owner = owner;\n        this.component = component;\n    }\n}\nexports.ComponentEvent = ComponentEvent;\nComponentEvent.ADDED = \"componentAdded\";\nComponentEvent.REMOVED = \"componentRemoved\";\n/**\n * Component base class.  Has an owner (unless it's the application root component),\n * can dispatch events to its children, and has access to the root Application component.\n *\n * @template O type of component's owner.\n */\nclass AbstractComponent extends events_1.EventDispatcher {\n    /**\n     * Create new Component instance.\n     */\n    constructor(owner) {\n        super();\n        this._componentOwner = owner;\n        this.initialize();\n    }\n    /**\n     * Initialize this component.\n     */\n    initialize() {\n        // empty default implementation\n    }\n    bubble(name, ...args) {\n        super.trigger(name, ...args);\n        if (this.owner instanceof AbstractComponent &&\n            this._componentOwner !== null) {\n            this.owner.bubble(name, ...args);\n        }\n        return this;\n    }\n    /**\n     * Return the application / root component instance.\n     */\n    get application() {\n        if (this._componentOwner === null) {\n            return this;\n        }\n        // Temporary hack, Application.application is going away.\n        if (this._componentOwner instanceof AbstractComponent &&\n            this._componentOwner._componentOwner === null) {\n            return this._componentOwner;\n        }\n        return this._componentOwner.application;\n    }\n    /**\n     * Return the owner of this component.\n     */\n    get owner() {\n        return this._componentOwner === null\n            ? this\n            : this._componentOwner;\n    }\n}\nexports.AbstractComponent = AbstractComponent;\n/**\n * Component that can have child components.\n *\n * @template O type of Component's owner\n * @template C type of Component's children\n */\nclass ChildableComponent extends AbstractComponent {\n    /**\n     * Create new Component instance.\n     */\n    constructor(owner) {\n        super(owner);\n        Object.entries(this._defaultComponents || {}).forEach(([name, component]) => {\n            this.addComponent(name, component);\n        });\n    }\n    /**\n     * Retrieve a plugin instance.\n     *\n     * @returns  The instance of the plugin or undefined if no plugin with the given class is attached.\n     */\n    getComponent(name) {\n        return (this._componentChildren || {})[name];\n    }\n    getComponents() {\n        return Object.values(this._componentChildren || {});\n    }\n    hasComponent(name) {\n        return !!(this._componentChildren || {})[name];\n    }\n    addComponent(name, componentClass) {\n        if (!this._componentChildren) {\n            this._componentChildren = {};\n        }\n        if (this._componentChildren[name]) {\n            // Component already added so we will return the existing component\n            // TODO: add better logging around this because it could be unexpected but shouldn't be fatal\n            // See https://github.com/TypeStrong/typedoc/issues/846\n            return this._componentChildren[name];\n        }\n        else {\n            const component = typeof componentClass === \"function\"\n                ? new componentClass(this)\n                : componentClass;\n            const event = new ComponentEvent(ComponentEvent.ADDED, this, component);\n            this.bubble(event);\n            this._componentChildren[name] = component;\n            return component;\n        }\n    }\n    removeComponent(name) {\n        const component = (this._componentChildren || {})[name];\n        if (component) {\n            delete this._componentChildren[name];\n            component.stopListening();\n            this.bubble(new ComponentEvent(ComponentEvent.REMOVED, this, component));\n            return component;\n        }\n    }\n    removeAllComponents() {\n        for (const component of Object.values(this._componentChildren || {})) {\n            component.stopListening();\n        }\n        this._componentChildren = {};\n    }\n}\nexports.ChildableComponent = ChildableComponent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallbackLogger = exports.ConsoleLogger = exports.Logger = exports.LogLevel = void 0;\nconst ts = require(\"typescript\");\nconst inspector_1 = require(\"inspector\");\nconst path_1 = require(\"path\");\nconst isDebugging = () => !!(0, inspector_1.url)();\n/**\n * List of known log levels. Used to specify the urgency of a log message.\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Verbose\"] = 0] = \"Verbose\";\n    LogLevel[LogLevel[\"Info\"] = 1] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nconst Colors = {\n    red: \"\\u001b[91m\",\n    yellow: \"\\u001b[93m\",\n    cyan: \"\\u001b[96m\",\n    gray: \"\\u001b[90m\",\n    reset: \"\\u001b[0m\",\n};\nconst messagePrefixes = {\n    [LogLevel.Error]: \"Error: \",\n    [LogLevel.Warn]: \"Warning: \",\n    [LogLevel.Info]: \"Info: \",\n    [LogLevel.Verbose]: \"Debug: \",\n};\nconst coloredMessagePrefixes = {\n    [LogLevel.Error]: `${Colors.red}${messagePrefixes[LogLevel.Error]}${Colors.reset}`,\n    [LogLevel.Warn]: `${Colors.yellow}${messagePrefixes[LogLevel.Warn]}${Colors.reset}`,\n    [LogLevel.Info]: `${Colors.cyan}${messagePrefixes[LogLevel.Info]}${Colors.reset}`,\n    [LogLevel.Verbose]: `${Colors.gray}${messagePrefixes[LogLevel.Verbose]}${Colors.reset}`,\n};\n/**\n * A logger that will not produce any output.\n *\n * This logger also serves as the base class of other loggers as it implements\n * all the required utility functions.\n */\nclass Logger {\n    constructor() {\n        /**\n         * How many error messages have been logged?\n         */\n        this.errorCount = 0;\n        /**\n         * How many warning messages have been logged?\n         */\n        this.warningCount = 0;\n        this.seenErrors = new Set();\n        this.seenWarnings = new Set();\n        /**\n         * The minimum logging level to print.\n         */\n        this.level = LogLevel.Info;\n    }\n    /**\n     * Has an error been raised through the log method?\n     */\n    hasErrors() {\n        return this.errorCount > 0;\n    }\n    /**\n     * Has a warning been raised through the log method?\n     */\n    hasWarnings() {\n        return this.warningCount > 0;\n    }\n    /**\n     * Reset the error counter.\n     */\n    resetErrors() {\n        this.errorCount = 0;\n        this.seenErrors.clear();\n    }\n    /**\n     * Reset the warning counter.\n     */\n    resetWarnings() {\n        this.warningCount = 0;\n        this.seenWarnings.clear();\n    }\n    /**\n     * Log the given verbose message.\n     *\n     * @param text  The message that should be logged.\n     * @param args  The arguments that should be printed into the given message.\n     */\n    verbose(text) {\n        this.log(text, LogLevel.Verbose);\n    }\n    /** Log the given info message. */\n    info(text) {\n        this.log(text, LogLevel.Info);\n    }\n    /**\n     * Log the given warning.\n     *\n     * @param text  The warning that should be logged.\n     * @param args  The arguments that should be printed into the given warning.\n     */\n    warn(text) {\n        if (this.seenWarnings.has(text))\n            return;\n        this.seenWarnings.add(text);\n        this.log(text, LogLevel.Warn);\n    }\n    /**\n     * Log the given error.\n     *\n     * @param text  The error that should be logged.\n     * @param args  The arguments that should be printed into the given error.\n     */\n    error(text) {\n        if (this.seenErrors.has(text))\n            return;\n        this.seenErrors.add(text);\n        this.log(text, LogLevel.Error);\n    }\n    /** @internal */\n    deprecated(text, addStack = true) {\n        var _a;\n        if (addStack) {\n            const stack = (_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\");\n            if (stack && stack.length >= 4) {\n                text = text + \"\\n\" + stack[3];\n            }\n        }\n        this.warn(text);\n    }\n    /**\n     * Print a log message.\n     *\n     * @param _message  The message itself.\n     * @param level  The urgency of the log message.\n     */\n    log(_message, level) {\n        if (level === LogLevel.Error) {\n            this.errorCount += 1;\n        }\n        if (level === LogLevel.Warn) {\n            this.warningCount += 1;\n        }\n    }\n    /**\n     * Print the given TypeScript log messages.\n     *\n     * @param diagnostics  The TypeScript messages that should be logged.\n     */\n    diagnostics(diagnostics) {\n        diagnostics.forEach((diagnostic) => {\n            this.diagnostic(diagnostic);\n        });\n    }\n    /**\n     * Print the given TypeScript log message.\n     *\n     * @param diagnostic  The TypeScript message that should be logged.\n     */\n    diagnostic(diagnostic) {\n        const output = ts.formatDiagnosticsWithColorAndContext([diagnostic], {\n            getCanonicalFileName: path_1.resolve,\n            getCurrentDirectory: () => process.cwd(),\n            getNewLine: () => ts.sys.newLine,\n        });\n        switch (diagnostic.category) {\n            case ts.DiagnosticCategory.Error:\n                this.log(output, LogLevel.Error);\n                break;\n            case ts.DiagnosticCategory.Warning:\n                this.log(output, LogLevel.Warn);\n                break;\n            case ts.DiagnosticCategory.Message:\n                this.log(output, LogLevel.Info);\n        }\n    }\n}\nexports.Logger = Logger;\n/**\n * A logger that outputs all messages to the console.\n */\nclass ConsoleLogger extends Logger {\n    /**\n     * Create a new ConsoleLogger instance.\n     */\n    constructor() {\n        super();\n        this.hasColoredOutput = !(\"NO_COLOR\" in process.env);\n    }\n    /**\n     * Print a log message.\n     *\n     * @param message  The message itself.\n     * @param level  The urgency of the log message.\n     */\n    log(message, level) {\n        super.log(message, level);\n        if (level < this.level && !isDebugging()) {\n            return;\n        }\n        const method = {\n            [LogLevel.Error]: \"error\",\n            [LogLevel.Warn]: \"warn\",\n            [LogLevel.Info]: \"info\",\n            [LogLevel.Verbose]: \"log\",\n        }[level];\n        const prefix = this.hasColoredOutput\n            ? coloredMessagePrefixes[level]\n            : messagePrefixes[level];\n        console[method](prefix + message);\n    }\n}\nexports.ConsoleLogger = ConsoleLogger;\n/**\n * A logger that calls a callback function.\n */\nclass CallbackLogger extends Logger {\n    /**\n     * Create a new CallbackLogger instance.\n     *\n     * @param callback  The callback that should be used to log messages.\n     */\n    constructor(callback) {\n        super();\n        this.callback = callback;\n    }\n    /**\n     * Print a log message.\n     *\n     * @param message  The message itself.\n     * @param level  The urgency of the log message.\n     */\n    log(message, level) {\n        super.log(message, level);\n        this.callback(message, level);\n    }\n}\nexports.CallbackLogger = CallbackLogger;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParameterHint = exports.ParameterType = exports.EmitStrategy = exports.TSConfigReader = exports.TypeDocReader = exports.ArgumentsReader = exports.BindOption = exports.Options = void 0;\nvar options_1 = require(\"./options\");\nObject.defineProperty(exports, \"Options\", { enumerable: true, get: function () { return options_1.Options; } });\nObject.defineProperty(exports, \"BindOption\", { enumerable: true, get: function () { return options_1.BindOption; } });\nvar readers_1 = require(\"./readers\");\nObject.defineProperty(exports, \"ArgumentsReader\", { enumerable: true, get: function () { return readers_1.ArgumentsReader; } });\nObject.defineProperty(exports, \"TypeDocReader\", { enumerable: true, get: function () { return readers_1.TypeDocReader; } });\nObject.defineProperty(exports, \"TSConfigReader\", { enumerable: true, get: function () { return readers_1.TSConfigReader; } });\nvar declaration_1 = require(\"./declaration\");\nObject.defineProperty(exports, \"EmitStrategy\", { enumerable: true, get: function () { return declaration_1.EmitStrategy; } });\nObject.defineProperty(exports, \"ParameterType\", { enumerable: true, get: function () { return declaration_1.ParameterType; } });\nObject.defineProperty(exports, \"ParameterHint\", { enumerable: true, get: function () { return declaration_1.ParameterHint; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BindOption = exports.Options = void 0;\nconst declaration_1 = require(\"./declaration\");\nconst array_1 = require(\"../array\");\nconst declaration_2 = require(\"./declaration\");\nconst sources_1 = require(\"./sources\");\n/**\n * Maintains a collection of option declarations split into TypeDoc options\n * and TypeScript options. Ensures options are of the correct type for calling\n * code.\n *\n * ### Option Discovery\n *\n * Since plugins commonly add custom options, and TypeDoc does not permit options which have\n * not been declared to be set, options must be read twice. The first time options are read,\n * a noop logger is passed so that any errors are ignored. Then, after loading plugins, options\n * are read again, this time with the logger specified by the application.\n *\n * Options are read in a specific order.\n * 1. argv (0) - Must be read first since it should change the files read when\n *    passing --options or --tsconfig.\n * 2. typedoc-json (100) - Read next so that it can specify the tsconfig.json file to read.\n * 3. tsconfig-json (200) - Last config file reader, cannot specify the typedoc.json file to read.\n * 4. argv (300) - Read argv again since any options set there should override those set in config\n *    files.\n */\nclass Options {\n    constructor(logger) {\n        this._readers = [];\n        this._declarations = new Map();\n        this._values = {};\n        this._setOptions = new Set();\n        this._compilerOptions = {};\n        this._fileNames = [];\n        this._projectReferences = [];\n        this._logger = logger;\n    }\n    /**\n     * Marks the options as readonly, enables caching when fetching options, which improves performance.\n     */\n    freeze() {\n        Object.freeze(this._values);\n    }\n    /**\n     * Checks if the options object has been frozen, preventing future changes to option values.\n     */\n    isFrozen() {\n        return Object.isFrozen(this._values);\n    }\n    /**\n     * Sets the logger used when an option declaration fails to be added.\n     * @param logger\n     */\n    setLogger(logger) {\n        this._logger = logger;\n    }\n    /**\n     * Adds the option declarations declared by the TypeDoc and all supported TypeScript declarations.\n     */\n    addDefaultDeclarations() {\n        (0, sources_1.addTypeDocOptions)(this);\n    }\n    reset(name) {\n        if (name != null) {\n            const declaration = this.getDeclaration(name);\n            if (!declaration) {\n                throw new Error(\"Cannot reset an option which has not been declared.\");\n            }\n            this._values[declaration.name] = (0, declaration_2.getDefaultValue)(declaration);\n            this._setOptions.delete(declaration.name);\n        }\n        else {\n            for (const declaration of this.getDeclarations()) {\n                this._values[declaration.name] = (0, declaration_2.getDefaultValue)(declaration);\n            }\n            this._setOptions.clear();\n            this._compilerOptions = {};\n            this._fileNames = [];\n        }\n    }\n    /**\n     * Adds an option reader that will be used to read configuration values\n     * from the command line, configuration files, or other locations.\n     * @param reader\n     */\n    addReader(reader) {\n        (0, array_1.insertPrioritySorted)(this._readers, reader);\n    }\n    /**\n     * Removes all readers of a given name.\n     * @param name\n     * @deprecated should not be used, will be removed in 0.23\n     */\n    removeReaderByName(name) {\n        this._readers = this._readers.filter((reader) => reader.name !== name);\n    }\n    read(logger) {\n        for (const reader of this._readers) {\n            reader.read(this, logger);\n        }\n    }\n    addDeclaration(declaration) {\n        const decl = this.getDeclaration(declaration.name);\n        if (decl) {\n            this._logger.error(`The option ${declaration.name} has already been registered`);\n        }\n        else {\n            this._declarations.set(declaration.name, declaration);\n        }\n        this._values[declaration.name] = (0, declaration_2.getDefaultValue)(declaration);\n    }\n    /**\n     * Adds the given declarations to the container\n     * @param declarations\n     * @deprecated will be removed in 0.23.\n     */\n    addDeclarations(declarations) {\n        for (const decl of declarations) {\n            this.addDeclaration(decl);\n        }\n    }\n    /**\n     * Removes a declared option.\n     * WARNING: This is probably a bad idea. If you do this you will probably cause a crash\n     * when code assumes that an option that it declared still exists.\n     * @param name\n     * @deprecated will be removed in 0.23.\n     */\n    removeDeclarationByName(name) {\n        const declaration = this.getDeclaration(name);\n        if (declaration) {\n            this._declarations.delete(declaration.name);\n            delete this._values[declaration.name];\n        }\n    }\n    /**\n     * Gets a declaration by one of its names.\n     * @param name\n     */\n    getDeclaration(name) {\n        return this._declarations.get(name);\n    }\n    /**\n     * Gets all declared options.\n     */\n    getDeclarations() {\n        return (0, array_1.unique)(this._declarations.values());\n    }\n    isSet(name) {\n        if (!this._declarations.has(name)) {\n            throw new Error(\"Tried to check if an undefined option was set\");\n        }\n        return this._setOptions.has(name);\n    }\n    /**\n     * Gets all of the TypeDoc option values defined in this option container.\n     */\n    getRawValues() {\n        return this._values;\n    }\n    getValue(name) {\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            throw new Error(`Unknown option '${name}'`);\n        }\n        return this._values[declaration.name];\n    }\n    setValue(name, value, configPath) {\n        if (this.isFrozen()) {\n            throw new Error(\"Tried to modify an option value after options have been frozen.\");\n        }\n        const declaration = this.getDeclaration(name);\n        if (!declaration) {\n            throw new Error(`Tried to set an option (${name}) that was not declared.`);\n        }\n        const converted = (0, declaration_2.convert)(value, declaration, configPath !== null && configPath !== void 0 ? configPath : process.cwd());\n        if (declaration.type === declaration_1.ParameterType.Flags) {\n            Object.assign(this._values[declaration.name], converted);\n        }\n        else {\n            this._values[declaration.name] = converted;\n        }\n        this._setOptions.add(name);\n    }\n    /**\n     * Gets the set compiler options.\n     */\n    getCompilerOptions() {\n        return this.fixCompilerOptions(this._compilerOptions);\n    }\n    /** @internal */\n    fixCompilerOptions(options) {\n        const overrides = this.getValue(\"compilerOptions\");\n        const result = { ...options };\n        if (overrides) {\n            Object.assign(result, overrides);\n        }\n        if (this.getValue(\"emit\") !== \"both\" &&\n            this.getValue(\"emit\") !== true) {\n            result.noEmit = true;\n            delete result.emitDeclarationOnly;\n        }\n        return result;\n    }\n    /**\n     * Gets the file names discovered through reading a tsconfig file.\n     */\n    getFileNames() {\n        return this._fileNames;\n    }\n    /**\n     * Gets the project references - used in solution style tsconfig setups.\n     */\n    getProjectReferences() {\n        return this._projectReferences;\n    }\n    /**\n     * Sets the compiler options that will be used to get a TS program.\n     */\n    setCompilerOptions(fileNames, options, projectReferences) {\n        if (this.isFrozen()) {\n            throw new Error(\"Tried to modify an option value after options have been sealed.\");\n        }\n        // We do this here instead of in the tsconfig reader so that API consumers which\n        // supply a program to `Converter.convert` instead of letting TypeDoc create one\n        // can just set the compiler options, and not need to know about this mapping.\n        // It feels a bit like a hack... but it's better to have it here than to put it\n        // in Application or Converter.\n        if (options.stripInternal && !this.isSet(\"excludeInternal\")) {\n            this.setValue(\"excludeInternal\", true);\n        }\n        this._fileNames = fileNames;\n        this._compilerOptions = { ...options };\n        this._projectReferences = projectReferences !== null && projectReferences !== void 0 ? projectReferences : [];\n    }\n}\nexports.Options = Options;\nfunction BindOption(name) {\n    return function (target, key) {\n        Object.defineProperty(target, key, {\n            get() {\n                const options = \"options\" in this ? this.options : this.application.options;\n                const value = options.getValue(name);\n                if (options.isFrozen()) {\n                    Object.defineProperty(this, key, { value });\n                }\n                return value;\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    };\n}\nexports.BindOption = BindOption;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaultValue = exports.convert = exports.ParameterType = exports.ParameterHint = exports.EmitStrategy = void 0;\nconst path_1 = require(\"path\");\nconst kind_1 = require(\"../../models/reflections/kind\");\nexports.EmitStrategy = {\n    true: true,\n    false: false,\n    both: \"both\",\n    docs: \"docs\",\n    none: \"none\", // Emit nothing, just convert and run validation\n};\nconst Kinds = Object.values(kind_1.ReflectionKind);\nvar ParameterHint;\n(function (ParameterHint) {\n    ParameterHint[ParameterHint[\"File\"] = 0] = \"File\";\n    ParameterHint[ParameterHint[\"Directory\"] = 1] = \"Directory\";\n})(ParameterHint = exports.ParameterHint || (exports.ParameterHint = {}));\nvar ParameterType;\n(function (ParameterType) {\n    ParameterType[ParameterType[\"String\"] = 0] = \"String\";\n    /**\n     * Resolved according to the config directory.\n     */\n    ParameterType[ParameterType[\"Path\"] = 1] = \"Path\";\n    ParameterType[ParameterType[\"Number\"] = 2] = \"Number\";\n    ParameterType[ParameterType[\"Boolean\"] = 3] = \"Boolean\";\n    ParameterType[ParameterType[\"Map\"] = 4] = \"Map\";\n    ParameterType[ParameterType[\"Mixed\"] = 5] = \"Mixed\";\n    ParameterType[ParameterType[\"Array\"] = 6] = \"Array\";\n    /**\n     * Resolved according to the config directory.\n     */\n    ParameterType[ParameterType[\"PathArray\"] = 7] = \"PathArray\";\n    /**\n     * Resolved according to the config directory if it starts with `.`\n     */\n    ParameterType[ParameterType[\"ModuleArray\"] = 8] = \"ModuleArray\";\n    /**\n     * Resolved according to the config directory unless it starts with `**`, after skipping any leading `!` and `#` characters.\n     */\n    ParameterType[ParameterType[\"GlobArray\"] = 9] = \"GlobArray\";\n    /**\n     * An object with true/false flags\n     */\n    ParameterType[ParameterType[\"Flags\"] = 10] = \"Flags\";\n})(ParameterType = exports.ParameterType || (exports.ParameterType = {}));\nconst converters = {\n    [ParameterType.String](value, option) {\n        var _a;\n        const stringValue = value == null ? \"\" : String(value);\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, stringValue);\n        return stringValue;\n    },\n    [ParameterType.Path](value, option, configPath) {\n        var _a;\n        const stringValue = value == null ? \"\" : (0, path_1.resolve)(configPath, String(value));\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, stringValue);\n        return stringValue;\n    },\n    [ParameterType.Number](value, option) {\n        var _a;\n        const numValue = parseInt(String(value), 10) || 0;\n        if (!valueIsWithinBounds(numValue, option.minValue, option.maxValue)) {\n            throw new Error(getBoundsError(option.name, option.minValue, option.maxValue));\n        }\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, numValue);\n        return numValue;\n    },\n    [ParameterType.Boolean](value) {\n        return !!value;\n    },\n    [ParameterType.Array](value, option) {\n        var _a;\n        let strArrValue = new Array();\n        if (Array.isArray(value)) {\n            strArrValue = value.map(String);\n        }\n        else if (typeof value === \"string\") {\n            strArrValue = [value];\n        }\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, strArrValue);\n        return strArrValue;\n    },\n    [ParameterType.PathArray](value, option, configPath) {\n        var _a;\n        let strArrValue = new Array();\n        if (Array.isArray(value)) {\n            strArrValue = value.map(String);\n        }\n        else if (typeof value === \"string\") {\n            strArrValue = [value];\n        }\n        strArrValue = strArrValue.map((path) => (0, path_1.resolve)(configPath, path));\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, strArrValue);\n        return strArrValue;\n    },\n    [ParameterType.ModuleArray](value, option, configPath) {\n        var _a;\n        let strArrValue = new Array();\n        if (Array.isArray(value)) {\n            strArrValue = value.map(String);\n        }\n        else if (typeof value === \"string\") {\n            strArrValue = [value];\n        }\n        strArrValue = resolveModulePaths(strArrValue, configPath);\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, strArrValue);\n        return strArrValue;\n    },\n    [ParameterType.GlobArray](value, option, configPath) {\n        var _a;\n        let strArrValue = new Array();\n        if (Array.isArray(value)) {\n            strArrValue = value.map(String);\n        }\n        else if (typeof value === \"string\") {\n            strArrValue = [value];\n        }\n        strArrValue = resolveGlobPaths(strArrValue, configPath);\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, strArrValue);\n        return strArrValue;\n    },\n    [ParameterType.Map](value, option) {\n        var _a;\n        const key = String(value);\n        if (option.map instanceof Map) {\n            if (option.map.has(key)) {\n                return option.map.get(key);\n            }\n            else if ([...option.map.values()].includes(value)) {\n                return value;\n            }\n        }\n        else if (key in option.map) {\n            if (isTsNumericEnum(option.map) && typeof value === \"number\") {\n                return value;\n            }\n            return option.map[key];\n        }\n        else if (Object.values(option.map).includes(value)) {\n            return value;\n        }\n        throw new Error((_a = option.mapError) !== null && _a !== void 0 ? _a : getMapError(option.map, option.name));\n    },\n    [ParameterType.Mixed](value, option) {\n        var _a;\n        (_a = option.validate) === null || _a === void 0 ? void 0 : _a.call(option, value);\n        return value;\n    },\n    [ParameterType.Flags](value, option) {\n        if (typeof value === \"boolean\") {\n            value = Object.fromEntries(Object.keys(option.defaults).map((key) => [key, value]));\n        }\n        if (typeof value !== \"object\" || value == null) {\n            throw new Error(`Expected an object with flag values for ${option.name} or true/false`);\n        }\n        const obj = { ...value };\n        for (const key of Object.keys(obj)) {\n            if (!Object.prototype.hasOwnProperty.call(option.defaults, key)) {\n                throw new Error(`The flag '${key}' is not valid for ${option.name}, expected one of: ${Object.keys(option.defaults).join(\", \")}`);\n            }\n            if (typeof obj[key] !== \"boolean\") {\n                // Explicit null/undefined, switch to default.\n                if (obj[key] == null) {\n                    obj[key] = option.defaults[key];\n                }\n                else {\n                    throw new Error(`Flag values for ${option.name} must be a boolean.`);\n                }\n            }\n        }\n        return obj;\n    },\n};\n/**\n * The default conversion function used by the Options container. Readers may\n * re-use this conversion function or implement their own. The arguments reader\n * implements its own since 'false' should not be converted to true for a boolean option.\n * @param value The value to convert.\n * @param option The option for which the value should be converted.\n * @returns The result of the conversion. Might be the value or an error.\n */\nfunction convert(value, option, configPath) {\n    var _a;\n    const _converters = converters;\n    return _converters[(_a = option.type) !== null && _a !== void 0 ? _a : ParameterType.String](value, option, configPath);\n}\nexports.convert = convert;\nconst defaultGetters = {\n    [ParameterType.String](option) {\n        var _a;\n        return (_a = option.defaultValue) !== null && _a !== void 0 ? _a : \"\";\n    },\n    [ParameterType.Path](option) {\n        var _a;\n        const defaultStr = (_a = option.defaultValue) !== null && _a !== void 0 ? _a : \"\";\n        if (defaultStr == \"\") {\n            return \"\";\n        }\n        return (0, path_1.isAbsolute)(defaultStr)\n            ? defaultStr\n            : (0, path_1.join)(process.cwd(), defaultStr);\n    },\n    [ParameterType.Number](option) {\n        var _a;\n        return (_a = option.defaultValue) !== null && _a !== void 0 ? _a : 0;\n    },\n    [ParameterType.Boolean](option) {\n        var _a;\n        return (_a = option.defaultValue) !== null && _a !== void 0 ? _a : false;\n    },\n    [ParameterType.Map](option) {\n        return option.defaultValue;\n    },\n    [ParameterType.Mixed](option) {\n        return option.defaultValue;\n    },\n    [ParameterType.Array](option) {\n        var _a;\n        return (_a = option.defaultValue) !== null && _a !== void 0 ? _a : [];\n    },\n    [ParameterType.PathArray](option) {\n        var _a, _b;\n        return ((_b = (_a = option.defaultValue) === null || _a === void 0 ? void 0 : _a.map((value) => (0, path_1.resolve)(process.cwd(), value))) !== null && _b !== void 0 ? _b : []);\n    },\n    [ParameterType.ModuleArray](option) {\n        var _a, _b;\n        return ((_b = (_a = option.defaultValue) === null || _a === void 0 ? void 0 : _a.map((value) => value.startsWith(\".\") ? (0, path_1.resolve)(process.cwd(), value) : value)) !== null && _b !== void 0 ? _b : []);\n    },\n    [ParameterType.GlobArray](option) {\n        var _a;\n        return resolveGlobPaths((_a = option.defaultValue) !== null && _a !== void 0 ? _a : [], process.cwd());\n    },\n    [ParameterType.Flags](option) {\n        return { ...option.defaults };\n    },\n};\nfunction getDefaultValue(option) {\n    var _a;\n    const getters = defaultGetters;\n    return getters[(_a = option.type) !== null && _a !== void 0 ? _a : ParameterType.String](option);\n}\nexports.getDefaultValue = getDefaultValue;\nfunction resolveGlobPaths(globs, configPath) {\n    return globs.map((path) => {\n        var _a, _b;\n        const start = (_b = (_a = path.match(/^[!#]+/)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : \"\";\n        const remaining = path.substr(start.length);\n        if (!remaining.startsWith(\"**\")) {\n            return start + (0, path_1.resolve)(configPath, remaining);\n        }\n        return start + remaining;\n    });\n}\nfunction resolveModulePaths(modules, configPath) {\n    return modules.map((path) => {\n        if (path.startsWith(\".\")) {\n            return (0, path_1.resolve)(configPath, path);\n        }\n        return path;\n    });\n}\nfunction isTsNumericEnum(map) {\n    return Object.values(map).every((key) => map[map[key]] === key);\n}\n/**\n * Returns an error message for a map option, indicating that a given value was not one of the values within the map.\n * @param map The values for the option.\n * @param name The name of the option.\n * @returns The error message.\n */\nfunction getMapError(map, name) {\n    let keys = map instanceof Map ? [...map.keys()] : Object.keys(map);\n    // If the map is a TS numeric enum we need to filter out the numeric keys.\n    // TS numeric enums have the property that every key maps to a value, which maps back to that key.\n    if (!(map instanceof Map) && isTsNumericEnum(map)) {\n        // This works because TS enum keys may not be numeric.\n        keys = keys.filter((key) => Number.isNaN(parseInt(key, 10)));\n    }\n    return `${name} must be one of ${keys.join(\", \")}`;\n}\n/**\n * Returns an error message for a value that is out of bounds of the given min and/or max values.\n * @param name The name of the thing the value represents.\n * @param minValue The lower bound of the range of allowed values.\n * @param maxValue The upper bound of the range of allowed values.\n * @returns The error message.\n */\nfunction getBoundsError(name, minValue, maxValue) {\n    if (isFiniteNumber(minValue) && isFiniteNumber(maxValue)) {\n        return `${name} must be between ${minValue} and ${maxValue}`;\n    }\n    else if (isFiniteNumber(minValue)) {\n        return `${name} must be >= ${minValue}`;\n    }\n    else {\n        return `${name} must be <= ${maxValue}`;\n    }\n}\n/**\n * Checks if the given value is a finite number.\n * @param value The value being checked.\n * @returns True, if the value is a finite number, otherwise false.\n */\nfunction isFiniteNumber(value) {\n    return Number.isFinite(value);\n}\n/**\n * Checks if a value is between the bounds of the given min and/or max values.\n * @param value The value being checked.\n * @param minValue The lower bound of the range of allowed values.\n * @param maxValue The upper bound of the range of allowed values.\n * @returns True, if the value is within the given bounds, otherwise false.\n */\nfunction valueIsWithinBounds(value, minValue, maxValue) {\n    if (isFiniteNumber(minValue) && isFiniteNumber(maxValue)) {\n        return minValue <= value && value <= maxValue;\n    }\n    else if (isFiniteNumber(minValue)) {\n        return minValue <= value;\n    }\n    else if (isFiniteNumber(maxValue)) {\n        return value <= maxValue;\n    }\n    else {\n        return true;\n    }\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addTypeDocOptions = void 0;\nvar typedoc_1 = require(\"./typedoc\");\nObject.defineProperty(exports, \"addTypeDocOptions\", { enumerable: true, get: function () { return typedoc_1.addTypeDocOptions; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addTypeDocOptions = void 0;\nconst loggers_1 = require(\"../../loggers\");\nconst declaration_1 = require(\"../declaration\");\nconst shiki_1 = require(\"shiki\");\nconst sort_1 = require(\"../../sort\");\nconst entry_point_1 = require(\"../../entry-point\");\nconst kind_1 = require(\"../../../models/reflections/kind\");\nfunction addTypeDocOptions(options) {\n    options.addDeclaration({\n        type: declaration_1.ParameterType.Path,\n        name: \"options\",\n        help: \"Specify a json option file that should be loaded. If not specified TypeDoc will look for 'typedoc.json' in the current directory.\",\n        hint: declaration_1.ParameterHint.File,\n        defaultValue: process.cwd(),\n    });\n    options.addDeclaration({\n        type: declaration_1.ParameterType.Path,\n        name: \"tsconfig\",\n        help: \"Specify a TypeScript config file that should be loaded. If not specified TypeDoc will look for 'tsconfig.json' in the current directory.\",\n        hint: declaration_1.ParameterHint.File,\n        defaultValue: process.cwd(),\n    });\n    options.addDeclaration({\n        name: \"entryPoints\",\n        help: \"The entry points of your documentation.\",\n        type: declaration_1.ParameterType.PathArray,\n    });\n    options.addDeclaration({\n        name: \"entryPointStrategy\",\n        help: \"The strategy to be used to convert entry points into documentation modules.\",\n        type: declaration_1.ParameterType.Map,\n        map: entry_point_1.EntryPointStrategy,\n        defaultValue: entry_point_1.EntryPointStrategy.Resolve,\n    });\n    options.addDeclaration({\n        name: \"exclude\",\n        help: \"Define patterns to be excluded when expanding a directory that was specified as an entry point.\",\n        type: declaration_1.ParameterType.GlobArray,\n    });\n    options.addDeclaration({\n        name: \"externalPattern\",\n        help: \"Define patterns for files that should be considered being external.\",\n        type: declaration_1.ParameterType.GlobArray,\n        defaultValue: [\"**/node_modules/**\"],\n    });\n    options.addDeclaration({\n        name: \"excludeExternals\",\n        help: \"Prevent externally resolved symbols from being documented.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"excludeNotDocumented\",\n        help: \"Prevent symbols that are not explicitly documented from appearing in the results.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"excludeInternal\",\n        help: \"Prevent symbols that are marked with @internal from being documented.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"excludePrivate\",\n        help: \"Ignore private variables and methods.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"excludeProtected\",\n        help: \"Ignore protected variables and methods.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"searchCategoryBoosts\",\n        help: \"Configure search to give a relevance boost to selected categories\",\n        type: declaration_1.ParameterType.Mixed,\n        validate(value) {\n            if (!isObject(value)) {\n                throw new Error(\"The 'searchCategoryBoosts' option must be a non-array object.\");\n            }\n            if (Object.values(value).some((x) => typeof x !== \"number\")) {\n                throw new Error(\"All values of 'searchCategoryBoosts' must be numbers.\");\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"searchGroupBoosts\",\n        help: 'Configure search to give a relevance boost to selected kinds (eg \"class\")',\n        type: declaration_1.ParameterType.Mixed,\n        validate(value) {\n            if (!isObject(value)) {\n                throw new Error(\"The 'searchGroupBoosts' option must be a non-array object.\");\n            }\n            const validValues = Object.values(kind_1.ReflectionKind)\n                .filter((v) => typeof v === \"string\")\n                .map((v) => v.toString());\n            for (const kindName in value) {\n                if (validValues.indexOf(kindName) < 0) {\n                    throw new Error(`'${kindName}' is an invalid value for 'searchGroupBoosts'. Must be one of: ${validValues.join(\", \")}`);\n                }\n            }\n            if (Object.values(value).some((x) => typeof x !== \"number\")) {\n                throw new Error(\"All values of 'searchGroupBoosts' must be numbers.\");\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"disableSources\",\n        help: \"Disable setting the source of a reflection when documenting it.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"includes\",\n        help: \"Specify the location to look for included documents (use [[include:FILENAME]] in comments).\",\n        type: declaration_1.ParameterType.Path,\n        hint: declaration_1.ParameterHint.Directory,\n    });\n    options.addDeclaration({\n        name: \"media\",\n        help: \"Specify the location with media files that should be copied to the output directory.\",\n        type: declaration_1.ParameterType.Path,\n        hint: declaration_1.ParameterHint.Directory,\n    });\n    options.addDeclaration({\n        name: \"watch\",\n        help: \"Watch files for changes and rebuild docs on change.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"preserveWatchOutput\",\n        help: \"If set, TypeDoc will not clear the screen between compilation runs.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"emit\",\n        help: \"Specify what TypeDoc should emit, 'docs', 'both', or 'none'.\",\n        type: declaration_1.ParameterType.Map,\n        map: declaration_1.EmitStrategy,\n        defaultValue: \"docs\",\n    });\n    options.addDeclaration({\n        name: \"out\",\n        help: \"Specify the location the documentation should be written to.\",\n        type: declaration_1.ParameterType.Path,\n        hint: declaration_1.ParameterHint.Directory,\n    });\n    options.addDeclaration({\n        name: \"json\",\n        help: \"Specify the location and filename a JSON file describing the project is written to.\",\n        type: declaration_1.ParameterType.Path,\n        hint: declaration_1.ParameterHint.File,\n    });\n    options.addDeclaration({\n        name: \"pretty\",\n        help: \"Specify whether the output JSON should be formatted with tabs.\",\n        type: declaration_1.ParameterType.Boolean,\n        defaultValue: true,\n    });\n    options.addDeclaration({\n        name: \"theme\",\n        help: \"Specify the path to the theme that should be used, or 'default' or 'minimal' to use built-in themes. \" +\n            \"Note: Not resolved according to the config file location, always resolved according to cwd.\",\n        type: declaration_1.ParameterType.String,\n        defaultValue: \"default\",\n    });\n    const defaultLightTheme = \"light-plus\";\n    const defaultDarkTheme = \"dark-plus\";\n    options.addDeclaration({\n        name: \"lightHighlightTheme\",\n        help: \"Specify the code highlighting theme in light mode.\",\n        type: declaration_1.ParameterType.String,\n        defaultValue: defaultLightTheme,\n        validate(value) {\n            if (!shiki_1.BUNDLED_THEMES.includes(value)) {\n                throw new Error(`lightHighlightTheme must be one of the following: ${shiki_1.BUNDLED_THEMES.join(\", \")}`);\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"darkHighlightTheme\",\n        help: \"Specify the code highlighting theme in dark mode.\",\n        type: declaration_1.ParameterType.String,\n        defaultValue: defaultDarkTheme,\n        validate(value) {\n            if (!shiki_1.BUNDLED_THEMES.includes(value)) {\n                throw new Error(`darkHighlightTheme must be one of the following: ${shiki_1.BUNDLED_THEMES.join(\", \")}`);\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"customCss\",\n        help: \"Path to a custom CSS file to for the theme to import.\",\n        type: declaration_1.ParameterType.Path,\n    });\n    options.addDeclaration({\n        name: \"name\",\n        help: \"Set the name of the project that will be used in the header of the template.\",\n    });\n    options.addDeclaration({\n        name: \"includeVersion\",\n        help: \"Add the package version to the project name.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"excludeTags\",\n        help: \"Remove the listed tags from doc comments.\",\n        type: declaration_1.ParameterType.Array,\n    });\n    options.addDeclaration({\n        name: \"readme\",\n        help: \"Path to the readme file that should be displayed on the index page. Pass `none` to disable the index page and start the documentation on the globals page.\",\n        type: declaration_1.ParameterType.Path,\n    });\n    options.addDeclaration({\n        name: \"defaultCategory\",\n        help: \"Specify the default category for reflections without a category.\",\n        defaultValue: \"Other\",\n    });\n    options.addDeclaration({\n        name: \"categoryOrder\",\n        help: \"Specify the order in which categories appear. * indicates the relative order for categories not in the list.\",\n        type: declaration_1.ParameterType.Array,\n    });\n    options.addDeclaration({\n        name: \"categorizeByGroup\",\n        help: \"Specify whether categorization will be done at the group level.\",\n        type: declaration_1.ParameterType.Boolean,\n        defaultValue: true,\n    });\n    options.addDeclaration({\n        name: \"cname\",\n        help: \"Set the CNAME file text, it's useful for custom domains on GitHub Pages.\",\n    });\n    options.addDeclaration({\n        name: \"sort\",\n        help: \"Specify the sort strategy for documented values.\",\n        type: declaration_1.ParameterType.Array,\n        defaultValue: [\"kind\", \"instance-first\", \"alphabetical\"],\n        validate(value) {\n            const invalid = new Set(value);\n            for (const v of sort_1.SORT_STRATEGIES) {\n                invalid.delete(v);\n            }\n            if (invalid.size !== 0) {\n                throw new Error(`sort may only specify known values, and invalid values were provided (${Array.from(invalid).join(\", \")}). The valid sort strategies are:\\n${sort_1.SORT_STRATEGIES.join(\", \")}`);\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"gitRevision\",\n        help: \"Use specified revision instead of the last revision for linking to GitHub/Bitbucket source files.\",\n    });\n    options.addDeclaration({\n        name: \"gitRemote\",\n        help: \"Use the specified remote for linking to GitHub/Bitbucket source files.\",\n        defaultValue: \"origin\",\n    });\n    options.addDeclaration({\n        name: \"gaID\",\n        help: \"Set the Google Analytics tracking ID and activate tracking code.\",\n    });\n    options.addDeclaration({\n        name: \"gaSite\",\n        help: \"Set the site name for Google Analytics. Defaults to `auto`.\",\n        defaultValue: \"auto\",\n    });\n    options.addDeclaration({\n        name: \"githubPages\",\n        help: \"Generate a .nojekyll file to prevent 404 errors in GitHub Pages. Defaults to `true`.\",\n        type: declaration_1.ParameterType.Boolean,\n        defaultValue: true,\n    });\n    options.addDeclaration({\n        name: \"hideGenerator\",\n        help: \"Do not print the TypeDoc link at the end of the page.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"hideLegend\",\n        help: \"Do not print the Legend for icons at the end of the page.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"cleanOutputDir\",\n        help: \"If set, TypeDoc will remove the output directory before writing output.\",\n        type: declaration_1.ParameterType.Boolean,\n        defaultValue: true,\n    });\n    options.addDeclaration({\n        name: \"help\",\n        help: \"Print this message.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"version\",\n        help: \"Print TypeDoc's version.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"showConfig\",\n        help: \"Print the resolved configuration and exit.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"plugin\",\n        help: \"Specify the npm plugins that should be loaded. Omit to load all installed plugins, set to 'none' to load no plugins.\",\n        type: declaration_1.ParameterType.ModuleArray,\n    });\n    options.addDeclaration({\n        name: \"logger\",\n        help: \"Specify the logger that should be used, 'none' or 'console'.\",\n        defaultValue: \"console\",\n        type: declaration_1.ParameterType.Mixed,\n    });\n    options.addDeclaration({\n        name: \"logLevel\",\n        help: \"Specify what level of logging should be used.\",\n        type: declaration_1.ParameterType.Map,\n        map: loggers_1.LogLevel,\n        defaultValue: loggers_1.LogLevel.Info,\n    });\n    options.addDeclaration({\n        name: \"markedOptions\",\n        help: \"Specify the options passed to Marked, the Markdown parser used by TypeDoc.\",\n        type: declaration_1.ParameterType.Mixed,\n        validate(value) {\n            if (!isObject(value)) {\n                throw new Error(\"The 'markedOptions' option must be a non-array object.\");\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"compilerOptions\",\n        help: \"Selectively override the TypeScript compiler options used by TypeDoc.\",\n        type: declaration_1.ParameterType.Mixed,\n        validate(value) {\n            if (!isObject(value)) {\n                throw new Error(\"The 'compilerOptions' option must be a non-array object.\");\n            }\n        },\n    });\n    options.addDeclaration({\n        name: \"treatWarningsAsErrors\",\n        help: \"If set, warnings will be treated as errors.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"listInvalidSymbolLinks\",\n        help: \"Emit a list of broken symbol {@link navigation} links after documentation generation, DEPRECATED, prefer validation.invalidLink instead.\",\n        type: declaration_1.ParameterType.Boolean,\n    });\n    options.addDeclaration({\n        name: \"intentionallyNotExported\",\n        help: \"A list of types which should not produce 'referenced but not documented' warnings.\",\n        type: declaration_1.ParameterType.Array,\n    });\n    options.addDeclaration({\n        name: \"requiredToBeDocumented\",\n        help: \"A list of reflection kinds that must be documented\",\n        type: declaration_1.ParameterType.Array,\n        validate(values) {\n            // this is good enough because the values of the ReflectionKind enum are all numbers\n            const validValues = Object.values(kind_1.ReflectionKind).filter((v) => typeof v === \"string\");\n            for (const kind of values) {\n                if (!validValues.includes(kind)) {\n                    throw new Error(`'${kind}' is an invalid value for 'requiredToBeDocumented'. Must be one of: ${validValues.join(\", \")}`);\n                }\n            }\n        },\n        defaultValue: [\n            \"Enum\",\n            \"EnumMember\",\n            \"Variable\",\n            \"Function\",\n            \"Class\",\n            \"Interface\",\n            \"Property\",\n            \"Method\",\n            \"Accessor\",\n            \"TypeAlias\",\n        ],\n    });\n    options.addDeclaration({\n        name: \"validation\",\n        help: \"Specify which validation steps TypeDoc should perform on your generated documentation.\",\n        type: declaration_1.ParameterType.Flags,\n        defaults: {\n            notExported: true,\n            invalidLink: false,\n            notDocumented: false,\n        },\n    });\n}\nexports.addTypeDocOptions = addTypeDocOptions;\nfunction isObject(x) {\n    return !!x && typeof x === \"object\" && !Array.isArray(x);\n}\n","\n/**\n * Module which handles sorting reflections according to a user specified strategy.\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortReflections = exports.SORT_STRATEGIES = void 0;\nconst kind_1 = require(\"../models/reflections/kind\");\nconst types_1 = require(\"../models/types\");\nexports.SORT_STRATEGIES = [\n    \"source-order\",\n    \"alphabetical\",\n    \"enum-value-ascending\",\n    \"enum-value-descending\",\n    \"static-first\",\n    \"instance-first\",\n    \"visibility\",\n    \"required-first\",\n    \"kind\",\n];\n// Return true if a < b\nconst sorts = {\n    \"source-order\"(a, b) {\n        var _a, _b;\n        const aSymbol = a.project.getSymbolFromReflection(a);\n        const bSymbol = b.project.getSymbolFromReflection(b);\n        // This is going to be somewhat ambiguous. No way around that. Treat the first\n        // declaration of a symbol as its ordering declaration.\n        const aDecl = (_a = aSymbol === null || aSymbol === void 0 ? void 0 : aSymbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];\n        const bDecl = (_b = bSymbol === null || bSymbol === void 0 ? void 0 : bSymbol.getDeclarations()) === null || _b === void 0 ? void 0 : _b[0];\n        if (aDecl && bDecl) {\n            const aFile = aDecl.getSourceFile().fileName;\n            const bFile = bDecl.getSourceFile().fileName;\n            if (aFile < bFile) {\n                return true;\n            }\n            if (aFile == bFile && aDecl.pos < bDecl.pos) {\n                return true;\n            }\n            return false;\n        }\n        // Someone is doing something weird. Fail to re-order. This *might* be a bug in TD\n        // but it could also be TS having some exported symbol without a declaration.\n        return false;\n    },\n    alphabetical(a, b) {\n        return a.name < b.name;\n    },\n    \"enum-value-ascending\"(a, b) {\n        if (a.kind == kind_1.ReflectionKind.EnumMember &&\n            b.kind == kind_1.ReflectionKind.EnumMember) {\n            const aValue = a.type instanceof types_1.LiteralType ? a.type.value : -Infinity;\n            const bValue = b.type instanceof types_1.LiteralType ? b.type.value : -Infinity;\n            return aValue < bValue;\n        }\n        return false;\n    },\n    \"enum-value-descending\"(a, b) {\n        if (a.kind == kind_1.ReflectionKind.EnumMember &&\n            b.kind == kind_1.ReflectionKind.EnumMember) {\n            const aValue = a.type instanceof types_1.LiteralType ? a.type.value : -Infinity;\n            const bValue = b.type instanceof types_1.LiteralType ? b.type.value : -Infinity;\n            return bValue < aValue;\n        }\n        return false;\n    },\n    \"static-first\"(a, b) {\n        return a.flags.isStatic && !b.flags.isStatic;\n    },\n    \"instance-first\"(a, b) {\n        return !a.flags.isStatic && b.flags.isStatic;\n    },\n    visibility(a, b) {\n        // Note: flags.isPublic may not be set on public members. It will only be set\n        // if the user explicitly marks members as public. Therefore, we can't use it\n        // here to get a reliable sort order.\n        if (a.flags.isPrivate) {\n            return false; // Not sorted before anything\n        }\n        if (a.flags.isProtected) {\n            return b.flags.isPrivate; // Sorted before privates\n        }\n        if (b.flags.isPrivate || b.flags.isProtected) {\n            return true; // We are public, sort before b if b is less visible\n        }\n        return false;\n    },\n    \"required-first\"(a, b) {\n        return !a.flags.isOptional && b.flags.isOptional;\n    },\n    kind(a, b) {\n        const weights = [\n            kind_1.ReflectionKind.Reference,\n            kind_1.ReflectionKind.Project,\n            kind_1.ReflectionKind.Module,\n            kind_1.ReflectionKind.Namespace,\n            kind_1.ReflectionKind.Enum,\n            kind_1.ReflectionKind.EnumMember,\n            kind_1.ReflectionKind.Class,\n            kind_1.ReflectionKind.Interface,\n            kind_1.ReflectionKind.TypeAlias,\n            kind_1.ReflectionKind.Constructor,\n            kind_1.ReflectionKind.Event,\n            kind_1.ReflectionKind.Property,\n            kind_1.ReflectionKind.Variable,\n            kind_1.ReflectionKind.Function,\n            kind_1.ReflectionKind.Accessor,\n            kind_1.ReflectionKind.Method,\n            kind_1.ReflectionKind.ObjectLiteral,\n            kind_1.ReflectionKind.Parameter,\n            kind_1.ReflectionKind.TypeParameter,\n            kind_1.ReflectionKind.TypeLiteral,\n            kind_1.ReflectionKind.CallSignature,\n            kind_1.ReflectionKind.ConstructorSignature,\n            kind_1.ReflectionKind.IndexSignature,\n            kind_1.ReflectionKind.GetSignature,\n            kind_1.ReflectionKind.SetSignature,\n        ];\n        return weights.indexOf(a.kind) < weights.indexOf(b.kind);\n    },\n};\nfunction sortReflections(reflections, strategies) {\n    reflections.sort((a, b) => {\n        for (const s of strategies) {\n            if (sorts[s](a, b)) {\n                return -1;\n            }\n            if (sorts[s](b, a)) {\n                return 1;\n            }\n        }\n        return 0;\n    });\n}\nexports.sortReflections = sortReflections;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeDocReader = exports.TSConfigReader = exports.ArgumentsReader = void 0;\nvar arguments_1 = require(\"./arguments\");\nObject.defineProperty(exports, \"ArgumentsReader\", { enumerable: true, get: function () { return arguments_1.ArgumentsReader; } });\nvar tsconfig_1 = require(\"./tsconfig\");\nObject.defineProperty(exports, \"TSConfigReader\", { enumerable: true, get: function () { return tsconfig_1.TSConfigReader; } });\nvar typedoc_1 = require(\"./typedoc\");\nObject.defineProperty(exports, \"TypeDocReader\", { enumerable: true, get: function () { return typedoc_1.TypeDocReader; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgumentsReader = void 0;\nconst assert_1 = require(\"assert\");\nconst declaration_1 = require(\"../declaration\");\nconst ARRAY_OPTION_TYPES = new Set([\n    declaration_1.ParameterType.Array,\n    declaration_1.ParameterType.PathArray,\n    declaration_1.ParameterType.ModuleArray,\n    declaration_1.ParameterType.GlobArray,\n]);\n/**\n * Obtains option values from command-line arguments\n */\nclass ArgumentsReader {\n    constructor(priority, args = process.argv.slice(2)) {\n        this.name = \"arguments\";\n        this.priority = priority;\n        this.args = args;\n    }\n    read(container, logger) {\n        // Make container's type more lax, we do the appropriate checks manually.\n        const options = container;\n        const seen = new Set();\n        let index = 0;\n        const trySet = (name, value) => {\n            try {\n                options.setValue(name, value);\n            }\n            catch (err) {\n                (0, assert_1.ok)(err instanceof Error);\n                logger.error(err.message);\n            }\n        };\n        while (index < this.args.length) {\n            const name = this.args[index];\n            const decl = name.startsWith(\"-\")\n                ? (index++, options.getDeclaration(name.replace(/^--?/, \"\")))\n                : options.getDeclaration(\"entryPoints\");\n            if (decl) {\n                if (seen.has(decl.name) && ARRAY_OPTION_TYPES.has(decl.type)) {\n                    trySet(decl.name, options.getValue(decl.name).concat(this.args[index]));\n                }\n                else if (decl.type === declaration_1.ParameterType.Boolean ||\n                    decl.type === declaration_1.ParameterType.Flags) {\n                    const value = String(this.args[index]).toLowerCase();\n                    if (value === \"true\" || value === \"false\") {\n                        trySet(decl.name, value === \"true\");\n                    }\n                    else {\n                        trySet(decl.name, true);\n                        // Bool option didn't consume the next argument as expected.\n                        index--;\n                    }\n                }\n                else {\n                    if (index === this.args.length) {\n                        // Only boolean values have optional values.\n                        logger.warn(`--${decl.name} expected a value, but none was given as an argument`);\n                    }\n                    trySet(decl.name, this.args[index]);\n                }\n                seen.add(decl.name);\n                index++;\n                continue;\n            }\n            if (name.includes(\".\")) {\n                const actualName = name.split(\".\")[0].replace(/^--?/, \"\");\n                const decl = options.getDeclaration(actualName);\n                if (decl && decl.type === declaration_1.ParameterType.Flags) {\n                    const flagName = name.split(\".\", 2)[1];\n                    const value = String(this.args[index]).toLowerCase();\n                    if (value === \"true\" || value === \"false\") {\n                        trySet(decl.name, { [flagName]: value === \"true\" });\n                    }\n                    else {\n                        trySet(decl.name, { [flagName]: true });\n                        // Bool option didn't consume the next argument as expected.\n                        index--;\n                    }\n                    index++;\n                    continue;\n                }\n            }\n            logger.error(`Unknown option: ${name}`);\n            index++;\n        }\n    }\n}\nexports.ArgumentsReader = ArgumentsReader;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TSConfigReader = void 0;\nconst path_1 = require(\"path\");\nconst fs_1 = require(\"fs\");\nconst ts = require(\"typescript\");\nconst fs_2 = require(\"../../fs\");\nconst assert_1 = require(\"assert\");\nfunction isFile(file) {\n    return (0, fs_1.existsSync)(file) && (0, fs_1.statSync)(file).isFile();\n}\nfunction isDir(path) {\n    return (0, fs_1.existsSync)(path) && (0, fs_1.statSync)(path).isDirectory();\n}\nclass TSConfigReader {\n    constructor() {\n        /**\n         * Note: Runs after the {@link TypeDocReader}.\n         */\n        this.priority = 200;\n        this.name = \"tsconfig-json\";\n    }\n    /**\n     * Not considered part of the public API. You can use it, but it might break.\n     * @internal\n     */\n    static findConfigFile(file) {\n        let fileToRead = file;\n        if (isDir(fileToRead)) {\n            fileToRead = ts.findConfigFile(file, isFile);\n        }\n        if (!fileToRead || !isFile(fileToRead)) {\n            return;\n        }\n        return fileToRead;\n    }\n    read(container, logger) {\n        var _a, _b;\n        const file = container.getValue(\"tsconfig\");\n        let fileToRead = TSConfigReader.findConfigFile(file);\n        if (!fileToRead) {\n            // If the user didn't give us this option, we shouldn't complain about not being able to find it.\n            if (container.isSet(\"tsconfig\")) {\n                logger.error(`The tsconfig file ${file} does not exist`);\n            }\n            return;\n        }\n        fileToRead = (0, fs_2.normalizePath)((0, path_1.resolve)(fileToRead));\n        let fatalError = false;\n        const parsed = ts.getParsedCommandLineOfConfigFile(fileToRead, {}, {\n            ...ts.sys,\n            onUnRecoverableConfigFileDiagnostic(error) {\n                logger.diagnostic(error);\n                fatalError = true;\n            },\n        });\n        if (!parsed || fatalError) {\n            return;\n        }\n        logger.diagnostics(parsed.errors);\n        const typedocOptions = (_b = (_a = parsed.raw) === null || _a === void 0 ? void 0 : _a.typedocOptions) !== null && _b !== void 0 ? _b : {};\n        if (typedocOptions.options) {\n            logger.error([\n                \"typedocOptions in tsconfig file specifies an option file to read but the option\",\n                \"file has already been read. This is likely a misconfiguration.\",\n            ].join(\" \"));\n            delete typedocOptions.options;\n        }\n        if (typedocOptions.tsconfig) {\n            logger.error(\"typedocOptions in tsconfig file may not specify a tsconfig file to read\");\n            delete typedocOptions.tsconfig;\n        }\n        container.setCompilerOptions(parsed.fileNames, parsed.options, parsed.projectReferences);\n        for (const [key, val] of Object.entries(typedocOptions || {})) {\n            try {\n                // We catch the error, so can ignore the strict type checks\n                container.setValue(key, val, (0, path_1.join)(fileToRead, \"..\"));\n            }\n            catch (error) {\n                (0, assert_1.ok)(error instanceof Error);\n                logger.error(error.message);\n            }\n        }\n    }\n}\nexports.TSConfigReader = TSConfigReader;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeDocReader = void 0;\nconst path_1 = require(\"path\");\nconst FS = require(\"fs\");\nconst assert_1 = require(\"assert\");\n/**\n * Obtains option values from typedoc.json\n * or typedoc.js (discouraged since ~0.14, don't fully deprecate until API has stabilized)\n */\nclass TypeDocReader {\n    constructor() {\n        /**\n         * Should run before the tsconfig reader so that it can specify a tsconfig file to read.\n         */\n        this.priority = 100;\n        this.name = \"typedoc-json\";\n    }\n    /**\n     * Read user configuration from a typedoc.json or typedoc.js configuration file.\n     * @param container\n     * @param logger\n     */\n    read(container, logger) {\n        const path = container.getValue(\"options\");\n        const file = this.findTypedocFile(path);\n        if (!file) {\n            if (container.isSet(\"options\")) {\n                logger.error(`The options file could not be found with the given path ${path}`);\n            }\n            return;\n        }\n        const seen = new Set();\n        this.readFile(file, container, logger, seen);\n    }\n    /**\n     * Read the given options file + any extended files.\n     * @param file\n     * @param container\n     * @param logger\n     */\n    readFile(file, container, logger, seen) {\n        if (seen.has(file)) {\n            logger.error(`Tried to load the options file ${file} multiple times.`);\n            return;\n        }\n        seen.add(file);\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const fileContent = require(file);\n        if (typeof fileContent !== \"object\" || !fileContent) {\n            logger.error(`The file ${file} is not an object.`);\n            return;\n        }\n        // clone option object to avoid of property changes in re-calling this file\n        const data = { ...fileContent };\n        delete data[\"$schema\"]; // Useful for better autocompletion, should not be read as a key.\n        if (\"extends\" in data) {\n            const extended = getStringArray(data[\"extends\"]);\n            for (const extendedFile of extended) {\n                // Extends is relative to the file it appears in.\n                this.readFile((0, path_1.resolve)((0, path_1.dirname)(file), extendedFile), container, logger, seen);\n            }\n            delete data[\"extends\"];\n        }\n        for (const [key, val] of Object.entries(data)) {\n            try {\n                container.setValue(key, val, (0, path_1.resolve)((0, path_1.dirname)(file)));\n            }\n            catch (error) {\n                (0, assert_1.ok)(error instanceof Error);\n                logger.error(error.message);\n            }\n        }\n    }\n    /**\n     * Search for the typedoc.js or typedoc.json file from the given path\n     *\n     * @param  path Path to the typedoc.(js|json) file. If path is a directory\n     *   typedoc file will be attempted to be found at the root of this path\n     * @param logger\n     * @return the typedoc.(js|json) file path or undefined\n     */\n    findTypedocFile(path) {\n        path = (0, path_1.resolve)(path);\n        return [\n            path,\n            (0, path_1.join)(path, \"typedoc.json\"),\n            (0, path_1.join)(path, \"typedoc.js\"),\n        ].find((path) => FS.existsSync(path) && FS.statSync(path).isFile());\n    }\n}\nexports.TypeDocReader = TypeDocReader;\nfunction getStringArray(arg) {\n    return Array.isArray(arg) ? arg.map(String) : [String(arg)];\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventHooks = void 0;\nconst array_1 = require(\"./array\");\nconst momentos = new WeakMap();\n/**\n * Event emitter which allows listeners to return a value.\n *\n * This is beneficial for the themes since it allows plugins to modify the HTML output\n * without doing unsafe text replacement.\n *\n * This class is functionally nearly identical to the {@link EventEmitter} class with\n * two exceptions.\n * 1. The {@link EventEmitter} class only `await`s return values from its listeners, it\n *    does not return them to the emitter.\n * 2. This class requires listeners to by synchronous, unless `R` is specified as to be\n *    a promise or other deferred type.\n *\n * @example\n * ```ts\n * const x = new EventHooks<{ a: [string] }, string>()\n * x.on('a', a => a.repeat(123)) // ok, returns a string\n * x.on('b', console.log) // error, 'b' is not assignable to 'a'\n * x.on('a' a => 1) // error, returns a number but expected a string\n * ```\n */\nclass EventHooks {\n    constructor() {\n        // Function is *usually* not a good type to use, but here it lets us specify stricter\n        // contracts in the methods while not casting everywhere this is used.\n        this._listeners = new Map();\n    }\n    /**\n     * Starts listening to an event.\n     * @param event the event to listen to.\n     * @param listener function to be called when an this event is emitted.\n     * @param order optional order to insert this hook with.\n     */\n    on(event, listener, order = 0) {\n        const list = (this._listeners.get(event) || []).slice();\n        (0, array_1.insertOrderSorted)(list, { listener, order });\n        this._listeners.set(event, list);\n    }\n    /**\n     * Listens to a single occurrence of an event.\n     * @param event the event to listen to.\n     * @param listener function to be called when an this event is emitted.\n     * @param order optional order to insert this hook with.\n     */\n    once(event, listener, order = 0) {\n        const list = (this._listeners.get(event) || []).slice();\n        (0, array_1.insertOrderSorted)(list, { listener, once: true, order });\n        this._listeners.set(event, list);\n    }\n    /**\n     * Stops listening to an event.\n     * @param event the event to stop listening to.\n     * @param listener the function to remove from the listener array.\n     */\n    off(event, listener) {\n        const listeners = this._listeners.get(event);\n        if (listeners) {\n            const index = listeners.findIndex((lo) => lo.listener === listener);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Emits an event to all currently subscribed listeners.\n     * @param event the event to emit.\n     * @param args any arguments required for the event.\n     */\n    emit(event, ...args) {\n        var _a;\n        const listeners = ((_a = this._listeners.get(event)) === null || _a === void 0 ? void 0 : _a.slice()) || [];\n        this._listeners.set(event, listeners.filter(({ once }) => !once));\n        return listeners.map(({ listener }) => listener(...args));\n    }\n    saveMomento() {\n        const momento = {};\n        const save = new Map();\n        for (const [key, val] of this._listeners) {\n            save.set(key, [...val]);\n        }\n        momentos.set(momento, save);\n        return momento;\n    }\n    restoreMomento(momento) {\n        const saved = momentos.get(momento);\n        if (saved) {\n            this._listeners.clear();\n            for (const [key, val] of saved) {\n                this._listeners.set(key, [...val]);\n            }\n        }\n        else {\n            throw new Error(\"Momento not found.\");\n        }\n    }\n}\nexports.EventHooks = EventHooks;\n","\n/**\n * Custom JSX module designed specifically for TypeDoc's needs.\n * When overriding a default TypeDoc theme output, your implementation must create valid {@link Element}\n * instances, which can be most easily done by using TypeDoc's JSX implementation. To use it, set up\n * your tsconfig with the following compiler options:\n * ```json\n * {\n *     \"jsx\": \"react\",\n *     \"jsxFactory\": \"JSX.createElement\",\n *     \"jsxFragmentFactory\": \"JSX.Fragment\"\n * }\n * ```\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderElement = exports.createElement = exports.Raw = exports.Fragment = void 0;\nconst jsx_elements_1 = require(\"./jsx.elements\");\nvar jsx_elements_2 = require(\"./jsx.elements\");\nObject.defineProperty(exports, \"Fragment\", { enumerable: true, get: function () { return jsx_elements_2.JsxFragment; } });\n/**\n * Used to inject HTML directly into the document.\n */\nfunction Raw(_props) {\n    // This is handled specially by the renderElement function. Instead of being\n    // called, the tag is compared to this function and the `html` prop will be\n    // returned directly.\n    return null;\n}\nexports.Raw = Raw;\nfunction escapeHtml(html) {\n    return html.replace(/[&<>'\"]/g, (c) => ({\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\",\n    }[c]));\n}\nconst voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\n/**\n * JSX factory function to create an \"element\" that can later be rendered with {@link renderElement}\n * @param tag\n * @param props\n * @param children\n */\nfunction createElement(tag, props, ...children) {\n    return { tag, props, children };\n}\nexports.createElement = createElement;\nfunction renderElement(element) {\n    if (!element) {\n        return \"\";\n    }\n    const { tag, props, children } = element;\n    if (typeof tag === \"function\") {\n        if (tag === Raw) {\n            return String(props.html);\n        }\n        return renderElement(tag(Object.assign({ children }, props)));\n    }\n    const html = [];\n    if (tag !== jsx_elements_1.JsxFragment) {\n        html.push(\"<\", tag);\n        for (const [key, val] of Object.entries(props !== null && props !== void 0 ? props : {})) {\n            if (val == null)\n                continue;\n            if (typeof val == \"boolean\") {\n                if (val) {\n                    html.push(\" \", key);\n                }\n            }\n            else {\n                html.push(\" \", key, \"=\", JSON.stringify(val));\n            }\n        }\n    }\n    let hasChildren = false;\n    if (children.length) {\n        hasChildren = true;\n        if (tag !== jsx_elements_1.JsxFragment)\n            html.push(\">\");\n        renderChildren(children);\n    }\n    if (tag !== jsx_elements_1.JsxFragment) {\n        if (!hasChildren) {\n            if (voidElements.has(tag)) {\n                html.push(\"/>\");\n            }\n            else {\n                html.push(\"></\", tag, \">\");\n            }\n        }\n        else {\n            html.push(\"</\", tag, \">\");\n        }\n    }\n    return html.join(\"\");\n    function renderChildren(children) {\n        for (const child of children) {\n            if (!child)\n                continue;\n            if (Array.isArray(child)) {\n                renderChildren(child);\n            }\n            else if (typeof child === \"string\" || typeof child === \"number\") {\n                html.push(escapeHtml(child.toString()));\n            }\n            else {\n                html.push(renderElement(child));\n            }\n        }\n    }\n}\nexports.renderElement = renderElement;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsxFragment = void 0;\nexports.JsxFragment = Symbol();\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SignatureReflection = void 0;\nconst types_1 = require(\"../types\");\nconst abstract_1 = require(\"./abstract\");\nclass SignatureReflection extends abstract_1.Reflection {\n    /**\n     * Create a new SignatureReflection to contain a specific type of signature.\n     */\n    constructor(name, kind, parent) {\n        super(name, kind, parent);\n    }\n    /**\n     * Traverse all potential child reflections of this reflection.\n     *\n     * The given callback will be invoked for all children, signatures and type parameters\n     * attached to this reflection.\n     *\n     * @param callback  The callback function that should be applied for each child reflection.\n     */\n    traverse(callback) {\n        var _a, _b;\n        if (this.type instanceof types_1.ReflectionType) {\n            if (callback(this.type.declaration, abstract_1.TraverseProperty.TypeLiteral) === false) {\n                return;\n            }\n        }\n        for (const parameter of ((_a = this.typeParameters) === null || _a === void 0 ? void 0 : _a.slice()) || []) {\n            if (callback(parameter, abstract_1.TraverseProperty.TypeParameter) === false) {\n                return;\n            }\n        }\n        for (const parameter of ((_b = this.parameters) === null || _b === void 0 ? void 0 : _b.slice()) || []) {\n            if (callback(parameter, abstract_1.TraverseProperty.Parameters) === false) {\n                return;\n            }\n        }\n        super.traverse(callback);\n    }\n    /**\n     * Return a string representation of this reflection.\n     */\n    toString() {\n        let result = super.toString();\n        if (this.typeParameters) {\n            const parameters = [];\n            this.typeParameters.forEach((parameter) => parameters.push(parameter.name));\n            result += \"<\" + parameters.join(\", \") + \">\";\n        }\n        if (this.type) {\n            result += \":\" + this.type.toString();\n        }\n        return result;\n    }\n}\nexports.SignatureReflection = SignatureReflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeParameterReflection = exports.VarianceModifier = void 0;\nconst abstract_1 = require(\"./abstract\");\nconst kind_1 = require(\"./kind\");\n/**\n * Modifier flags for type parameters, added in TS 4.7\n * @enum\n */\nexports.VarianceModifier = {\n    in: \"in\",\n    out: \"out\",\n    inOut: \"in out\",\n};\nclass TypeParameterReflection extends abstract_1.Reflection {\n    constructor(name, constraint, defaultType, parent, varianceModifier) {\n        super(name, kind_1.ReflectionKind.TypeParameter, parent);\n        this.type = constraint;\n        this.default = defaultType;\n        this.varianceModifier = varianceModifier;\n    }\n}\nexports.TypeParameterReflection = TypeParameterReflection;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentTag = exports.Comment = void 0;\nvar comment_1 = require(\"./comment\");\nObject.defineProperty(exports, \"Comment\", { enumerable: true, get: function () { return comment_1.Comment; } });\nvar tag_1 = require(\"./tag\");\nObject.defineProperty(exports, \"CommentTag\", { enumerable: true, get: function () { return tag_1.CommentTag; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Comment = void 0;\nconst utils_1 = require(\"../../utils\");\nconst tag_1 = require(\"./tag\");\nconst COPIED_TAGS = [\"remarks\"];\n/**\n * A model that represents a comment.\n *\n * Instances of this model are created by the CommentPlugin. You can retrieve comments\n * through the {@link DeclarationReflection.comment} property.\n */\nclass Comment {\n    /**\n     * Creates a new Comment instance.\n     */\n    constructor(shortText, text) {\n        /**\n         * All associated tags.\n         */\n        this.tags = [];\n        this.shortText = shortText || \"\";\n        this.text = text || \"\";\n    }\n    /**\n     * Has this comment a visible component?\n     *\n     * @returns TRUE when this comment has a visible component.\n     */\n    hasVisibleComponent() {\n        return !!this.shortText || !!this.text || this.tags.length > 0;\n    }\n    /**\n     * Test whether this comment contains a tag with the given name.\n     *\n     * @param tagName  The name of the tag to look for.\n     * @returns TRUE when this comment contains a tag with the given name, otherwise FALSE.\n     */\n    hasTag(tagName) {\n        return this.tags.some((tag) => tag.tagName === tagName);\n    }\n    /**\n     * Return the first tag with the given name.\n     *\n     * You can optionally pass a parameter name that should be searched to.\n     *\n     * @param tagName  The name of the tag to look for.\n     * @param paramName  An optional parameter name to look for.\n     * @returns The found tag or undefined.\n     */\n    getTag(tagName, paramName) {\n        return this.tags.find((tag) => {\n            return (tag.tagName === tagName &&\n                (paramName === void 0 || tag.paramName === paramName));\n        });\n    }\n    /**\n     * Removes all tags with the given tag name from the comment.\n     * @param tagName\n     */\n    removeTags(tagName) {\n        (0, utils_1.removeIf)(this.tags, (tag) => tag.tagName === tagName);\n    }\n    /**\n     * Copy the data of the given comment into this comment.\n     *\n     * `shortText`, `text`, `returns` and tags from `COPIED_TAGS` are copied;\n     * other instance tags left unchanged.\n     *\n     * @param comment - Source comment to copy from\n     */\n    copyFrom(comment) {\n        this.shortText = comment.shortText;\n        this.text = comment.text;\n        this.returns = comment.returns;\n        const overrideTags = comment.tags\n            .filter((tag) => COPIED_TAGS.includes(tag.tagName))\n            .map((tag) => new tag_1.CommentTag(tag.tagName, tag.paramName, tag.text));\n        this.tags.forEach((tag, index) => {\n            const matchingTag = overrideTags.find((matchingOverride) => (matchingOverride === null || matchingOverride === void 0 ? void 0 : matchingOverride.tagName) === tag.tagName);\n            if (matchingTag) {\n                this.tags[index] = matchingTag;\n                overrideTags.splice(overrideTags.indexOf(matchingTag), 1);\n            }\n        });\n        this.tags = [...this.tags, ...overrideTags];\n    }\n}\nexports.Comment = Comment;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentTag = void 0;\n/**\n * A model that represents a single javadoc comment tag.\n *\n * Tags are stored in the {@link Comment.tags} property.\n */\nclass CommentTag {\n    /**\n     * Create a new CommentTag instance.\n     */\n    constructor(tagName, paramName, text) {\n        this.tagName = tagName;\n        this.paramName = paramName || \"\";\n        this.text = text || \"\";\n    }\n}\nexports.CommentTag = CommentTag;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionGroup = void 0;\n/**\n * A group of reflections. All reflections in a group are of the same kind.\n *\n * Reflection groups are created by the GroupHandler in the resolving phase\n * of the dispatcher. The main purpose of groups is to be able to more easily\n * render human readable children lists in templates.\n */\nclass ReflectionGroup {\n    /**\n     * Create a new ReflectionGroup instance.\n     *\n     * @param title The title of this group.\n     * @param kind  The original typescript kind of the children of this group.\n     */\n    constructor(title, kind) {\n        /**\n         * All reflections of this group.\n         */\n        this.children = [];\n        this.title = title;\n        this.kind = kind;\n    }\n    /**\n     * Do all children of this group have a separate document?\n     */\n    allChildrenHaveOwnDocument() {\n        return this.children.every((child) => child.hasOwnDocument);\n    }\n}\nexports.ReflectionGroup = ReflectionGroup;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionCategory = void 0;\n/**\n * A category of reflections.\n *\n * Reflection categories are created by the CategoryPlugin in the resolving phase\n * of the dispatcher. The main purpose of categories is to be able to more easily\n * render human readable children lists in templates.\n */\nclass ReflectionCategory {\n    /**\n     * Create a new ReflectionCategory instance.\n     *\n     * @param title The title of this category.\n     */\n    constructor(title) {\n        /**\n         * All reflections of this category.\n         */\n        this.children = [];\n        this.title = title;\n    }\n    /**\n     * Do all children of this category have a separate document?\n     */\n    allChildrenHaveOwnDocument() {\n        return this.children.every((child) => child.hasOwnDocument);\n    }\n}\nexports.ReflectionCategory = ReflectionCategory;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertExpression = exports.convertDefaultValue = exports.Converter = exports.Context = void 0;\nvar context_1 = require(\"./context\");\nObject.defineProperty(exports, \"Context\", { enumerable: true, get: function () { return context_1.Context; } });\nvar converter_1 = require(\"./converter\");\nObject.defineProperty(exports, \"Converter\", { enumerable: true, get: function () { return converter_1.Converter; } });\nvar convert_expression_1 = require(\"./convert-expression\");\nObject.defineProperty(exports, \"convertDefaultValue\", { enumerable: true, get: function () { return convert_expression_1.convertDefaultValue; } });\nObject.defineProperty(exports, \"convertExpression\", { enumerable: true, get: function () { return convert_expression_1.convertExpression; } });\nrequire(\"./plugins/index\");\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Converter_1;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Converter = void 0;\nconst ts = require(\"typescript\");\nconst index_1 = require(\"../models/index\");\nconst context_1 = require(\"./context\");\nconst components_1 = require(\"./components\");\nconst component_1 = require(\"../utils/component\");\nconst utils_1 = require(\"../utils\");\nconst types_1 = require(\"./types\");\nconst converter_events_1 = require(\"./converter-events\");\nconst symbols_1 = require(\"./symbols\");\nconst paths_1 = require(\"../utils/paths\");\nconst enum_1 = require(\"../utils/enum\");\nconst symbols_2 = require(\"./utils/symbols\");\n/**\n * Compiles source files using TypeScript and converts compiler symbols to reflections.\n */\nlet Converter = Converter_1 = class Converter extends component_1.ChildableComponent {\n    /**\n     * Compile the given source files and create a project reflection for them.\n     */\n    convert(entryPoints) {\n        const programs = entryPoints.map((e) => e.program);\n        this.externalPatternCache = void 0;\n        const project = new index_1.ProjectReflection(this.name);\n        const context = new context_1.Context(this, programs, project);\n        this.trigger(Converter_1.EVENT_BEGIN, context);\n        this.compile(entryPoints, context);\n        this.resolve(context);\n        // This should only do anything if a plugin does something bad.\n        project.removeDanglingReferences();\n        this.trigger(Converter_1.EVENT_END, context);\n        return project;\n    }\n    /** @internal */\n    convertSymbol(context, symbol) {\n        (0, symbols_1.convertSymbol)(context, symbol);\n    }\n    /**\n     * Convert the given TypeScript type into its TypeDoc type reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param referenceTarget The target to be used to attempt to resolve reference types\n     * @returns The TypeDoc type reflection representing the given node and type.\n     * @internal\n     */\n    convertType(context, node) {\n        return (0, types_1.convertType)(context, node);\n    }\n    /** @internal */\n    getNodesForSymbol(symbol, kind) {\n        var _a;\n        const wantedKinds = {\n            [index_1.ReflectionKind.Project]: [ts.SyntaxKind.SourceFile],\n            [index_1.ReflectionKind.Module]: [ts.SyntaxKind.SourceFile],\n            [index_1.ReflectionKind.Namespace]: [\n                ts.SyntaxKind.ModuleDeclaration,\n                ts.SyntaxKind.SourceFile,\n            ],\n            [index_1.ReflectionKind.Enum]: [\n                ts.SyntaxKind.EnumDeclaration,\n                ts.SyntaxKind.VariableDeclaration,\n            ],\n            [index_1.ReflectionKind.EnumMember]: [\n                ts.SyntaxKind.EnumMember,\n                ts.SyntaxKind.PropertyAssignment,\n                ts.SyntaxKind.PropertySignature,\n            ],\n            [index_1.ReflectionKind.Variable]: [\n                ts.SyntaxKind.VariableDeclaration,\n                ts.SyntaxKind.ExportAssignment,\n            ],\n            [index_1.ReflectionKind.Function]: [\n                ts.SyntaxKind.FunctionDeclaration,\n                ts.SyntaxKind.VariableDeclaration,\n            ],\n            [index_1.ReflectionKind.Class]: [ts.SyntaxKind.ClassDeclaration],\n            [index_1.ReflectionKind.Interface]: [\n                ts.SyntaxKind.InterfaceDeclaration,\n                ts.SyntaxKind.JSDocTypedefTag,\n            ],\n            [index_1.ReflectionKind.Constructor]: [ts.SyntaxKind.Constructor],\n            [index_1.ReflectionKind.Property]: [\n                ts.SyntaxKind.PropertyDeclaration,\n                ts.SyntaxKind.PropertyAssignment,\n                ts.SyntaxKind.PropertySignature,\n                ts.SyntaxKind.JSDocPropertyTag,\n                ts.SyntaxKind.BinaryExpression,\n            ],\n            [index_1.ReflectionKind.Method]: [\n                ts.SyntaxKind.MethodDeclaration,\n                ts.SyntaxKind.PropertyDeclaration,\n                ts.SyntaxKind.PropertySignature,\n            ],\n            [index_1.ReflectionKind.CallSignature]: [\n                ts.SyntaxKind.FunctionDeclaration,\n                ts.SyntaxKind.VariableDeclaration,\n                ts.SyntaxKind.MethodDeclaration,\n                ts.SyntaxKind.MethodDeclaration,\n                ts.SyntaxKind.PropertyDeclaration,\n                ts.SyntaxKind.PropertySignature,\n                ts.SyntaxKind.CallSignature,\n            ],\n            [index_1.ReflectionKind.IndexSignature]: [ts.SyntaxKind.IndexSignature],\n            [index_1.ReflectionKind.ConstructorSignature]: [\n                ts.SyntaxKind.ConstructSignature,\n            ],\n            [index_1.ReflectionKind.Parameter]: [ts.SyntaxKind.Parameter],\n            [index_1.ReflectionKind.TypeLiteral]: [ts.SyntaxKind.TypeLiteral],\n            [index_1.ReflectionKind.TypeParameter]: [ts.SyntaxKind.TypeParameter],\n            [index_1.ReflectionKind.Accessor]: [\n                ts.SyntaxKind.GetAccessor,\n                ts.SyntaxKind.SetAccessor,\n            ],\n            [index_1.ReflectionKind.GetSignature]: [ts.SyntaxKind.GetAccessor],\n            [index_1.ReflectionKind.SetSignature]: [ts.SyntaxKind.SetAccessor],\n            [index_1.ReflectionKind.ObjectLiteral]: [\n                ts.SyntaxKind.ObjectLiteralExpression,\n            ],\n            [index_1.ReflectionKind.TypeAlias]: [\n                ts.SyntaxKind.TypeAliasDeclaration,\n                ts.SyntaxKind.JSDocTypedefTag,\n            ],\n            [index_1.ReflectionKind.Event]: [],\n            [index_1.ReflectionKind.Reference]: [\n                ts.SyntaxKind.NamespaceExport,\n                ts.SyntaxKind.ExportSpecifier,\n            ],\n        }[kind];\n        const declarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n        return declarations.filter((d) => wantedKinds.includes(d.kind));\n    }\n    /**\n     * Compile the files within the given context and convert the compiler symbols to reflections.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns An array containing all errors generated by the TypeScript compiler.\n     */\n    compile(entryPoints, context) {\n        const entries = entryPoints.map((e) => {\n            return {\n                entryPoint: e,\n                context: undefined,\n            };\n        });\n        entries.forEach((e) => {\n            context.setActiveProgram(e.entryPoint.program);\n            e.context = this.convertExports(context, e.entryPoint.sourceFile, entries.length === 1, e.entryPoint.displayName);\n        });\n        for (const { entryPoint, context } of entries) {\n            // active program is already set on context\n            // if we don't have a context, then this entry point is being ignored\n            if (context) {\n                this.convertReExports(context, entryPoint.sourceFile);\n            }\n        }\n        context.setActiveProgram(undefined);\n    }\n    convertExports(context, node, singleEntryPoint, entryName) {\n        const symbol = getSymbolForModuleLike(context, node);\n        let moduleContext;\n        const allExports = getExports(context, node, symbol);\n        if (allExports.every((exp) => this.shouldIgnore(exp, context.checker))) {\n            this.owner.logger.verbose(`Ignoring entry point ${entryName} since all members will be ignored.`);\n            return;\n        }\n        if (singleEntryPoint) {\n            // Special case for when we're giving a single entry point, we don't need to\n            // create modules for each entry. Register the project as this module.\n            context.project.registerReflection(context.project, symbol);\n            context.trigger(Converter_1.EVENT_CREATE_DECLARATION, context.project, node);\n            moduleContext = context;\n        }\n        else {\n            const reflection = context.createDeclarationReflection(index_1.ReflectionKind.Module, symbol, void 0, entryName);\n            context.finalizeDeclarationReflection(reflection, symbol, void 0, node);\n            moduleContext = context.withScope(reflection);\n        }\n        for (const exp of allExports.filter((exp) => isDirectExport(context.resolveAliasedSymbol(exp), node))) {\n            (0, symbols_1.convertSymbol)(moduleContext, exp);\n        }\n        return moduleContext;\n    }\n    convertReExports(moduleContext, node) {\n        for (const exp of getExports(moduleContext, node, moduleContext.project.getSymbolFromReflection(moduleContext.scope)).filter((exp) => !isDirectExport(moduleContext.resolveAliasedSymbol(exp), node))) {\n            (0, symbols_1.convertSymbol)(moduleContext, exp);\n        }\n    }\n    /**\n     * Resolve the project within the given context.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @returns The final project reflection.\n     */\n    resolve(context) {\n        this.trigger(Converter_1.EVENT_RESOLVE_BEGIN, context);\n        const project = context.project;\n        for (const reflection of Object.values(project.reflections)) {\n            this.trigger(Converter_1.EVENT_RESOLVE, context, reflection);\n        }\n        this.trigger(Converter_1.EVENT_RESOLVE_END, context);\n    }\n    /** @internal */\n    shouldIgnore(symbol, checker) {\n        if (this.excludeNotDocumented &&\n            // If the enum is included, we should include members even if not documented.\n            !(0, enum_1.hasAllFlags)(symbol.flags, ts.SymbolFlags.EnumMember) &&\n            (0, symbols_2.resolveAliasedSymbol)(symbol, checker).getDocumentationComment(checker).length === 0) {\n            return true;\n        }\n        if (this.isExcluded(symbol)) {\n            return true;\n        }\n        if (!this.excludeExternals) {\n            return false;\n        }\n        return this.isExternal(symbol);\n    }\n    isExcluded(symbol) {\n        var _a, _b;\n        (_a = this.excludeCache) !== null && _a !== void 0 ? _a : (this.excludeCache = (0, paths_1.createMinimatch)(this.application.options.getValue(\"exclude\")));\n        for (const node of (_b = symbol.getDeclarations()) !== null && _b !== void 0 ? _b : []) {\n            if ((0, paths_1.matchesAny)(this.excludeCache, node.getSourceFile().fileName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /** @internal */\n    isExternal(symbol) {\n        var _a, _b;\n        (_a = this.externalPatternCache) !== null && _a !== void 0 ? _a : (this.externalPatternCache = (0, paths_1.createMinimatch)(this.externalPattern));\n        for (const node of (_b = symbol.getDeclarations()) !== null && _b !== void 0 ? _b : []) {\n            if ((0, paths_1.matchesAny)(this.externalPatternCache, node.getSourceFile().fileName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n/**\n * General events\n */\n/**\n * Triggered when the converter begins converting a project.\n * The listener will be given a {@link Context} object.\n * @event\n */\nConverter.EVENT_BEGIN = converter_events_1.ConverterEvents.BEGIN;\n/**\n * Triggered when the converter has finished converting a project.\n * The listener will be given a {@link Context} object.\n * @event\n */\nConverter.EVENT_END = converter_events_1.ConverterEvents.END;\n/**\n * Factory events\n */\n/**\n * Triggered when the converter has created a declaration reflection.\n * The listener will be given {@link Context}, {@link Reflection} and a `ts.Node?`.\n * @event\n */\nConverter.EVENT_CREATE_DECLARATION = converter_events_1.ConverterEvents.CREATE_DECLARATION;\n/**\n * Triggered when the converter has created a signature reflection.\n * The listener will be given {@link Context}, {@link SignatureReflection} and a `ts.Node?`\n * @event\n */\nConverter.EVENT_CREATE_SIGNATURE = converter_events_1.ConverterEvents.CREATE_SIGNATURE;\n/**\n * Triggered when the converter has created a parameter reflection.\n * The listener will be given {@link Context}, {@link ParameterReflection} and a `ts.Node?`\n * @event\n */\nConverter.EVENT_CREATE_PARAMETER = converter_events_1.ConverterEvents.CREATE_PARAMETER;\n/**\n * Triggered when the converter has created a type parameter reflection.\n * The listener will be given {@link Context}, {@link TypeParameterReflection} and a `ts.Node?`\n * @event\n */\nConverter.EVENT_CREATE_TYPE_PARAMETER = converter_events_1.ConverterEvents.CREATE_TYPE_PARAMETER;\n/**\n * Resolve events\n */\n/**\n * Triggered when the converter begins resolving a project.\n * The listener will be given {@link Context}.\n * @event\n */\nConverter.EVENT_RESOLVE_BEGIN = converter_events_1.ConverterEvents.RESOLVE_BEGIN;\n/**\n * Triggered when the converter resolves a reflection.\n * The listener will be given {@link Context} and a {@link Reflection}.\n * @event\n */\nConverter.EVENT_RESOLVE = converter_events_1.ConverterEvents.RESOLVE;\n/**\n * Triggered when the converter has finished resolving a project.\n * The listener will be given {@link Context}.\n * @event\n */\nConverter.EVENT_RESOLVE_END = converter_events_1.ConverterEvents.RESOLVE_END;\n__decorate([\n    (0, utils_1.BindOption)(\"name\")\n], Converter.prototype, \"name\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"externalPattern\")\n], Converter.prototype, \"externalPattern\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"excludeExternals\")\n], Converter.prototype, \"excludeExternals\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"excludeNotDocumented\")\n], Converter.prototype, \"excludeNotDocumented\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"excludePrivate\")\n], Converter.prototype, \"excludePrivate\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"excludeProtected\")\n], Converter.prototype, \"excludeProtected\", void 0);\nConverter = Converter_1 = __decorate([\n    (0, component_1.Component)({\n        name: \"converter\",\n        internal: true,\n        childClass: components_1.ConverterComponent,\n    })\n], Converter);\nexports.Converter = Converter;\nfunction getSymbolForModuleLike(context, node) {\n    var _a, _b;\n    const symbol = (_a = context.checker.getSymbolAtLocation(node)) !== null && _a !== void 0 ? _a : node.symbol;\n    if (symbol) {\n        return symbol;\n    }\n    // This is a global file, get all symbols declared in this file...\n    // this isn't the best solution, it would be nice to have all globals given to a special\n    // \"globals\" file, but this is uncommon enough that I'm skipping it for now.\n    const sourceFile = node.getSourceFile();\n    const globalSymbols = context.checker\n        .getSymbolsInScope(node, ts.SymbolFlags.ModuleMember)\n        .filter((s) => { var _a; return (_a = s.getDeclarations()) === null || _a === void 0 ? void 0 : _a.some((d) => d.getSourceFile() === sourceFile); });\n    // Detect declaration files with declare module \"foo\" as their only export\n    // and lift that up one level as the source file symbol\n    if (globalSymbols.length === 1 &&\n        ((_b = globalSymbols[0]\n            .getDeclarations()) === null || _b === void 0 ? void 0 : _b.every((declaration) => ts.isModuleDeclaration(declaration) &&\n            ts.isStringLiteral(declaration.name)))) {\n        return globalSymbols[0];\n    }\n}\nfunction getExports(context, node, symbol) {\n    var _a;\n    let result;\n    // The generated docs aren't great, but you really ought not be using\n    // this in the first place... so it's better than nothing.\n    const exportEq = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.exports) === null || _a === void 0 ? void 0 : _a.get(\"export=\");\n    if (exportEq) {\n        // JS users might also have exported types here.\n        // We need to filter for types because otherwise static methods can show up as both\n        // members of the export= class and as functions if a class is directly exported.\n        result = [exportEq].concat(context.checker\n            .getExportsOfModule(symbol)\n            .filter((s) => !(0, enum_1.hasAnyFlag)(s.flags, ts.SymbolFlags.Prototype | ts.SymbolFlags.Value)));\n    }\n    else if (symbol) {\n        result = context.checker\n            .getExportsOfModule(symbol)\n            .filter((s) => !(0, enum_1.hasAllFlags)(s.flags, ts.SymbolFlags.Prototype));\n        if (result.length === 0) {\n            const globalDecl = node.statements.find((s) => ts.isModuleDeclaration(s) &&\n                s.flags & ts.NodeFlags.GlobalAugmentation);\n            if (globalDecl) {\n                const globalSymbol = context.getSymbolAtLocation(globalDecl);\n                if (globalSymbol) {\n                    result = context.checker\n                        .getExportsOfModule(globalSymbol)\n                        .filter((exp) => {\n                        var _a;\n                        return (_a = exp.declarations) === null || _a === void 0 ? void 0 : _a.some((d) => d.getSourceFile() === node);\n                    });\n                }\n            }\n        }\n    }\n    else {\n        // Global file with no inferred top level symbol, get all symbols declared in this file.\n        const sourceFile = node.getSourceFile();\n        result = context.checker\n            .getSymbolsInScope(node, ts.SymbolFlags.ModuleMember)\n            .filter((s) => {\n            var _a;\n            return (_a = s\n                .getDeclarations()) === null || _a === void 0 ? void 0 : _a.some((d) => d.getSourceFile() === sourceFile);\n        });\n    }\n    // Put symbols named \"default\" last, #1795\n    result.sort((a, b) => {\n        if (a.name === \"default\") {\n            return 1;\n        }\n        else if (b.name === \"default\") {\n            return -1;\n        }\n        return 0;\n    });\n    return result;\n}\nfunction isDirectExport(symbol, file) {\n    var _a, _b;\n    return ((_b = (_a = symbol\n        .getDeclarations()) === null || _a === void 0 ? void 0 : _a.every((decl) => decl.getSourceFile() === file)) !== null && _b !== void 0 ? _b : false);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConverterComponent = exports.Component = void 0;\nconst component_1 = require(\"../utils/component\");\nObject.defineProperty(exports, \"Component\", { enumerable: true, get: function () { return component_1.Component; } });\nclass ConverterComponent extends component_1.AbstractComponent {\n}\nexports.ConverterComponent = ConverterComponent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertType = exports.loadConverters = void 0;\nconst assert = require(\"assert\");\nconst ts = require(\"typescript\");\nconst models_1 = require(\"../models\");\nconst array_1 = require(\"../utils/array\");\nconst converter_events_1 = require(\"./converter-events\");\nconst index_signature_1 = require(\"./factories/index-signature\");\nconst signature_1 = require(\"./factories/signature\");\nconst symbols_1 = require(\"./symbols\");\nconst reflections_1 = require(\"./utils/reflections\");\nconst converters = new Map();\nfunction loadConverters() {\n    if (converters.size)\n        return;\n    for (const actor of [\n        arrayConverter,\n        conditionalConverter,\n        constructorConverter,\n        exprWithTypeArgsConverter,\n        functionTypeConverter,\n        importType,\n        indexedAccessConverter,\n        inferredConverter,\n        intersectionConverter,\n        jsDocVariadicTypeConverter,\n        keywordConverter,\n        optionalConverter,\n        parensConverter,\n        predicateConverter,\n        queryConverter,\n        typeLiteralConverter,\n        referenceConverter,\n        restConverter,\n        namedTupleMemberConverter,\n        mappedConverter,\n        literalTypeConverter,\n        templateLiteralConverter,\n        thisConverter,\n        tupleConverter,\n        typeOperatorConverter,\n        unionConverter,\n        // Only used if skipLibCheck: true\n        jsDocNullableTypeConverter,\n        jsDocNonNullableTypeConverter,\n    ]) {\n        for (const key of actor.kind) {\n            if (key === undefined) {\n                // Might happen if running on an older TS version.\n                continue;\n            }\n            assert(!converters.has(key));\n            converters.set(key, actor);\n        }\n    }\n}\nexports.loadConverters = loadConverters;\n// This ought not be necessary, but we need some way to discover recursively\n// typed symbols which do not have type nodes. See the `recursive` symbol in the variables test.\nconst seenTypeSymbols = new Set();\nfunction maybeConvertType(context, typeOrNode) {\n    if (!typeOrNode) {\n        return;\n    }\n    return convertType(context, typeOrNode);\n}\nfunction convertType(context, typeOrNode) {\n    if (!typeOrNode) {\n        return new models_1.IntrinsicType(\"any\");\n    }\n    loadConverters();\n    if (\"kind\" in typeOrNode) {\n        const converter = converters.get(typeOrNode.kind);\n        if (converter) {\n            return converter.convert(context, typeOrNode);\n        }\n        return requestBugReport(context, typeOrNode);\n    }\n    // IgnoreErrors is important, without it, we can't assert that we will get a node.\n    const node = context.checker.typeToTypeNode(typeOrNode, void 0, ts.NodeBuilderFlags.IgnoreErrors);\n    assert(node); // According to the TS source of typeToString, this is a bug if it does not hold.\n    const symbol = typeOrNode.getSymbol();\n    if (symbol) {\n        if (node.kind !== ts.SyntaxKind.TypeReference &&\n            node.kind !== ts.SyntaxKind.ArrayType &&\n            seenTypeSymbols.has(symbol)) {\n            const typeString = context.checker.typeToString(typeOrNode);\n            context.logger.verbose(`Refusing to recurse when converting type: ${typeString}`);\n            return new models_1.UnknownType(typeString);\n        }\n        seenTypeSymbols.add(symbol);\n    }\n    const converter = converters.get(node.kind);\n    if (converter) {\n        const result = converter.convertType(context, typeOrNode, node);\n        if (symbol)\n            seenTypeSymbols.delete(symbol);\n        return result;\n    }\n    return requestBugReport(context, typeOrNode);\n}\nexports.convertType = convertType;\nconst arrayConverter = {\n    kind: [ts.SyntaxKind.ArrayType],\n    convert(context, node) {\n        return new models_1.ArrayType(convertType(context, node.elementType));\n    },\n    convertType(context, type) {\n        const params = context.checker.getTypeArguments(type);\n        // This is *almost* always true... except for when this type is in the constraint of a type parameter see GH#1408\n        // assert(params.length === 1);\n        assert(params.length > 0);\n        return new models_1.ArrayType(convertType(context, params[0]));\n    },\n};\nconst conditionalConverter = {\n    kind: [ts.SyntaxKind.ConditionalType],\n    convert(context, node) {\n        return new models_1.ConditionalType(convertType(context, node.checkType), convertType(context, node.extendsType), convertType(context, node.trueType), convertType(context, node.falseType));\n    },\n    convertType(context, type) {\n        return new models_1.ConditionalType(convertType(context, type.checkType), convertType(context, type.extendsType), convertType(context, type.resolvedTrueType), convertType(context, type.resolvedFalseType));\n    },\n};\nconst constructorConverter = {\n    kind: [ts.SyntaxKind.ConstructorType],\n    convert(context, node) {\n        var _a, _b;\n        const symbol = (_a = context.getSymbolAtLocation(node)) !== null && _a !== void 0 ? _a : node.symbol;\n        const type = context.getTypeAtLocation(node);\n        if (!symbol || !type) {\n            return new models_1.IntrinsicType(\"Function\");\n        }\n        const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.Constructor, context.scope);\n        const rc = context.withScope(reflection);\n        rc.setConvertingTypeNode();\n        context.registerReflection(reflection, symbol);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection, node);\n        const signature = new models_1.SignatureReflection(\"__type\", models_1.ReflectionKind.ConstructorSignature, reflection);\n        // This is unfortunate... but seems the obvious place to put this with the current\n        // architecture. Ideally, this would be a property on a \"ConstructorType\"... but that\n        // needs to wait until TypeDoc 0.22 when making other breaking changes.\n        if ((_b = node.modifiers) === null || _b === void 0 ? void 0 : _b.some((m) => m.kind === ts.SyntaxKind.AbstractKeyword)) {\n            signature.setFlag(models_1.ReflectionFlag.Abstract);\n        }\n        context.registerReflection(signature, void 0);\n        const signatureCtx = rc.withScope(signature);\n        reflection.signatures = [signature];\n        signature.type = convertType(signatureCtx, node.type);\n        signature.parameters = (0, signature_1.convertParameterNodes)(signatureCtx, signature, node.parameters);\n        signature.typeParameters = (0, signature_1.convertTypeParameterNodes)(signatureCtx, node.typeParameters);\n        return new models_1.ReflectionType(reflection);\n    },\n    convertType(context, type) {\n        if (!type.symbol) {\n            return new models_1.IntrinsicType(\"Function\");\n        }\n        const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.Constructor, context.scope);\n        context.registerReflection(reflection, type.symbol);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection);\n        (0, signature_1.createSignature)(context.withScope(reflection), models_1.ReflectionKind.ConstructorSignature, type.getConstructSignatures()[0]);\n        return new models_1.ReflectionType(reflection);\n    },\n};\nconst exprWithTypeArgsConverter = {\n    kind: [ts.SyntaxKind.ExpressionWithTypeArguments],\n    convert(context, node) {\n        var _a, _b;\n        const targetSymbol = context.getSymbolAtLocation(node.expression);\n        // Mixins... we might not have a symbol here.\n        if (!targetSymbol) {\n            return convertType(context, context.checker.getTypeAtLocation(node));\n        }\n        const parameters = (_b = (_a = node.typeArguments) === null || _a === void 0 ? void 0 : _a.map((type) => convertType(context, type))) !== null && _b !== void 0 ? _b : [];\n        const ref = models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(targetSymbol), context);\n        ref.typeArguments = parameters;\n        return ref;\n    },\n    convertType: requestBugReport,\n};\nconst functionTypeConverter = {\n    kind: [ts.SyntaxKind.FunctionType],\n    convert(context, node) {\n        var _a;\n        const symbol = (_a = context.getSymbolAtLocation(node)) !== null && _a !== void 0 ? _a : node.symbol;\n        const type = context.getTypeAtLocation(node);\n        if (!symbol || !type) {\n            return new models_1.IntrinsicType(\"Function\");\n        }\n        const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.TypeLiteral, context.scope);\n        const rc = context.withScope(reflection);\n        context.registerReflection(reflection, symbol);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection, node);\n        const signature = new models_1.SignatureReflection(\"__type\", models_1.ReflectionKind.CallSignature, reflection);\n        context.registerReflection(signature, void 0);\n        const signatureCtx = rc.withScope(signature);\n        reflection.signatures = [signature];\n        signature.type = convertType(signatureCtx, node.type);\n        signature.parameters = (0, signature_1.convertParameterNodes)(signatureCtx, signature, node.parameters);\n        signature.typeParameters = (0, signature_1.convertTypeParameterNodes)(signatureCtx, node.typeParameters);\n        return new models_1.ReflectionType(reflection);\n    },\n    convertType(context, type) {\n        if (!type.symbol) {\n            return new models_1.IntrinsicType(\"Function\");\n        }\n        const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.TypeLiteral, context.scope);\n        context.registerReflection(reflection, type.symbol);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection);\n        (0, signature_1.createSignature)(context.withScope(reflection), models_1.ReflectionKind.CallSignature, type.getCallSignatures()[0]);\n        return new models_1.ReflectionType(reflection);\n    },\n};\nconst importType = {\n    kind: [ts.SyntaxKind.ImportType],\n    convert(context, node) {\n        var _a, _b;\n        const name = (_b = (_a = node.qualifier) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : \"__module\";\n        const symbol = context.checker.getSymbolAtLocation(node);\n        assert(symbol, \"Missing symbol when converting import type node\");\n        return models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(symbol), context, name);\n    },\n    convertType(context, type) {\n        const symbol = type.getSymbol();\n        assert(symbol, \"Missing symbol when converting import type\"); // Should be a compiler error\n        return models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(symbol), context, \"__module\");\n    },\n};\nconst indexedAccessConverter = {\n    kind: [ts.SyntaxKind.IndexedAccessType],\n    convert(context, node) {\n        return new models_1.IndexedAccessType(convertType(context, node.objectType), convertType(context, node.indexType));\n    },\n    convertType(context, type) {\n        return new models_1.IndexedAccessType(convertType(context, type.objectType), convertType(context, type.indexType));\n    },\n};\nconst inferredConverter = {\n    kind: [ts.SyntaxKind.InferType],\n    convert(context, node) {\n        return new models_1.InferredType(node.typeParameter.name.text, maybeConvertType(context, node.typeParameter.constraint));\n    },\n    convertType(context, type) {\n        return new models_1.InferredType(type.symbol.name, maybeConvertType(context, type.getConstraint()));\n    },\n};\nconst intersectionConverter = {\n    kind: [ts.SyntaxKind.IntersectionType],\n    convert(context, node) {\n        return new models_1.IntersectionType(node.types.map((type) => convertType(context, type)));\n    },\n    convertType(context, type) {\n        return new models_1.IntersectionType(type.types.map((type) => convertType(context, type)));\n    },\n};\nconst jsDocVariadicTypeConverter = {\n    kind: [ts.SyntaxKind.JSDocVariadicType],\n    convert(context, node) {\n        return new models_1.ArrayType(convertType(context, node.type));\n    },\n    // Should just be an ArrayType\n    convertType: requestBugReport,\n};\nconst keywordNames = {\n    [ts.SyntaxKind.AnyKeyword]: \"any\",\n    [ts.SyntaxKind.BigIntKeyword]: \"bigint\",\n    [ts.SyntaxKind.BooleanKeyword]: \"boolean\",\n    [ts.SyntaxKind.NeverKeyword]: \"never\",\n    [ts.SyntaxKind.NumberKeyword]: \"number\",\n    [ts.SyntaxKind.ObjectKeyword]: \"object\",\n    [ts.SyntaxKind.StringKeyword]: \"string\",\n    [ts.SyntaxKind.SymbolKeyword]: \"symbol\",\n    [ts.SyntaxKind.UndefinedKeyword]: \"undefined\",\n    [ts.SyntaxKind.UnknownKeyword]: \"unknown\",\n    [ts.SyntaxKind.VoidKeyword]: \"void\",\n    [ts.SyntaxKind.IntrinsicKeyword]: \"intrinsic\",\n};\nconst keywordConverter = {\n    kind: [\n        ts.SyntaxKind.AnyKeyword,\n        ts.SyntaxKind.BigIntKeyword,\n        ts.SyntaxKind.BooleanKeyword,\n        ts.SyntaxKind.NeverKeyword,\n        ts.SyntaxKind.NumberKeyword,\n        ts.SyntaxKind.ObjectKeyword,\n        ts.SyntaxKind.StringKeyword,\n        ts.SyntaxKind.SymbolKeyword,\n        ts.SyntaxKind.UndefinedKeyword,\n        ts.SyntaxKind.UnknownKeyword,\n        ts.SyntaxKind.VoidKeyword,\n    ],\n    convert(_context, node) {\n        return new models_1.IntrinsicType(keywordNames[node.kind]);\n    },\n    convertType(_context, _type, node) {\n        return new models_1.IntrinsicType(keywordNames[node.kind]);\n    },\n};\nconst optionalConverter = {\n    kind: [ts.SyntaxKind.OptionalType],\n    convert(context, node) {\n        return new models_1.OptionalType((0, reflections_1.removeUndefined)(convertType(context, node.type)));\n    },\n    // Handled by the tuple converter\n    convertType: requestBugReport,\n};\nconst parensConverter = {\n    kind: [ts.SyntaxKind.ParenthesizedType],\n    convert(context, node) {\n        return convertType(context, node.type);\n    },\n    // TS strips these out too... shouldn't run into this.\n    convertType: requestBugReport,\n};\nconst predicateConverter = {\n    kind: [ts.SyntaxKind.TypePredicate],\n    convert(context, node) {\n        const name = ts.isThisTypeNode(node.parameterName)\n            ? \"this\"\n            : node.parameterName.getText();\n        const asserts = !!node.assertsModifier;\n        const targetType = node.type ? convertType(context, node.type) : void 0;\n        return new models_1.PredicateType(name, asserts, targetType);\n    },\n    // Never inferred by TS 4.0, could potentially change in a future TS version.\n    convertType: requestBugReport,\n};\n// This is a horrible thing... we're going to want to split this into converters\n// for different types at some point.\nconst typeLiteralConverter = {\n    kind: [ts.SyntaxKind.TypeLiteral],\n    convert(context, node) {\n        var _a;\n        const symbol = (_a = context.getSymbolAtLocation(node)) !== null && _a !== void 0 ? _a : node.symbol;\n        const type = context.getTypeAtLocation(node);\n        if (!symbol || !type) {\n            return new models_1.IntrinsicType(\"Object\");\n        }\n        const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.TypeLiteral, context.scope);\n        const rc = context.withScope(reflection);\n        rc.setConvertingTypeNode();\n        context.registerReflection(reflection, symbol);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection, node);\n        for (const prop of context.checker.getPropertiesOfType(type)) {\n            (0, symbols_1.convertSymbol)(rc, prop);\n        }\n        for (const signature of type.getCallSignatures()) {\n            (0, signature_1.createSignature)(rc, models_1.ReflectionKind.CallSignature, signature);\n        }\n        (0, index_signature_1.convertIndexSignature)(rc, symbol);\n        return new models_1.ReflectionType(reflection);\n    },\n    convertType(context, type) {\n        if (!type.symbol) {\n            return new models_1.IntrinsicType(\"Object\");\n        }\n        const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.TypeLiteral, context.scope);\n        context.registerReflection(reflection, type.symbol);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection);\n        for (const prop of context.checker.getPropertiesOfType(type)) {\n            (0, symbols_1.convertSymbol)(context.withScope(reflection), prop);\n        }\n        for (const signature of type.getCallSignatures()) {\n            (0, signature_1.createSignature)(context.withScope(reflection), models_1.ReflectionKind.CallSignature, signature);\n        }\n        (0, index_signature_1.convertIndexSignature)(context.withScope(reflection), type.symbol);\n        return new models_1.ReflectionType(reflection);\n    },\n};\nconst queryConverter = {\n    kind: [ts.SyntaxKind.TypeQuery],\n    convert(context, node) {\n        const querySymbol = context.getSymbolAtLocation(node.exprName);\n        if (!querySymbol) {\n            // This can happen if someone uses `typeof` on some property\n            // on a variable typed as `any` with a name that doesn't exist.\n            return new models_1.QueryType(models_1.ReferenceType.createBrokenReference(node.exprName.getText(), context.project));\n        }\n        return new models_1.QueryType(models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(querySymbol), context, node.exprName.getText()));\n    },\n    convertType(context, type) {\n        const symbol = type.getSymbol();\n        assert(symbol, `Query type failed to get a symbol for: ${context.checker.typeToString(type)}. This is a bug.`);\n        return new models_1.QueryType(models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(symbol), context));\n    },\n};\nconst referenceConverter = {\n    kind: [ts.SyntaxKind.TypeReference],\n    convert(context, node) {\n        var _a, _b, _c;\n        const isArray = ((_a = context.checker.typeToTypeNode(context.checker.getTypeAtLocation(node.typeName), void 0, ts.NodeBuilderFlags.IgnoreErrors)) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.ArrayType;\n        if (isArray) {\n            return new models_1.ArrayType(convertType(context, (_b = node.typeArguments) === null || _b === void 0 ? void 0 : _b[0]));\n        }\n        const symbol = context.expectSymbolAtLocation(node.typeName);\n        const name = node.typeName.getText();\n        const type = models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(symbol), context, name);\n        type.typeArguments = (_c = node.typeArguments) === null || _c === void 0 ? void 0 : _c.map((type) => convertType(context, type));\n        return type;\n    },\n    convertType(context, type) {\n        var _a, _b;\n        const symbol = (_a = type.aliasSymbol) !== null && _a !== void 0 ? _a : type.getSymbol();\n        if (!symbol) {\n            // This happens when we get a reference to a type parameter\n            // created within a mapped type, `K` in: `{ [K in T]: string }`\n            return models_1.ReferenceType.createBrokenReference(context.checker.typeToString(type), context.project);\n        }\n        const ref = models_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(symbol), context);\n        ref.typeArguments = (_b = (type.aliasSymbol ? type.aliasTypeArguments : type.typeArguments)) === null || _b === void 0 ? void 0 : _b.map((ref) => convertType(context, ref));\n        return ref;\n    },\n};\nconst restConverter = {\n    kind: [ts.SyntaxKind.RestType],\n    convert(context, node) {\n        return new models_1.RestType(convertType(context, node.type));\n    },\n    // This is handled in the tuple converter\n    convertType: requestBugReport,\n};\nconst namedTupleMemberConverter = {\n    kind: [ts.SyntaxKind.NamedTupleMember],\n    convert(context, node) {\n        const innerType = convertType(context, node.type);\n        return new models_1.NamedTupleMember(node.name.getText(), !!node.questionToken, innerType);\n    },\n    // This ought to be impossible.\n    convertType: requestBugReport,\n};\n// { -readonly [K in string]-?: number}\n//   ^ readonlyToken\n//              ^ typeParameter\n//                   ^^^^^^ typeParameter.constraint\n//                          ^ questionToken\n//                              ^^^^^^ type\nconst mappedConverter = {\n    kind: [ts.SyntaxKind.MappedType],\n    convert(context, node) {\n        var _a, _b;\n        const optionalModifier = kindToModifier((_a = node.questionToken) === null || _a === void 0 ? void 0 : _a.kind);\n        const templateType = convertType(context, node.type);\n        return new models_1.MappedType(node.typeParameter.name.text, convertType(context, node.typeParameter.constraint), optionalModifier === \"+\"\n            ? (0, reflections_1.removeUndefined)(templateType)\n            : templateType, kindToModifier((_b = node.readonlyToken) === null || _b === void 0 ? void 0 : _b.kind), optionalModifier, node.nameType ? convertType(context, node.nameType) : void 0);\n    },\n    convertType(context, type, node) {\n        var _a, _b, _c;\n        // This can happen if a generic function does not have a return type annotated.\n        const optionalModifier = kindToModifier((_a = node.questionToken) === null || _a === void 0 ? void 0 : _a.kind);\n        const templateType = convertType(context, type.templateType);\n        return new models_1.MappedType((_b = type.typeParameter.symbol) === null || _b === void 0 ? void 0 : _b.name, convertType(context, type.typeParameter.getConstraint()), optionalModifier === \"+\"\n            ? (0, reflections_1.removeUndefined)(templateType)\n            : templateType, kindToModifier((_c = node.readonlyToken) === null || _c === void 0 ? void 0 : _c.kind), optionalModifier, type.nameType ? convertType(context, type.nameType) : void 0);\n    },\n};\nconst literalTypeConverter = {\n    kind: [ts.SyntaxKind.LiteralType],\n    convert(context, node) {\n        switch (node.literal.kind) {\n            case ts.SyntaxKind.TrueKeyword:\n            case ts.SyntaxKind.FalseKeyword:\n                return new models_1.LiteralType(node.literal.kind === ts.SyntaxKind.TrueKeyword);\n            case ts.SyntaxKind.StringLiteral:\n                return new models_1.LiteralType(node.literal.text);\n            case ts.SyntaxKind.NumericLiteral:\n                return new models_1.LiteralType(Number(node.literal.text));\n            case ts.SyntaxKind.NullKeyword:\n                return new models_1.LiteralType(null);\n            case ts.SyntaxKind.PrefixUnaryExpression: {\n                const operand = node.literal\n                    .operand;\n                switch (operand.kind) {\n                    case ts.SyntaxKind.NumericLiteral:\n                        return new models_1.LiteralType(Number(node.literal.getText()));\n                    case ts.SyntaxKind.BigIntLiteral:\n                        return new models_1.LiteralType(BigInt(node.literal.getText().replace(\"n\", \"\")));\n                    default:\n                        return requestBugReport(context, node.literal);\n                }\n            }\n            case ts.SyntaxKind.BigIntLiteral:\n                return new models_1.LiteralType(BigInt(node.literal.getText().replace(\"n\", \"\")));\n            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n                return new models_1.LiteralType(node.literal.text);\n        }\n        return requestBugReport(context, node.literal);\n    },\n    convertType(_context, type, node) {\n        switch (node.literal.kind) {\n            case ts.SyntaxKind.StringLiteral:\n                return new models_1.LiteralType(node.literal.text);\n            case ts.SyntaxKind.NumericLiteral:\n                return new models_1.LiteralType(+node.literal.text);\n            case ts.SyntaxKind.TrueKeyword:\n            case ts.SyntaxKind.FalseKeyword:\n                return new models_1.LiteralType(node.literal.kind === ts.SyntaxKind.TrueKeyword);\n            case ts.SyntaxKind.NullKeyword:\n                return new models_1.LiteralType(null);\n        }\n        if (typeof type.value === \"object\") {\n            return new models_1.LiteralType(BigInt(`${type.value.negative ? \"-\" : \"\"}${type.value.base10Value}`));\n        }\n        return new models_1.LiteralType(type.value);\n    },\n};\nconst templateLiteralConverter = {\n    kind: [ts.SyntaxKind.TemplateLiteralType],\n    convert(context, node) {\n        return new models_1.TemplateLiteralType(node.head.text, node.templateSpans.map((span) => {\n            return [convertType(context, span.type), span.literal.text];\n        }));\n    },\n    convertType(context, type) {\n        assert(type.texts.length === type.types.length + 1);\n        const parts = [];\n        for (const [a, b] of (0, array_1.zip)(type.types, type.texts.slice(1))) {\n            parts.push([convertType(context, a), b]);\n        }\n        return new models_1.TemplateLiteralType(type.texts[0], parts);\n    },\n};\nconst thisConverter = {\n    kind: [ts.SyntaxKind.ThisType],\n    convert() {\n        return new models_1.IntrinsicType(\"this\");\n    },\n    convertType() {\n        return new models_1.IntrinsicType(\"this\");\n    },\n};\nconst tupleConverter = {\n    kind: [ts.SyntaxKind.TupleType],\n    convert(context, node) {\n        const elements = node.elements.map((node) => convertType(context, node));\n        return new models_1.TupleType(elements);\n    },\n    convertType(context, type, node) {\n        var _a;\n        const types = (_a = type.typeArguments) === null || _a === void 0 ? void 0 : _a.slice(0, node.elements.length);\n        let elements = types === null || types === void 0 ? void 0 : types.map((type) => convertType(context, type));\n        if (type.target.labeledElementDeclarations) {\n            const namedDeclarations = type.target.labeledElementDeclarations;\n            elements = elements === null || elements === void 0 ? void 0 : elements.map((el, i) => new models_1.NamedTupleMember(namedDeclarations[i].name.getText(), !!namedDeclarations[i].questionToken, (0, reflections_1.removeUndefined)(el)));\n        }\n        elements = elements === null || elements === void 0 ? void 0 : elements.map((el, i) => {\n            if (type.target.elementFlags[i] & ts.ElementFlags.Variable) {\n                // In the node case, we don't need to add the wrapping Array type... but we do here.\n                if (el instanceof models_1.NamedTupleMember) {\n                    return new models_1.RestType(new models_1.NamedTupleMember(el.name, el.isOptional, new models_1.ArrayType(el.element)));\n                }\n                return new models_1.RestType(new models_1.ArrayType(el));\n            }\n            if (type.target.elementFlags[i] & ts.ElementFlags.Optional &&\n                !(el instanceof models_1.NamedTupleMember)) {\n                return new models_1.OptionalType((0, reflections_1.removeUndefined)(el));\n            }\n            return el;\n        });\n        return new models_1.TupleType(elements !== null && elements !== void 0 ? elements : []);\n    },\n};\nconst supportedOperatorNames = {\n    [ts.SyntaxKind.KeyOfKeyword]: \"keyof\",\n    [ts.SyntaxKind.UniqueKeyword]: \"unique\",\n    [ts.SyntaxKind.ReadonlyKeyword]: \"readonly\",\n};\nconst typeOperatorConverter = {\n    kind: [ts.SyntaxKind.TypeOperator],\n    convert(context, node) {\n        return new models_1.TypeOperatorType(convertType(context, node.type), supportedOperatorNames[node.operator]);\n    },\n    convertType(context, type, node) {\n        // readonly is only valid on array and tuple literal types.\n        if (node.operator === ts.SyntaxKind.ReadonlyKeyword) {\n            const resolved = resolveReference(type);\n            assert(isObjectType(resolved));\n            const args = context.checker\n                .getTypeArguments(type)\n                .map((type) => convertType(context, type));\n            const inner = resolved.objectFlags & ts.ObjectFlags.Tuple\n                ? new models_1.TupleType(args)\n                : new models_1.ArrayType(args[0]);\n            return new models_1.TypeOperatorType(inner, \"readonly\");\n        }\n        // keyof will only show up with generic functions, otherwise it gets eagerly\n        // resolved to a union of strings.\n        if (node.operator === ts.SyntaxKind.KeyOfKeyword) {\n            // TS 4.2 added this to enable better tracking of type aliases.\n            if (type.isUnion() && type.origin) {\n                return convertType(context, type.origin);\n            }\n            // There's probably an interface for this somewhere... I couldn't find it.\n            const targetType = type.type;\n            return new models_1.TypeOperatorType(convertType(context, targetType), \"keyof\");\n        }\n        // TS drops `unique` in `unique symbol` everywhere. If someone used it, we ought\n        // to have a type node. This shouldn't ever happen.\n        return requestBugReport(context, type);\n    },\n};\nconst unionConverter = {\n    kind: [ts.SyntaxKind.UnionType],\n    convert(context, node) {\n        return new models_1.UnionType(node.types.map((type) => convertType(context, type)));\n    },\n    convertType(context, type) {\n        // TS 4.2 added this to enable better tracking of type aliases.\n        if (type.origin) {\n            return convertType(context, type.origin);\n        }\n        return new models_1.UnionType(type.types.map((type) => convertType(context, type)));\n    },\n};\nconst jsDocNullableTypeConverter = {\n    kind: [ts.SyntaxKind.JSDocNullableType],\n    convert(context, node) {\n        return new models_1.UnionType([\n            convertType(context, node.type),\n            new models_1.LiteralType(null),\n        ]);\n    },\n    // Should be a UnionType\n    convertType: requestBugReport,\n};\nconst jsDocNonNullableTypeConverter = {\n    kind: [ts.SyntaxKind.JSDocNonNullableType],\n    convert(context, node) {\n        return convertType(context, node.type);\n    },\n    // Should be a UnionType\n    convertType: requestBugReport,\n};\nfunction requestBugReport(context, nodeOrType) {\n    if (\"kind\" in nodeOrType) {\n        const kindName = ts.SyntaxKind[nodeOrType.kind];\n        const { line, character } = ts.getLineAndCharacterOfPosition(nodeOrType.getSourceFile(), nodeOrType.pos);\n        context.logger.warn(`Failed to convert type node with kind: ${kindName} and text ${nodeOrType.getText()}. Please report a bug.\\n\\t` +\n            `${nodeOrType.getSourceFile().fileName}:${line + 1}:${character}`);\n        return new models_1.UnknownType(nodeOrType.getText());\n    }\n    else {\n        const typeString = context.checker.typeToString(nodeOrType);\n        context.logger.warn(`Failed to convert type: ${typeString} when converting ${context.scope.getFullName()}. Please report a bug.`);\n        return new models_1.UnknownType(typeString);\n    }\n}\nfunction isObjectType(type) {\n    return typeof type.objectFlags === \"number\";\n}\nfunction resolveReference(type) {\n    if (isObjectType(type) && type.objectFlags & ts.ObjectFlags.Reference) {\n        return type.target;\n    }\n    return type;\n}\nfunction kindToModifier(kind) {\n    switch (kind) {\n        case ts.SyntaxKind.ReadonlyKeyword:\n        case ts.SyntaxKind.QuestionToken:\n        case ts.SyntaxKind.PlusToken:\n            return \"+\";\n        case ts.SyntaxKind.MinusToken:\n            return \"-\";\n        default:\n            return undefined;\n    }\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConverterEvents = void 0;\nexports.ConverterEvents = {\n    BEGIN: \"begin\",\n    END: \"end\",\n    CREATE_DECLARATION: \"createDeclaration\",\n    CREATE_SIGNATURE: \"createSignature\",\n    CREATE_PARAMETER: \"createParameter\",\n    CREATE_TYPE_PARAMETER: \"createTypeParameter\",\n    RESOLVE_BEGIN: \"resolveBegin\",\n    RESOLVE: \"resolveReflection\",\n    RESOLVE_END: \"resolveEnd\",\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertIndexSignature = void 0;\nconst assert = require(\"assert\");\nconst ts = require(\"typescript\");\nconst models_1 = require(\"../../models\");\nconst converter_events_1 = require(\"../converter-events\");\nfunction convertIndexSignature(context, symbol) {\n    var _a, _b;\n    assert(context.scope instanceof models_1.DeclarationReflection);\n    const indexSymbol = (_a = symbol.members) === null || _a === void 0 ? void 0 : _a.get(\"__index\");\n    if (indexSymbol) {\n        // Right now TypeDoc models don't have a way to distinguish between string\n        // and number index signatures... { [x: string]: 1 | 2; [x: number]: 2 }\n        // will be misrepresented.\n        const indexDeclaration = (_b = indexSymbol.getDeclarations()) === null || _b === void 0 ? void 0 : _b[0];\n        assert(indexDeclaration && ts.isIndexSignatureDeclaration(indexDeclaration));\n        const param = indexDeclaration.parameters[0];\n        assert(param && ts.isParameter(param));\n        const index = new models_1.SignatureReflection(\"__index\", models_1.ReflectionKind.IndexSignature, context.scope);\n        index.parameters = [\n            new models_1.ParameterReflection(param.name.getText(), models_1.ReflectionKind.Parameter, index),\n        ];\n        index.parameters[0].type = context.converter.convertType(context.withScope(index.parameters[0]), param.type);\n        index.type = context.converter.convertType(context.withScope(index), indexDeclaration.type);\n        context.registerReflection(index, indexSymbol);\n        context.scope.indexSignature = index;\n        context.trigger(converter_events_1.ConverterEvents.CREATE_SIGNATURE, index, indexDeclaration);\n    }\n}\nexports.convertIndexSignature = convertIndexSignature;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTypeParamReflection = exports.convertTypeParameterNodes = exports.convertParameterNodes = exports.createSignature = void 0;\nconst ts = require(\"typescript\");\nconst assert = require(\"assert\");\nconst models_1 = require(\"../../models\");\nconst converter_events_1 = require(\"../converter-events\");\nconst convert_expression_1 = require(\"../convert-expression\");\nconst reflections_1 = require(\"../utils/reflections\");\nfunction createSignature(context, kind, signature, declaration, commentDeclaration) {\n    var _a;\n    var _b;\n    assert(context.scope instanceof models_1.DeclarationReflection);\n    // signature.getDeclaration might return undefined.\n    // https://github.com/microsoft/TypeScript/issues/30014\n    declaration !== null && declaration !== void 0 ? declaration : (declaration = signature.getDeclaration());\n    if (!commentDeclaration &&\n        declaration &&\n        (ts.isArrowFunction(declaration) ||\n            ts.isFunctionExpression(declaration))) {\n        commentDeclaration = declaration.parent;\n    }\n    commentDeclaration !== null && commentDeclaration !== void 0 ? commentDeclaration : (commentDeclaration = declaration);\n    const sigRef = new models_1.SignatureReflection(kind == models_1.ReflectionKind.ConstructorSignature\n        ? `new ${context.scope.parent.name}`\n        : context.scope.name, kind, context.scope);\n    sigRef.typeParameters = convertTypeParameters(context, sigRef, signature.typeParameters);\n    const parameterSymbols = signature.thisParameter\n        ? [signature.thisParameter, ...signature.parameters]\n        : signature.parameters;\n    sigRef.parameters = convertParameters(context, sigRef, parameterSymbols, declaration === null || declaration === void 0 ? void 0 : declaration.parameters);\n    const predicate = context.checker.getTypePredicateOfSignature(signature);\n    if (predicate) {\n        sigRef.type = convertPredicate(predicate, context.withScope(sigRef));\n    }\n    else if (kind == models_1.ReflectionKind.SetSignature) {\n        sigRef.type = new models_1.IntrinsicType(\"void\");\n    }\n    else {\n        sigRef.type = context.converter.convertType(context.withScope(sigRef), ((declaration === null || declaration === void 0 ? void 0 : declaration.kind) === ts.SyntaxKind.FunctionDeclaration &&\n            declaration.type) ||\n            signature.getReturnType());\n    }\n    context.registerReflection(sigRef, undefined);\n    switch (kind) {\n        case models_1.ReflectionKind.GetSignature:\n            context.scope.getSignature = sigRef;\n            break;\n        case models_1.ReflectionKind.SetSignature:\n            context.scope.setSignature = sigRef;\n            break;\n        case models_1.ReflectionKind.CallSignature:\n        case models_1.ReflectionKind.ConstructorSignature:\n            (_a = (_b = context.scope).signatures) !== null && _a !== void 0 ? _a : (_b.signatures = []);\n            context.scope.signatures.push(sigRef);\n            break;\n    }\n    context.trigger(converter_events_1.ConverterEvents.CREATE_SIGNATURE, sigRef, commentDeclaration);\n}\nexports.createSignature = createSignature;\nfunction convertParameters(context, sigRef, parameters, parameterNodes) {\n    return parameters.map((param, i) => {\n        const declaration = param.valueDeclaration;\n        assert(!declaration ||\n            ts.isParameter(declaration) ||\n            ts.isJSDocParameterTag(declaration));\n        const paramRefl = new models_1.ParameterReflection(/__\\d+/.test(param.name) ? \"__namedParameters\" : param.name, models_1.ReflectionKind.Parameter, sigRef);\n        context.registerReflection(paramRefl, param);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_PARAMETER, paramRefl, declaration);\n        let type;\n        if (declaration) {\n            type = context.checker.getTypeOfSymbolAtLocation(param, declaration);\n        }\n        else {\n            type = param.type;\n        }\n        paramRefl.type = context.converter.convertType(context.withScope(paramRefl), type);\n        let isOptional = false;\n        if (declaration) {\n            isOptional = ts.isParameter(declaration)\n                ? !!declaration.questionToken\n                : declaration.isBracketed;\n        }\n        if (isOptional) {\n            paramRefl.type = (0, reflections_1.removeUndefined)(paramRefl.type);\n        }\n        paramRefl.defaultValue = (0, convert_expression_1.convertDefaultValue)(parameterNodes === null || parameterNodes === void 0 ? void 0 : parameterNodes[i]);\n        paramRefl.setFlag(models_1.ReflectionFlag.Optional, isOptional);\n        // If we have no declaration, then this is an implicitly defined parameter in JS land\n        // because the method body uses `arguments`... which is always a rest argument\n        let isRest = true;\n        if (declaration) {\n            isRest = ts.isParameter(declaration)\n                ? !!declaration.dotDotDotToken\n                : !!declaration.typeExpression &&\n                    ts.isJSDocVariadicType(declaration.typeExpression.type);\n        }\n        paramRefl.setFlag(models_1.ReflectionFlag.Rest, isRest);\n        return paramRefl;\n    });\n}\nfunction convertParameterNodes(context, sigRef, parameters) {\n    return parameters.map((param) => {\n        var _a;\n        const paramRefl = new models_1.ParameterReflection(/__\\d+/.test(param.name.getText())\n            ? \"__namedParameters\"\n            : param.name.getText(), models_1.ReflectionKind.Parameter, sigRef);\n        context.registerReflection(paramRefl, context.getSymbolAtLocation(param));\n        paramRefl.type = context.converter.convertType(context.withScope(paramRefl), ts.isParameter(param) ? param.type : (_a = param.typeExpression) === null || _a === void 0 ? void 0 : _a.type);\n        const isOptional = ts.isParameter(param)\n            ? !!param.questionToken\n            : param.isBracketed;\n        if (isOptional) {\n            paramRefl.type = (0, reflections_1.removeUndefined)(paramRefl.type);\n        }\n        paramRefl.defaultValue = (0, convert_expression_1.convertDefaultValue)(param);\n        paramRefl.setFlag(models_1.ReflectionFlag.Optional, isOptional);\n        paramRefl.setFlag(models_1.ReflectionFlag.Rest, ts.isParameter(param)\n            ? !!param.dotDotDotToken\n            : !!param.typeExpression &&\n                ts.isJSDocVariadicType(param.typeExpression.type));\n        return paramRefl;\n    });\n}\nexports.convertParameterNodes = convertParameterNodes;\nfunction convertTypeParameters(context, parent, parameters) {\n    return parameters === null || parameters === void 0 ? void 0 : parameters.map((param) => {\n        var _a, _b, _c;\n        const constraintT = param.getConstraint();\n        const defaultT = param.getDefault();\n        const constraint = constraintT\n            ? context.converter.convertType(context, constraintT)\n            : void 0;\n        const defaultType = defaultT\n            ? context.converter.convertType(context, defaultT)\n            : void 0;\n        // There's no way to determine directly from a ts.TypeParameter what it's variance modifiers are\n        // so unfortunately we have to go back to the node for this...\n        const variance = getVariance((_c = (_b = (_a = param.getSymbol()) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b.find(ts.isTypeParameterDeclaration)) === null || _c === void 0 ? void 0 : _c.modifiers);\n        const paramRefl = new models_1.TypeParameterReflection(param.symbol.name, constraint, defaultType, parent, variance);\n        context.registerReflection(paramRefl, param.getSymbol());\n        context.trigger(converter_events_1.ConverterEvents.CREATE_TYPE_PARAMETER, paramRefl);\n        return paramRefl;\n    });\n}\nfunction convertTypeParameterNodes(context, parameters) {\n    return parameters === null || parameters === void 0 ? void 0 : parameters.map((param) => createTypeParamReflection(param, context));\n}\nexports.convertTypeParameterNodes = convertTypeParameterNodes;\nfunction createTypeParamReflection(param, context) {\n    const constraint = param.constraint\n        ? context.converter.convertType(context, param.constraint)\n        : void 0;\n    const defaultType = param.default\n        ? context.converter.convertType(context, param.default)\n        : void 0;\n    const paramRefl = new models_1.TypeParameterReflection(param.name.text, constraint, defaultType, context.scope, getVariance(param.modifiers));\n    context.registerReflection(paramRefl, param.symbol);\n    context.trigger(converter_events_1.ConverterEvents.CREATE_TYPE_PARAMETER, paramRefl, param);\n    return paramRefl;\n}\nexports.createTypeParamReflection = createTypeParamReflection;\nfunction getVariance(modifiers) {\n    const hasIn = modifiers === null || modifiers === void 0 ? void 0 : modifiers.some((mod) => mod.kind === ts.SyntaxKind.InKeyword);\n    const hasOut = modifiers === null || modifiers === void 0 ? void 0 : modifiers.some((mod) => mod.kind === ts.SyntaxKind.OutKeyword);\n    if (hasIn && hasOut) {\n        return models_1.VarianceModifier.inOut;\n    }\n    if (hasIn) {\n        return models_1.VarianceModifier.in;\n    }\n    if (hasOut) {\n        return models_1.VarianceModifier.out;\n    }\n}\nfunction convertPredicate(predicate, context) {\n    let name;\n    switch (predicate.kind) {\n        case ts.TypePredicateKind.This:\n        case ts.TypePredicateKind.AssertsThis:\n            name = \"this\";\n            break;\n        case ts.TypePredicateKind.Identifier:\n        case ts.TypePredicateKind.AssertsIdentifier:\n            name = predicate.parameterName;\n            break;\n    }\n    let asserts;\n    switch (predicate.kind) {\n        case ts.TypePredicateKind.This:\n        case ts.TypePredicateKind.Identifier:\n            asserts = false;\n            break;\n        case ts.TypePredicateKind.AssertsThis:\n        case ts.TypePredicateKind.AssertsIdentifier:\n            asserts = true;\n            break;\n    }\n    return new models_1.PredicateType(name, asserts, predicate.type\n        ? context.converter.convertType(context, predicate.type)\n        : void 0);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertExpression = exports.convertDefaultValue = void 0;\nconst ts = require(\"typescript\");\n/**\n * Return the default value of the given node.\n *\n * @param node  The TypeScript node whose default value should be extracted.\n * @returns The default value as a string.\n */\nfunction convertDefaultValue(node) {\n    const anyNode = node;\n    if (anyNode === null || anyNode === void 0 ? void 0 : anyNode.initializer) {\n        return convertExpression(anyNode.initializer);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.convertDefaultValue = convertDefaultValue;\nfunction convertExpression(expression) {\n    switch (expression.kind) {\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.TrueKeyword:\n        case ts.SyntaxKind.FalseKeyword:\n        case ts.SyntaxKind.NullKeyword:\n        case ts.SyntaxKind.NumericLiteral:\n        case ts.SyntaxKind.PrefixUnaryExpression:\n        case ts.SyntaxKind.Identifier:\n            return expression.getText();\n    }\n    if (ts.isArrayLiteralExpression(expression) &&\n        expression.elements.length === 0) {\n        return \"[]\";\n    }\n    if (ts.isObjectLiteralExpression(expression) &&\n        expression.properties.length === 0) {\n        return \"{}\";\n    }\n    // a.b.c.d\n    if (ts.isPropertyAccessExpression(expression)) {\n        const parts = [expression.name.getText()];\n        let iter = expression.expression;\n        while (ts.isPropertyAccessExpression(iter)) {\n            parts.unshift(iter.name.getText());\n            iter = iter.expression;\n        }\n        if (ts.isIdentifier(iter)) {\n            parts.unshift(iter.text);\n            return parts.join(\".\");\n        }\n    }\n    // More complex expressions are generally not useful in the documentation.\n    // Show that there was a value, but not specifics.\n    return \"...\";\n}\nexports.convertExpression = convertExpression;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.copyComment = exports.removeUndefined = void 0;\nconst models_1 = require(\"../../models\");\nfunction removeUndefined(type) {\n    if (type instanceof models_1.UnionType) {\n        const types = type.types.filter((t) => {\n            if (t instanceof models_1.IntrinsicType) {\n                return t.name !== \"undefined\";\n            }\n            return true;\n        });\n        if (types.length === 1) {\n            return types[0];\n        }\n        type.types = types;\n        return type;\n    }\n    return type;\n}\nexports.removeUndefined = removeUndefined;\n/**\n * Copy the comment of the source reflection to the target reflection.\n *\n * @param target - Reflection with comment containing `inheritdoc` tag\n * @param source - Referenced reflection\n */\nfunction copyComment(target, source) {\n    var _a;\n    if (target.comment &&\n        source.comment &&\n        target.comment.hasTag(\"inheritdoc\")) {\n        if (target instanceof models_1.DeclarationReflection &&\n            source instanceof models_1.DeclarationReflection) {\n            target.typeParameters = source.typeParameters;\n        }\n        if (target instanceof models_1.SignatureReflection &&\n            source instanceof models_1.SignatureReflection) {\n            target.typeParameters = source.typeParameters;\n            /**\n             * TSDoc overrides existing parameters entirely with inherited ones, while\n             * existing implementation merges them.\n             * To avoid breaking things, `inheritDoc` tag is additionally checked for the parameter,\n             * so the previous behavior will continue to work.\n             *\n             * TODO: When breaking change becomes acceptable remove legacy implementation\n             */\n            if ((_a = target.comment.getTag(\"inheritdoc\")) === null || _a === void 0 ? void 0 : _a.paramName) {\n                target.parameters = source.parameters;\n            }\n            else {\n                legacyCopyImplementation(target, source);\n            }\n        }\n        target.comment.removeTags(\"inheritdoc\");\n        target.comment.copyFrom(source.comment);\n    }\n    else if (!target.comment && source.comment) {\n        if (target instanceof models_1.DeclarationReflection &&\n            source instanceof models_1.DeclarationReflection) {\n            target.typeParameters = source.typeParameters;\n        }\n        target.comment = new models_1.Comment();\n        target.comment.copyFrom(source.comment);\n    }\n}\nexports.copyComment = copyComment;\n/**\n * Copy comments from source reflection to target reflection, parameters are merged.\n *\n * @param target - Reflection with comment containing `inheritdoc` tag\n * @param source - Parent reflection\n */\nfunction legacyCopyImplementation(target, source) {\n    if (target.parameters && source.parameters) {\n        for (let index = 0, count = target.parameters.length; index < count; index++) {\n            const sourceParameter = source.parameters[index];\n            if (sourceParameter && sourceParameter.comment) {\n                const targetParameter = target.parameters[index];\n                if (!targetParameter.comment) {\n                    targetParameter.comment = new models_1.Comment();\n                    targetParameter.comment.copyFrom(sourceParameter.comment);\n                }\n            }\n        }\n    }\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertSymbol = void 0;\nconst assert = require(\"assert\");\nconst ts = require(\"typescript\");\nconst models_1 = require(\"../models\");\nconst enum_1 = require(\"../utils/enum\");\nconst convert_expression_1 = require(\"./convert-expression\");\nconst converter_events_1 = require(\"./converter-events\");\nconst index_signature_1 = require(\"./factories/index-signature\");\nconst signature_1 = require(\"./factories/signature\");\nconst jsdoc_1 = require(\"./jsdoc\");\nconst nodes_1 = require(\"./utils/nodes\");\nconst reflections_1 = require(\"./utils/reflections\");\nconst symbolConverters = {\n    [ts.SymbolFlags.RegularEnum]: convertEnum,\n    [ts.SymbolFlags.ConstEnum]: convertEnum,\n    [ts.SymbolFlags.EnumMember]: convertEnumMember,\n    [ts.SymbolFlags.ValueModule]: convertNamespace,\n    [ts.SymbolFlags.NamespaceModule]: convertNamespace,\n    [ts.SymbolFlags.TypeAlias]: convertTypeAlias,\n    [ts.SymbolFlags.Function]: convertFunctionOrMethod,\n    [ts.SymbolFlags.Method]: convertFunctionOrMethod,\n    [ts.SymbolFlags.Interface]: convertClassOrInterface,\n    [ts.SymbolFlags.Property]: convertProperty,\n    [ts.SymbolFlags.Class]: convertClassOrInterface,\n    [ts.SymbolFlags.Constructor]: convertConstructor,\n    [ts.SymbolFlags.Alias]: convertAlias,\n    [ts.SymbolFlags.BlockScopedVariable]: convertVariable,\n    [ts.SymbolFlags.FunctionScopedVariable]: convertVariable,\n    [ts.SymbolFlags.GetAccessor]: convertAccessor,\n    [ts.SymbolFlags.SetAccessor]: convertAccessor,\n};\nconst allConverterFlags = Object.keys(symbolConverters).reduce((v, k) => v | +k, 0);\n// This is kind of a hack, born of resolving references by symbols instead\n// of by source location.\nconst conversionOrder = [\n    // Do enums before namespaces so that @hidden on a namespace\n    // merged with an enum works properly.\n    ts.SymbolFlags.RegularEnum,\n    ts.SymbolFlags.ConstEnum,\n    ts.SymbolFlags.EnumMember,\n    // Before type alias\n    ts.SymbolFlags.BlockScopedVariable,\n    ts.SymbolFlags.FunctionScopedVariable,\n    ts.SymbolFlags.TypeAlias,\n    ts.SymbolFlags.Function,\n    ts.SymbolFlags.Method,\n    ts.SymbolFlags.Interface,\n    ts.SymbolFlags.Property,\n    ts.SymbolFlags.Class,\n    ts.SymbolFlags.Constructor,\n    ts.SymbolFlags.Alias,\n    ts.SymbolFlags.GetAccessor,\n    ts.SymbolFlags.SetAccessor,\n    ts.SymbolFlags.ValueModule,\n    ts.SymbolFlags.NamespaceModule,\n];\n// Sanity check, if this fails a dev messed up.\nfor (const key of Object.keys(symbolConverters)) {\n    if (!Number.isInteger(Math.log2(+key))) {\n        throw new Error(`Symbol converter for key ${ts.SymbolFlags[+key]} does not specify a valid flag value.`);\n    }\n    if (!conversionOrder.includes(+key)) {\n        throw new Error(`Symbol converter for key ${ts.SymbolFlags[+key]} is not specified in conversionOrder`);\n    }\n}\nif (conversionOrder.reduce((a, b) => a | b, 0) !== allConverterFlags) {\n    throw new Error(\"conversionOrder contains a symbol flag that converters do not.\");\n}\nfunction convertSymbol(context, symbol, exportSymbol) {\n    var _a, _b;\n    if (context.shouldIgnore(symbol)) {\n        return;\n    }\n    // This check can catch symbols which ought to be documented as references\n    // but aren't aliased symbols because `export *` was used.\n    const previous = context.project.getReflectionFromSymbol(symbol);\n    if (previous &&\n        ((_a = previous.parent) === null || _a === void 0 ? void 0 : _a.kindOf(models_1.ReflectionKind.Module | models_1.ReflectionKind.Project))) {\n        createAlias(previous, context, symbol, exportSymbol);\n        return;\n    }\n    let flags = (0, enum_1.removeFlag)(symbol.flags, ts.SymbolFlags.Transient |\n        ts.SymbolFlags.Assignment |\n        ts.SymbolFlags.Optional |\n        ts.SymbolFlags.Prototype);\n    // Declaration merging - the only type (excluding enum/enum, ns/ns, etc)\n    // that TD supports is merging a class and interface. All others are\n    // represented as multiple reflections\n    if ((0, enum_1.hasAllFlags)(symbol.flags, ts.SymbolFlags.Class)) {\n        flags = (0, enum_1.removeFlag)(flags, ts.SymbolFlags.Interface | ts.SymbolFlags.Function);\n    }\n    // Kind of declaration merging... we treat this as a property with get/set signatures.\n    if ((0, enum_1.hasAllFlags)(symbol.flags, ts.SymbolFlags.GetAccessor)) {\n        flags = (0, enum_1.removeFlag)(flags, ts.SymbolFlags.SetAccessor);\n    }\n    if ((0, enum_1.hasAllFlags)(symbol.flags, ts.SymbolFlags.NamespaceModule)) {\n        // This might be here if a namespace is declared several times.\n        flags = (0, enum_1.removeFlag)(flags, ts.SymbolFlags.ValueModule);\n    }\n    if ((0, enum_1.hasAnyFlag)(symbol.flags, ts.SymbolFlags.Method |\n        ts.SymbolFlags.Interface |\n        ts.SymbolFlags.Class |\n        ts.SymbolFlags.Variable)) {\n        // This happens when someone declares an object with methods:\n        // { methodProperty() {} }\n        flags = (0, enum_1.removeFlag)(flags, ts.SymbolFlags.Property);\n    }\n    // A default exported function with no associated variable is a property, but\n    // we should really convert it as a variable for documentation purposes\n    // export default () => {}\n    // export default 123\n    if (flags === ts.SymbolFlags.Property &&\n        symbol.name === \"default\" &&\n        context.scope.kindOf(models_1.ReflectionKind.Module | models_1.ReflectionKind.Project)) {\n        flags = ts.SymbolFlags.BlockScopedVariable;\n    }\n    for (const flag of (0, enum_1.getEnumFlags)(flags ^ allConverterFlags)) {\n        if (!(flag & allConverterFlags)) {\n            context.logger.verbose(`Missing converter for symbol: ${symbol.name} with flag ${ts.SymbolFlags[flag]}`);\n        }\n    }\n    // Note: This method does not allow skipping earlier converters.\n    // For now, this is fine... might not be flexible enough in the future.\n    let skip = 0;\n    for (const flag of conversionOrder) {\n        if (!(flag & flags))\n            continue;\n        if (skip & flag)\n            continue;\n        skip |= ((_b = symbolConverters[flag]) === null || _b === void 0 ? void 0 : _b.call(symbolConverters, context, symbol, exportSymbol)) || 0;\n    }\n}\nexports.convertSymbol = convertSymbol;\nfunction convertSymbols(context, symbols) {\n    for (const symbol of symbols) {\n        convertSymbol(context, symbol);\n    }\n}\nfunction convertEnum(context, symbol, exportSymbol) {\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Enum, symbol, exportSymbol);\n    if (symbol.flags & ts.SymbolFlags.ConstEnum) {\n        reflection.setFlag(models_1.ReflectionFlag.Const);\n    }\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    convertSymbols(context.withScope(reflection), context.checker\n        .getExportsOfModule(symbol)\n        .filter((s) => s.flags & ts.SymbolFlags.EnumMember));\n}\nfunction convertEnumMember(context, symbol, exportSymbol) {\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.EnumMember, symbol, exportSymbol);\n    const defaultValue = context.checker.getConstantValue(symbol.getDeclarations()[0]);\n    reflection.defaultValue = JSON.stringify(defaultValue);\n    if (defaultValue !== undefined) {\n        reflection.type = new models_1.LiteralType(defaultValue);\n    }\n    else {\n        // We know this has to be a number, because computed values aren't allowed\n        // in string enums, so otherwise we would have to have the constant value\n        reflection.type = new models_1.IntrinsicType(\"number\");\n    }\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n}\nfunction convertNamespace(context, symbol, exportSymbol) {\n    var _a;\n    let exportFlags = ts.SymbolFlags.ModuleMember;\n    // This can happen in JS land where \"class\" functions get tagged as a namespace too\n    if (((_a = symbol\n        .getDeclarations()) === null || _a === void 0 ? void 0 : _a.some((d) => ts.isModuleDeclaration(d) || ts.isSourceFile(d))) !==\n        true) {\n        exportFlags = ts.SymbolFlags.ClassMember;\n        if ((0, enum_1.hasAnyFlag)(symbol.flags, ts.SymbolFlags.Class)) {\n            return;\n        }\n    }\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Namespace, symbol, exportSymbol);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    convertSymbols(context.withScope(reflection), context.checker\n        .getExportsOfModule(symbol)\n        .filter((s) => s.flags & exportFlags));\n}\nfunction convertTypeAlias(context, symbol, exportSymbol) {\n    var _a, _b;\n    const declaration = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a.find((d) => ts.isTypeAliasDeclaration(d) ||\n        ts.isJSDocTypedefTag(d) ||\n        ts.isJSDocCallbackTag(d) ||\n        ts.isJSDocEnumTag(d));\n    assert(declaration);\n    if (ts.isTypeAliasDeclaration(declaration)) {\n        const reflection = context.createDeclarationReflection(models_1.ReflectionKind.TypeAlias, symbol, exportSymbol);\n        reflection.type = context.converter.convertType(context.withScope(reflection), declaration.type);\n        context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n        // Do this after finalization so that the CommentPlugin can get @typeParam tags\n        // from the parent comment. Ugly, but works for now. Should be cleaned up with TSDoc\n        // support.\n        reflection.typeParameters = (_b = declaration.typeParameters) === null || _b === void 0 ? void 0 : _b.map((param) => (0, signature_1.createTypeParamReflection)(param, context.withScope(reflection)));\n    }\n    else if (ts.isJSDocTypedefTag(declaration) ||\n        ts.isJSDocEnumTag(declaration)) {\n        (0, jsdoc_1.convertJsDocAlias)(context, symbol, declaration, exportSymbol);\n    }\n    else {\n        (0, jsdoc_1.convertJsDocCallback)(context, symbol, declaration, exportSymbol);\n    }\n}\nfunction convertFunctionOrMethod(context, symbol, exportSymbol) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    // Can't just check method flag because this might be called for properties as well\n    // This will *NOT* be called for variables that look like functions, they need a special case.\n    const isMethod = !!(symbol.flags &\n        (ts.SymbolFlags.Property | ts.SymbolFlags.Method));\n    const declarations = (_b = (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a.filter(ts.isFunctionLike)) !== null && _b !== void 0 ? _b : [];\n    // Don't do anything if we inherited this method and it is private.\n    if (isMethod &&\n        isInherited(context, symbol) &&\n        declarations.length > 0 &&\n        (0, enum_1.hasAllFlags)(ts.getCombinedModifierFlags(declarations[0]), ts.ModifierFlags.Private)) {\n        return;\n    }\n    const parentSymbol = context.project.getSymbolFromReflection(context.scope);\n    const locationDeclaration = (_g = (_d = (_c = parentSymbol === null || parentSymbol === void 0 ? void 0 : parentSymbol.getDeclarations()) === null || _c === void 0 ? void 0 : _c.find((d) => ts.isClassDeclaration(d) || ts.isInterfaceDeclaration(d))) !== null && _d !== void 0 ? _d : (_f = (_e = parentSymbol === null || parentSymbol === void 0 ? void 0 : parentSymbol.getDeclarations()) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.getSourceFile()) !== null && _g !== void 0 ? _g : (_j = (_h = symbol.getDeclarations()) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.getSourceFile();\n    assert(locationDeclaration, \"Missing declaration context\");\n    const type = context.checker.getTypeOfSymbolAtLocation(symbol, locationDeclaration);\n    // Need to get the non nullable type because interface methods might be declared\n    // with a question token. See GH1490.\n    const signatures = type.getNonNullableType().getCallSignatures();\n    const reflection = context.createDeclarationReflection(context.scope.kindOf(models_1.ReflectionKind.ClassOrInterface |\n        models_1.ReflectionKind.VariableOrProperty |\n        models_1.ReflectionKind.TypeLiteral)\n        ? models_1.ReflectionKind.Method\n        : models_1.ReflectionKind.Function, symbol, exportSymbol, void 0);\n    if (((_k = symbol.declarations) === null || _k === void 0 ? void 0 : _k.length) && isMethod) {\n        // All method signatures must have the same modifier flags.\n        setModifiers(symbol, symbol.declarations[0], reflection);\n    }\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    const scope = context.withScope(reflection);\n    (_l = reflection.signatures) !== null && _l !== void 0 ? _l : (reflection.signatures = []);\n    // Can't use zip here. We might have less declarations than signatures\n    // or less signatures than declarations.\n    for (let i = 0; i < signatures.length; i++) {\n        (0, signature_1.createSignature)(scope, models_1.ReflectionKind.CallSignature, signatures[i], declarations[i]);\n    }\n}\n// getDeclaredTypeOfSymbol gets the INSTANCE type\n// getTypeOfSymbolAtLocation gets the STATIC type\nfunction convertClassOrInterface(context, symbol, exportSymbol) {\n    var _a, _b, _c, _d, _e;\n    const reflection = context.createDeclarationReflection(ts.SymbolFlags.Class & symbol.flags\n        ? models_1.ReflectionKind.Class\n        : models_1.ReflectionKind.Interface, symbol, exportSymbol, void 0);\n    const classDeclaration = (_a = symbol\n        .getDeclarations()) === null || _a === void 0 ? void 0 : _a.find((d) => ts.isClassDeclaration(d) || ts.isFunctionDeclaration(d));\n    if (classDeclaration)\n        setModifiers(symbol, classDeclaration, reflection);\n    const reflectionContext = context.withScope(reflection);\n    const instanceType = context.checker.getDeclaredTypeOfSymbol(symbol);\n    assert(instanceType.isClassOrInterface());\n    // We might do some inheritance - do this first so that it's set when converting properties\n    const declarations = (_c = (_b = symbol\n        .getDeclarations()) === null || _b === void 0 ? void 0 : _b.filter((d) => ts.isInterfaceDeclaration(d) || ts.isClassDeclaration(d))) !== null && _c !== void 0 ? _c : [];\n    const extendedTypes = (0, nodes_1.getHeritageTypes)(declarations, ts.SyntaxKind.ExtendsKeyword).map((t) => context.converter.convertType(reflectionContext, t));\n    if (extendedTypes.length) {\n        reflection.extendedTypes = extendedTypes;\n    }\n    const implementedTypes = (0, nodes_1.getHeritageTypes)(declarations, ts.SyntaxKind.ImplementsKeyword).map((t) => context.converter.convertType(reflectionContext, t));\n    if (implementedTypes.length) {\n        reflection.implementedTypes = implementedTypes;\n    }\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    if (classDeclaration) {\n        // Classes can have static props\n        const staticType = context.checker.getTypeOfSymbolAtLocation(symbol, classDeclaration);\n        reflectionContext.shouldBeStatic = true;\n        for (const prop of context.checker.getPropertiesOfType(staticType)) {\n            // Don't convert namespace members, or the prototype here.\n            if (prop.flags &\n                (ts.SymbolFlags.ModuleMember | ts.SymbolFlags.Prototype))\n                continue;\n            convertSymbol(reflectionContext, prop);\n        }\n        reflectionContext.shouldBeStatic = false;\n        const constructMember = new models_1.DeclarationReflection(\"constructor\", models_1.ReflectionKind.Constructor, reflection);\n        reflectionContext.addChild(constructMember);\n        const ctors = staticType.getConstructSignatures();\n        context.registerReflection(constructMember, (_e = (_d = ctors === null || ctors === void 0 ? void 0 : ctors[0]) === null || _d === void 0 ? void 0 : _d.declaration) === null || _e === void 0 ? void 0 : _e.symbol);\n        // Modifiers are the same for all constructors\n        if (ctors.length && ctors[0].declaration) {\n            setModifiers(symbol, ctors[0].declaration, constructMember);\n        }\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, constructMember, ts.isClassDeclaration(classDeclaration)\n            ? classDeclaration.members.find(ts.isConstructorDeclaration)\n            : void 0);\n        const constructContext = reflectionContext.withScope(constructMember);\n        ctors.forEach((sig) => {\n            (0, signature_1.createSignature)(constructContext, models_1.ReflectionKind.ConstructorSignature, sig);\n        });\n    }\n    // Classes/interfaces usually just have properties...\n    convertSymbols(reflectionContext, context.checker.getPropertiesOfType(instanceType));\n    // And type arguments\n    if (instanceType.typeParameters) {\n        reflection.typeParameters = instanceType.typeParameters.map((param) => {\n            var _a, _b;\n            const declaration = (_b = (_a = param.symbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b[0];\n            assert(declaration && ts.isTypeParameterDeclaration(declaration));\n            return (0, signature_1.createTypeParamReflection)(declaration, reflectionContext);\n        });\n    }\n    // Interfaces might also have call signatures\n    // Classes might too, because of declaration merging\n    context.checker\n        .getSignaturesOfType(instanceType, ts.SignatureKind.Call)\n        .forEach((sig) => (0, signature_1.createSignature)(reflectionContext, models_1.ReflectionKind.CallSignature, sig));\n    // We also might have constructor signatures\n    // This is potentially a problem with classes having multiple \"constructor\" members...\n    // but nobody has complained yet.\n    convertConstructSignatures(reflectionContext, symbol);\n    // And finally, index signatures\n    (0, index_signature_1.convertIndexSignature)(reflectionContext, symbol);\n}\nfunction convertProperty(context, symbol, exportSymbol) {\n    var _a, _b, _c;\n    const declarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n    // Don't do anything if we inherited this property and it is private.\n    if (isInherited(context, symbol) &&\n        declarations.length > 0 &&\n        (0, enum_1.hasAllFlags)(ts.getCombinedModifierFlags(declarations[0]), ts.ModifierFlags.Private)) {\n        return;\n    }\n    // Special case: We pretend properties are methods if they look like methods.\n    // This happens with mixins / weird inheritance.\n    if (declarations.length &&\n        declarations.every((decl) => ts.isMethodSignature(decl) || ts.isMethodDeclaration(decl))) {\n        return convertFunctionOrMethod(context, symbol, exportSymbol);\n    }\n    if (declarations.length === 1) {\n        const declaration = declarations[0];\n        // Special case: \"arrow methods\" should be treated as methods.\n        if (ts.isPropertyDeclaration(declaration) &&\n            !declaration.type &&\n            declaration.initializer &&\n            ts.isArrowFunction(declaration.initializer)) {\n            return convertArrowAsMethod(context, symbol, declaration.initializer, exportSymbol);\n        }\n        // Special case: \"arrow properties\" in type space should be treated as methods.\n        if (ts.isPropertySignature(declaration) &&\n            declaration.type &&\n            ts.isFunctionTypeNode(declaration.type)) {\n            return convertArrowAsMethod(context, symbol, declaration.type, exportSymbol);\n        }\n    }\n    const reflection = context.createDeclarationReflection(context.scope.kindOf(models_1.ReflectionKind.Namespace)\n        ? models_1.ReflectionKind.Variable\n        : models_1.ReflectionKind.Property, symbol, exportSymbol);\n    const declaration = (_b = symbol.getDeclarations()) === null || _b === void 0 ? void 0 : _b[0];\n    let parameterType;\n    if (declaration &&\n        (ts.isPropertyDeclaration(declaration) ||\n            ts.isPropertySignature(declaration) ||\n            ts.isParameter(declaration) ||\n            ts.isPropertyAccessExpression(declaration))) {\n        if (!ts.isPropertyAccessExpression(declaration)) {\n            parameterType = declaration.type;\n        }\n        setModifiers(symbol, declaration, reflection);\n    }\n    reflection.defaultValue = declaration && (0, convert_expression_1.convertDefaultValue)(declaration);\n    // FIXME: Once we drop support for TS 4.5, we can use context.checker.getTypeOfSymbol(symbol) here.\n    reflection.type = context.converter.convertType(context, (_c = (context.isConvertingTypeNode() ? parameterType : void 0)) !== null && _c !== void 0 ? _c : context.checker.getTypeOfSymbolAtLocation(symbol, {\n        kind: ts.SyntaxKind.SourceFile,\n    }));\n    if (reflection.flags.isOptional) {\n        reflection.type = (0, reflections_1.removeUndefined)(reflection.type);\n    }\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n}\nfunction convertArrowAsMethod(context, symbol, arrow, exportSymbol) {\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Method, symbol, exportSymbol, void 0);\n    setModifiers(symbol, arrow.parent, reflection);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    const rc = context.withScope(reflection);\n    const signature = context.checker.getSignatureFromDeclaration(arrow);\n    assert(signature);\n    (0, signature_1.createSignature)(rc, models_1.ReflectionKind.CallSignature, signature, arrow);\n}\nfunction convertConstructor(context, symbol) {\n    var _a, _b;\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Constructor, symbol, void 0, \"constructor\");\n    context.finalizeDeclarationReflection(reflection, symbol);\n    const reflectionContext = context.withScope(reflection);\n    const declarations = (_b = (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a.filter(ts.isConstructorDeclaration)) !== null && _b !== void 0 ? _b : [];\n    const signatures = declarations.map((decl) => {\n        const sig = context.checker.getSignatureFromDeclaration(decl);\n        assert(sig);\n        return sig;\n    });\n    for (const sig of signatures) {\n        (0, signature_1.createSignature)(reflectionContext, models_1.ReflectionKind.ConstructorSignature, sig);\n    }\n}\nfunction convertConstructSignatures(context, symbol) {\n    const type = context.checker.getDeclaredTypeOfSymbol(symbol);\n    // These get added as a \"constructor\" member of this interface. This is a problem... but nobody\n    // has complained yet. We really ought to have a constructSignatures property on the reflection instead.\n    const constructSignatures = context.checker.getSignaturesOfType(type, ts.SignatureKind.Construct);\n    if (constructSignatures.length) {\n        const constructMember = new models_1.DeclarationReflection(\"constructor\", models_1.ReflectionKind.Constructor, context.scope);\n        context.addChild(constructMember);\n        context.registerReflection(constructMember, undefined);\n        context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, constructMember, \n        // FIXME this isn't good enough.\n        context.converter.getNodesForSymbol(symbol, models_1.ReflectionKind.Constructor)[0]);\n        const constructContext = context.withScope(constructMember);\n        constructSignatures.forEach((sig) => (0, signature_1.createSignature)(constructContext, models_1.ReflectionKind.ConstructorSignature, sig));\n    }\n}\nfunction convertAlias(context, symbol, exportSymbol) {\n    const reflection = context.project.getReflectionFromSymbol(context.resolveAliasedSymbol(symbol));\n    if (!reflection) {\n        // We don't have this, convert it.\n        convertSymbol(context, context.resolveAliasedSymbol(symbol), exportSymbol !== null && exportSymbol !== void 0 ? exportSymbol : symbol);\n    }\n    else {\n        createAlias(reflection, context, symbol, exportSymbol);\n    }\n}\nfunction createAlias(target, context, symbol, exportSymbol) {\n    var _a;\n    // We already have this. Create a reference.\n    const ref = new models_1.ReferenceReflection((_a = exportSymbol === null || exportSymbol === void 0 ? void 0 : exportSymbol.name) !== null && _a !== void 0 ? _a : symbol.name, target, context.scope);\n    context.addChild(ref);\n    context.registerReflection(ref, symbol);\n    context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, ref, \n    // FIXME this isn't good enough.\n    context.converter.getNodesForSymbol(symbol, models_1.ReflectionKind.Reference)[0]);\n}\nfunction convertVariable(context, symbol, exportSymbol) {\n    var _a;\n    const declaration = (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];\n    assert(declaration);\n    const type = context.checker.getTypeOfSymbolAtLocation(symbol, declaration);\n    if (isEnumLike(context.checker, type, declaration) &&\n        symbol.getJsDocTags().some((tag) => tag.name === \"enum\")) {\n        return convertVariableAsEnum(context, symbol, exportSymbol);\n    }\n    if (type.getCallSignatures().length && !type.getProperties().length) {\n        return convertVariableAsFunction(context, symbol, exportSymbol);\n    }\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Variable, symbol, exportSymbol);\n    let typeNode;\n    if (ts.isVariableDeclaration(declaration)) {\n        // Otherwise we might have destructuring\n        typeNode = declaration.type;\n    }\n    reflection.type = context.converter.convertType(context.withScope(reflection), typeNode !== null && typeNode !== void 0 ? typeNode : type);\n    setModifiers(symbol, declaration, reflection);\n    reflection.defaultValue = (0, convert_expression_1.convertDefaultValue)(declaration);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n}\nfunction isEnumLike(checker, type, location) {\n    if (!(0, enum_1.hasAllFlags)(type.flags, ts.TypeFlags.Object)) {\n        return false;\n    }\n    return type.getProperties().every((prop) => {\n        const propType = checker.getTypeOfSymbolAtLocation(prop, location);\n        return propType.isStringLiteral() || propType.isNumberLiteral();\n    });\n}\nfunction convertVariableAsEnum(context, symbol, exportSymbol) {\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Enum, symbol, exportSymbol);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    const rc = context.withScope(reflection);\n    const declaration = symbol.declarations[0];\n    const type = context.checker.getTypeAtLocation(declaration);\n    for (const prop of type.getProperties()) {\n        const reflection = rc.createDeclarationReflection(models_1.ReflectionKind.EnumMember, prop, void 0);\n        const propType = context.checker.getTypeOfSymbolAtLocation(prop, declaration);\n        assert(propType.isStringLiteral() || propType.isNumberLiteral());\n        reflection.defaultValue = JSON.stringify(propType.value);\n        reflection.type = new models_1.LiteralType(propType.value);\n        rc.finalizeDeclarationReflection(reflection, prop, void 0);\n    }\n    // Skip converting the type alias, if there is one\n    return ts.SymbolFlags.TypeAlias;\n}\nfunction convertVariableAsFunction(context, symbol, exportSymbol) {\n    var _a, _b;\n    const declaration = (_a = symbol\n        .getDeclarations()) === null || _a === void 0 ? void 0 : _a.find(ts.isVariableDeclaration);\n    const accessDeclaration = declaration !== null && declaration !== void 0 ? declaration : symbol.valueDeclaration;\n    const type = accessDeclaration\n        ? context.checker.getTypeOfSymbolAtLocation(symbol, accessDeclaration)\n        : context.checker.getDeclaredTypeOfSymbol(symbol);\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Function, symbol, exportSymbol);\n    setModifiers(symbol, accessDeclaration, reflection);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    const reflectionContext = context.withScope(reflection);\n    (_b = reflection.signatures) !== null && _b !== void 0 ? _b : (reflection.signatures = []);\n    for (const signature of type.getCallSignatures()) {\n        (0, signature_1.createSignature)(reflectionContext, models_1.ReflectionKind.CallSignature, signature, void 0, declaration);\n    }\n}\nfunction convertAccessor(context, symbol, exportSymbol) {\n    var _a, _b, _c;\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Accessor, symbol, exportSymbol);\n    const rc = context.withScope(reflection);\n    const declaration = (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];\n    if (declaration) {\n        setModifiers(symbol, declaration, reflection);\n    }\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    const getDeclaration = (_b = symbol.getDeclarations()) === null || _b === void 0 ? void 0 : _b.find(ts.isGetAccessor);\n    if (getDeclaration) {\n        const signature = context.checker.getSignatureFromDeclaration(getDeclaration);\n        if (signature) {\n            (0, signature_1.createSignature)(rc, models_1.ReflectionKind.GetSignature, signature, getDeclaration);\n        }\n    }\n    const setDeclaration = (_c = symbol.getDeclarations()) === null || _c === void 0 ? void 0 : _c.find(ts.isSetAccessor);\n    if (setDeclaration) {\n        const signature = context.checker.getSignatureFromDeclaration(setDeclaration);\n        if (signature) {\n            (0, signature_1.createSignature)(rc, models_1.ReflectionKind.SetSignature, signature, setDeclaration);\n        }\n    }\n}\nfunction isInherited(context, symbol) {\n    var _a;\n    const parentSymbol = context.project.getSymbolFromReflection(context.scope);\n    assert(parentSymbol, `No parent symbol found for ${symbol.name} in ${context.scope.name}`);\n    return (((_a = parentSymbol\n        .getDeclarations()) === null || _a === void 0 ? void 0 : _a.some((d) => { var _a; return (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a.some((d2) => d2.parent === d); })) === false);\n}\nfunction setModifiers(symbol, declaration, reflection) {\n    var _a;\n    if (!declaration) {\n        return;\n    }\n    const modifiers = ts.getCombinedModifierFlags(declaration);\n    if (ts.isMethodDeclaration(declaration) ||\n        ts.isPropertyDeclaration(declaration) ||\n        ts.isAccessor(declaration)) {\n        if (ts.isPrivateIdentifier(declaration.name)) {\n            reflection.setFlag(models_1.ReflectionFlag.Private);\n        }\n    }\n    if ((0, enum_1.hasAllFlags)(modifiers, ts.ModifierFlags.Private)) {\n        reflection.setFlag(models_1.ReflectionFlag.Private);\n    }\n    if ((0, enum_1.hasAllFlags)(modifiers, ts.ModifierFlags.Protected)) {\n        reflection.setFlag(models_1.ReflectionFlag.Protected);\n    }\n    if ((0, enum_1.hasAllFlags)(modifiers, ts.ModifierFlags.Public)) {\n        reflection.setFlag(models_1.ReflectionFlag.Public);\n    }\n    reflection.setFlag(models_1.ReflectionFlag.Optional, (0, enum_1.hasAllFlags)(symbol.flags, ts.SymbolFlags.Optional));\n    reflection.setFlag(models_1.ReflectionFlag.Readonly, (0, enum_1.hasAllFlags)((_a = symbol.checkFlags) !== null && _a !== void 0 ? _a : 0, ts.CheckFlags.Readonly) ||\n        (0, enum_1.hasAllFlags)(modifiers, ts.ModifierFlags.Readonly));\n    reflection.setFlag(models_1.ReflectionFlag.Abstract, (0, enum_1.hasAllFlags)(modifiers, ts.ModifierFlags.Abstract));\n    if (reflection.kindOf(models_1.ReflectionKind.Variable) &&\n        (0, enum_1.hasAllFlags)(symbol.flags, ts.SymbolFlags.BlockScopedVariable)) {\n        reflection.setFlag(models_1.ReflectionFlag.Const, (0, enum_1.hasAllFlags)(declaration.parent.flags, ts.NodeFlags.Const));\n    }\n    // ReflectionFlag.Static happens when constructing the reflection.\n    // We don't have sufficient information here to determine if it ought to be static.\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasAnyFlag = exports.hasAllFlags = exports.removeFlag = exports.getEnumFlags = void 0;\nfunction getEnumFlags(flags) {\n    const result = [];\n    for (let i = 1; i <= flags; i *= 2) {\n        if (flags & i) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nexports.getEnumFlags = getEnumFlags;\n// T & {} reduces inference priority\nfunction removeFlag(flag, remove) {\n    return ((flag ^ remove) & flag);\n}\nexports.removeFlag = removeFlag;\nfunction hasAllFlags(flags, check) {\n    return (flags & check) === check;\n}\nexports.hasAllFlags = hasAllFlags;\nfunction hasAnyFlag(flags, check) {\n    return (flags & check) !== 0;\n}\nexports.hasAnyFlag = hasAnyFlag;\n","\n// Converter functions for JSDoc defined types\n// @typedef\n// @callback\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertJsDocCallback = exports.convertJsDocAlias = void 0;\nconst assert_1 = require(\"assert\");\nconst ts = require(\"typescript\");\nconst models_1 = require(\"../models\");\nconst array_1 = require(\"../utils/array\");\nconst converter_events_1 = require(\"./converter-events\");\nconst signature_1 = require(\"./factories/signature\");\nfunction convertJsDocAlias(context, symbol, declaration, exportSymbol) {\n    var _a;\n    if (declaration.typeExpression &&\n        ts.isJSDocTypeLiteral(declaration.typeExpression)) {\n        convertJsDocInterface(context, declaration, symbol, exportSymbol);\n        return;\n    }\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.TypeAlias, symbol, exportSymbol);\n    reflection.type = context.converter.convertType(context.withScope(reflection), (_a = declaration.typeExpression) === null || _a === void 0 ? void 0 : _a.type);\n    convertTemplateParameters(context.withScope(reflection), declaration.parent);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n}\nexports.convertJsDocAlias = convertJsDocAlias;\nfunction convertJsDocCallback(context, symbol, declaration, exportSymbol) {\n    const alias = context.createDeclarationReflection(models_1.ReflectionKind.TypeAlias, symbol, exportSymbol);\n    context.finalizeDeclarationReflection(alias, symbol, exportSymbol);\n    const ac = context.withScope(alias);\n    alias.type = convertJsDocSignature(ac, declaration.typeExpression);\n    convertTemplateParameters(ac, declaration.parent);\n}\nexports.convertJsDocCallback = convertJsDocCallback;\nfunction convertJsDocInterface(context, declaration, symbol, exportSymbol) {\n    const reflection = context.createDeclarationReflection(models_1.ReflectionKind.Interface, symbol, exportSymbol);\n    context.finalizeDeclarationReflection(reflection, symbol, exportSymbol);\n    const rc = context.withScope(reflection);\n    const type = context.checker.getDeclaredTypeOfSymbol(symbol);\n    for (const s of type.getProperties()) {\n        context.converter.convertSymbol(rc, s);\n    }\n    convertTemplateParameters(rc, declaration.parent);\n}\nfunction convertJsDocSignature(context, node) {\n    var _a, _b, _c;\n    const symbol = (_a = context.getSymbolAtLocation(node)) !== null && _a !== void 0 ? _a : node.symbol;\n    const type = context.getTypeAtLocation(node);\n    if (!symbol || !type) {\n        return new models_1.IntrinsicType(\"Function\");\n    }\n    const reflection = new models_1.DeclarationReflection(\"__type\", models_1.ReflectionKind.TypeLiteral, context.scope);\n    context.registerReflection(reflection, symbol);\n    context.trigger(converter_events_1.ConverterEvents.CREATE_DECLARATION, reflection, node);\n    const signature = new models_1.SignatureReflection(\"__type\", models_1.ReflectionKind.CallSignature, reflection);\n    context.registerReflection(signature, void 0);\n    const signatureCtx = context.withScope(signature);\n    reflection.signatures = [signature];\n    signature.type = context.converter.convertType(signatureCtx, (_c = (_b = node.type) === null || _b === void 0 ? void 0 : _b.typeExpression) === null || _c === void 0 ? void 0 : _c.type);\n    signature.parameters = (0, signature_1.convertParameterNodes)(signatureCtx, signature, node.parameters);\n    signature.typeParameters = convertTemplateParameterNodes(context.withScope(reflection), node.typeParameters);\n    return new models_1.ReflectionType(reflection);\n}\nfunction convertTemplateParameters(context, node) {\n    var _a;\n    (0, assert_1.ok)(context.scope instanceof models_1.DeclarationReflection);\n    context.scope.typeParameters = convertTemplateParameterNodes(context, (_a = node.tags) === null || _a === void 0 ? void 0 : _a.filter(ts.isJSDocTemplateTag));\n}\nfunction convertTemplateParameterNodes(context, nodes) {\n    const params = (0, array_1.flatMap)(nodes !== null && nodes !== void 0 ? nodes : [], (tag) => tag.typeParameters);\n    return (0, signature_1.convertTypeParameterNodes)(context, params);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHeritageTypes = exports.isNamedNode = void 0;\nconst ts = require(\"typescript\");\nconst array_1 = require(\"../../utils/array\");\nfunction isNamedNode(node) {\n    const name = node.name;\n    return (!!name &&\n        (ts.isIdentifierOrPrivateIdentifier(name) ||\n            ts.isComputedPropertyName(name)));\n}\nexports.isNamedNode = isNamedNode;\nfunction getHeritageTypes(declarations, kind) {\n    const exprs = (0, array_1.flatMap)(declarations, (d) => {\n        var _a, _b;\n        return (0, array_1.flatMap)((_b = (_a = d.heritageClauses) === null || _a === void 0 ? void 0 : _a.filter((hc) => hc.token === kind)) !== null && _b !== void 0 ? _b : [], (hc) => hc.types);\n    });\n    const seenTexts = new Set();\n    return exprs.filter((expr) => {\n        const text = expr.getText();\n        if (seenTexts.has(text)) {\n            return false;\n        }\n        seenTexts.add(text);\n        return true;\n    });\n}\nexports.getHeritageTypes = getHeritageTypes;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nicePath = exports.matchesAny = exports.createMinimatch = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst path_1 = require(\"path\");\nconst fs_1 = require(\"./fs\");\n/**\n * Convert array of glob patterns to array of minimatch instances.\n *\n * Handle a few Windows-Unix path gotchas.\n */\nfunction createMinimatch(patterns) {\n    return patterns.map((pattern) => new minimatch_1.Minimatch((0, fs_1.normalizePath)(pattern).replace(/^\\w:\\//, \"\"), {\n        dot: true,\n    }));\n}\nexports.createMinimatch = createMinimatch;\nfunction matchesAny(patterns, path) {\n    const normPath = (0, fs_1.normalizePath)(path).replace(/^\\w:\\//, \"\");\n    return patterns.some((pat) => pat.match(normPath));\n}\nexports.matchesAny = matchesAny;\nfunction nicePath(absPath) {\n    const relativePath = (0, path_1.relative)(process.cwd(), absPath);\n    if (relativePath.startsWith(\"..\")) {\n        return (0, fs_1.normalizePath)(absPath);\n    }\n    return `./${(0, fs_1.normalizePath)(relativePath)}`;\n}\nexports.nicePath = nicePath;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveAliasedSymbol = void 0;\nconst ts = require(\"typescript\");\nfunction resolveAliasedSymbol(symbol, checker) {\n    while (ts.SymbolFlags.Alias & symbol.flags) {\n        symbol = checker.getAliasedSymbol(symbol);\n    }\n    return symbol;\n}\nexports.resolveAliasedSymbol = resolveAliasedSymbol;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InheritDocPlugin = exports.TypePlugin = exports.SourcePlugin = exports.PackagePlugin = exports.ImplementsPlugin = exports.GroupPlugin = exports.SourceLinkPlugin = exports.DecoratorPlugin = exports.CommentPlugin = exports.CategoryPlugin = void 0;\nvar CategoryPlugin_1 = require(\"./CategoryPlugin\");\nObject.defineProperty(exports, \"CategoryPlugin\", { enumerable: true, get: function () { return CategoryPlugin_1.CategoryPlugin; } });\nvar CommentPlugin_1 = require(\"./CommentPlugin\");\nObject.defineProperty(exports, \"CommentPlugin\", { enumerable: true, get: function () { return CommentPlugin_1.CommentPlugin; } });\nvar DecoratorPlugin_1 = require(\"./DecoratorPlugin\");\nObject.defineProperty(exports, \"DecoratorPlugin\", { enumerable: true, get: function () { return DecoratorPlugin_1.DecoratorPlugin; } });\nvar SourceLinkPlugin_1 = require(\"./SourceLinkPlugin\");\nObject.defineProperty(exports, \"SourceLinkPlugin\", { enumerable: true, get: function () { return SourceLinkPlugin_1.SourceLinkPlugin; } });\nvar GroupPlugin_1 = require(\"./GroupPlugin\");\nObject.defineProperty(exports, \"GroupPlugin\", { enumerable: true, get: function () { return GroupPlugin_1.GroupPlugin; } });\nvar ImplementsPlugin_1 = require(\"./ImplementsPlugin\");\nObject.defineProperty(exports, \"ImplementsPlugin\", { enumerable: true, get: function () { return ImplementsPlugin_1.ImplementsPlugin; } });\nvar PackagePlugin_1 = require(\"./PackagePlugin\");\nObject.defineProperty(exports, \"PackagePlugin\", { enumerable: true, get: function () { return PackagePlugin_1.PackagePlugin; } });\nvar SourcePlugin_1 = require(\"./SourcePlugin\");\nObject.defineProperty(exports, \"SourcePlugin\", { enumerable: true, get: function () { return SourcePlugin_1.SourcePlugin; } });\nvar TypePlugin_1 = require(\"./TypePlugin\");\nObject.defineProperty(exports, \"TypePlugin\", { enumerable: true, get: function () { return TypePlugin_1.TypePlugin; } });\nvar InheritDocPlugin_1 = require(\"./InheritDocPlugin\");\nObject.defineProperty(exports, \"InheritDocPlugin\", { enumerable: true, get: function () { return InheritDocPlugin_1.InheritDocPlugin; } });\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar CategoryPlugin_1;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CategoryPlugin = void 0;\nconst models_1 = require(\"../../models\");\nconst models_2 = require(\"../../models\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\nconst utils_1 = require(\"../../utils\");\n/**\n * A handler that sorts and categorizes the found reflections in the resolving phase.\n *\n * The handler sets the category property of all reflections.\n */\nlet CategoryPlugin = CategoryPlugin_1 = class CategoryPlugin extends components_1.ConverterComponent {\n    /**\n     * Create a new CategoryPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_BEGIN]: this.onBegin,\n            [converter_1.Converter.EVENT_RESOLVE]: this.onResolve,\n            [converter_1.Converter.EVENT_RESOLVE_END]: this.onEndResolve,\n        }, undefined, -200);\n    }\n    /**\n     * Triggered when the converter begins converting a project.\n     */\n    onBegin(_context) {\n        // Set up static properties\n        if (this.defaultCategory) {\n            CategoryPlugin_1.defaultCategory = this.defaultCategory;\n        }\n        if (this.categoryOrder) {\n            CategoryPlugin_1.WEIGHTS = this.categoryOrder;\n        }\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(context, reflection) {\n        var _a, _b;\n        if (reflection instanceof models_1.ContainerReflection) {\n            this.categorize(reflection, (_b = (_a = context.getSearchOptions()) === null || _a === void 0 ? void 0 : _a.searchCategoryBoosts) !== null && _b !== void 0 ? _b : {});\n        }\n    }\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onEndResolve(context) {\n        var _a, _b;\n        const project = context.project;\n        this.categorize(project, (_b = (_a = context.getSearchOptions()) === null || _a === void 0 ? void 0 : _a.searchCategoryBoosts) !== null && _b !== void 0 ? _b : {});\n    }\n    categorize(obj, categorySearchBoosts) {\n        if (this.categorizeByGroup) {\n            this.groupCategorize(obj, categorySearchBoosts);\n        }\n        else {\n            CategoryPlugin_1.lumpCategorize(obj, categorySearchBoosts);\n        }\n    }\n    groupCategorize(obj, categorySearchBoosts) {\n        if (!obj.groups || obj.groups.length === 0) {\n            return;\n        }\n        obj.groups.forEach((group) => {\n            if (group.categories)\n                return;\n            group.categories = CategoryPlugin_1.getReflectionCategories(group.children, categorySearchBoosts);\n            if (group.categories && group.categories.length > 1) {\n                group.categories.sort(CategoryPlugin_1.sortCatCallback);\n            }\n            else if (group.categories.length === 1 &&\n                group.categories[0].title === CategoryPlugin_1.defaultCategory) {\n                // no categories if everything is uncategorized\n                group.categories = undefined;\n            }\n        });\n    }\n    static lumpCategorize(obj, categorySearchBoosts) {\n        if (!obj.children || obj.children.length === 0 || obj.categories) {\n            return;\n        }\n        obj.categories = CategoryPlugin_1.getReflectionCategories(obj.children, categorySearchBoosts);\n        if (obj.categories && obj.categories.length > 1) {\n            obj.categories.sort(CategoryPlugin_1.sortCatCallback);\n        }\n        else if (obj.categories.length === 1 &&\n            obj.categories[0].title === CategoryPlugin_1.defaultCategory) {\n            // no categories if everything is uncategorized\n            obj.categories = undefined;\n        }\n    }\n    /**\n     * Create a categorized representation of the given list of reflections.\n     *\n     * @param reflections  The reflections that should be categorized.\n     * @param categorySearchBoosts A user-supplied map of category titles, for computing a\n     *   relevance boost to be used when searching\n     * @returns An array containing all children of the given reflection categorized\n     */\n    static getReflectionCategories(reflections, categorySearchBoosts) {\n        const categories = [];\n        let defaultCat;\n        reflections.forEach((child) => {\n            var _a, _b;\n            const childCategories = CategoryPlugin_1.getCategories(child);\n            if (childCategories.size === 0) {\n                if (!defaultCat) {\n                    defaultCat = categories.find((category) => category.title === CategoryPlugin_1.defaultCategory);\n                    if (!defaultCat) {\n                        defaultCat = new models_2.ReflectionCategory(CategoryPlugin_1.defaultCategory);\n                        categories.push(defaultCat);\n                    }\n                }\n                defaultCat.children.push(child);\n                return;\n            }\n            for (const childCat of childCategories) {\n                let category = categories.find((cat) => cat.title === childCat);\n                const catBoost = categorySearchBoosts[(_a = category === null || category === void 0 ? void 0 : category.title) !== null && _a !== void 0 ? _a : -1];\n                if (catBoost != undefined) {\n                    child.relevanceBoost =\n                        ((_b = child.relevanceBoost) !== null && _b !== void 0 ? _b : 1) * catBoost;\n                }\n                if (category) {\n                    category.children.push(child);\n                    continue;\n                }\n                category = new models_2.ReflectionCategory(childCat);\n                category.children.push(child);\n                categories.push(category);\n            }\n        });\n        return categories;\n    }\n    /**\n     * Return the category of a given reflection.\n     *\n     * @param reflection The reflection.\n     * @returns The category the reflection belongs to\n     */\n    static getCategories(reflection) {\n        var _a, _b, _c;\n        function extractCategoryTag(comment) {\n            const categories = new Set();\n            if (!comment)\n                return categories;\n            const tags = comment.tags;\n            const commentTags = [];\n            tags.forEach((tag) => {\n                if (tag.tagName !== \"category\") {\n                    commentTags.push(tag);\n                    return;\n                }\n                const text = tag.text.trim();\n                if (!text) {\n                    return;\n                }\n                categories.add(text);\n            });\n            comment.tags = commentTags;\n            return categories;\n        }\n        let categories = new Set();\n        if (reflection.comment) {\n            categories = extractCategoryTag(reflection.comment);\n        }\n        else if (reflection.signatures) {\n            for (const sig of reflection.signatures) {\n                for (const cat of extractCategoryTag(sig.comment)) {\n                    categories.add(cat);\n                }\n            }\n        }\n        if (((_a = reflection.type) === null || _a === void 0 ? void 0 : _a.type) === \"reflection\") {\n            (_b = reflection.type.declaration.comment) === null || _b === void 0 ? void 0 : _b.removeTags(\"category\");\n            (_c = reflection.type.declaration.signatures) === null || _c === void 0 ? void 0 : _c.forEach((s) => { var _a; return (_a = s.comment) === null || _a === void 0 ? void 0 : _a.removeTags(\"category\"); });\n        }\n        return categories;\n    }\n    /**\n     * Callback used to sort categories by name.\n     *\n     * @param a The left reflection to sort.\n     * @param b The right reflection to sort.\n     * @returns The sorting weight.\n     */\n    static sortCatCallback(a, b) {\n        let aWeight = CategoryPlugin_1.WEIGHTS.indexOf(a.title);\n        let bWeight = CategoryPlugin_1.WEIGHTS.indexOf(b.title);\n        if (aWeight === -1 || bWeight === -1) {\n            let asteriskIndex = CategoryPlugin_1.WEIGHTS.indexOf(\"*\");\n            if (asteriskIndex === -1) {\n                asteriskIndex = CategoryPlugin_1.WEIGHTS.length;\n            }\n            if (aWeight === -1) {\n                aWeight = asteriskIndex;\n            }\n            if (bWeight === -1) {\n                bWeight = asteriskIndex;\n            }\n        }\n        if (aWeight === bWeight) {\n            return a.title > b.title ? 1 : -1;\n        }\n        return aWeight - bWeight;\n    }\n};\n// For use in static methods\nCategoryPlugin.defaultCategory = \"Other\";\nCategoryPlugin.WEIGHTS = [];\n__decorate([\n    (0, utils_1.BindOption)(\"defaultCategory\")\n], CategoryPlugin.prototype, \"defaultCategory\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"categoryOrder\")\n], CategoryPlugin.prototype, \"categoryOrder\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"categorizeByGroup\")\n], CategoryPlugin.prototype, \"categorizeByGroup\", void 0);\nCategoryPlugin = CategoryPlugin_1 = __decorate([\n    (0, components_1.Component)({ name: \"category\" })\n], CategoryPlugin);\nexports.CategoryPlugin = CategoryPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar CommentPlugin_1;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentPlugin = void 0;\nconst ts = require(\"typescript\");\nconst index_1 = require(\"../../models/comments/index\");\nconst index_2 = require(\"../../models/reflections/index\");\nconst components_1 = require(\"../components\");\nconst comment_1 = require(\"../factories/comment\");\nconst converter_1 = require(\"../converter\");\nconst models_1 = require(\"../../models\");\nconst utils_1 = require(\"../../utils\");\n/**\n * These tags are not useful to display in the generated documentation.\n * They should be ignored when parsing comments. Any relevant type information\n * (for JS users) will be consumed by TypeScript and need not be preserved\n * in the comment.\n *\n * Note that param/arg/argument/return/returns are not present.\n * These tags will have their type information stripped when parsing, but still\n * provide useful information for documentation.\n */\nconst TAG_BLACKLIST = [\n    \"augments\",\n    \"callback\",\n    \"class\",\n    \"constructor\",\n    \"enum\",\n    \"extends\",\n    \"this\",\n    \"type\",\n    \"typedef\",\n];\n/**\n * A handler that parses TypeDoc comments and attaches {@link Comment} instances to\n * the generated reflections.\n */\nlet CommentPlugin = CommentPlugin_1 = class CommentPlugin extends components_1.ConverterComponent {\n    /**\n     * Create a new CommentPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_CREATE_DECLARATION]: this.onDeclaration,\n            [converter_1.Converter.EVENT_CREATE_SIGNATURE]: this.onDeclaration,\n            [converter_1.Converter.EVENT_CREATE_TYPE_PARAMETER]: this.onCreateTypeParameter,\n            [converter_1.Converter.EVENT_RESOLVE_BEGIN]: this.onBeginResolve,\n            [converter_1.Converter.EVENT_RESOLVE]: this.onResolve,\n        });\n    }\n    /**\n     * Apply all comment tag modifiers to the given reflection.\n     *\n     * @param reflection  The reflection the modifiers should be applied to.\n     * @param comment  The comment that should be searched for modifiers.\n     */\n    applyModifiers(reflection, comment) {\n        var _a, _b, _c;\n        if (comment.hasTag(\"private\")) {\n            reflection.setFlag(index_2.ReflectionFlag.Private);\n            if (reflection.kindOf(index_2.ReflectionKind.CallSignature)) {\n                (_a = reflection.parent) === null || _a === void 0 ? void 0 : _a.setFlag(index_2.ReflectionFlag.Private);\n            }\n            comment.removeTags(\"private\");\n        }\n        if (comment.hasTag(\"protected\")) {\n            reflection.setFlag(index_2.ReflectionFlag.Protected);\n            if (reflection.kindOf(index_2.ReflectionKind.CallSignature)) {\n                (_b = reflection.parent) === null || _b === void 0 ? void 0 : _b.setFlag(index_2.ReflectionFlag.Protected);\n            }\n            comment.removeTags(\"protected\");\n        }\n        if (comment.hasTag(\"public\")) {\n            reflection.setFlag(index_2.ReflectionFlag.Public);\n            if (reflection.kindOf(index_2.ReflectionKind.CallSignature)) {\n                (_c = reflection.parent) === null || _c === void 0 ? void 0 : _c.setFlag(index_2.ReflectionFlag.Public);\n            }\n            comment.removeTags(\"public\");\n        }\n        if (comment.hasTag(\"event\")) {\n            if (reflection.kindOf(index_2.ReflectionKind.CallSignature)) {\n                if (reflection.parent) {\n                    reflection.parent.kind = index_2.ReflectionKind.Event;\n                }\n            }\n            reflection.kind = index_2.ReflectionKind.Event;\n            comment.removeTags(\"event\");\n        }\n        if (reflection.kindOf(index_2.ReflectionKind.Module | index_2.ReflectionKind.Namespace) ||\n            reflection.kind === index_2.ReflectionKind.Project) {\n            comment.removeTags(\"module\");\n            comment.removeTags(\"packagedocumentation\");\n        }\n    }\n    /**\n     * Triggered when the converter has created a type parameter reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     */\n    onCreateTypeParameter(_context, reflection, node) {\n        if (node && ts.isJSDocTemplateTag(node.parent)) {\n            const comment = (0, comment_1.getJsDocCommentText)(node.parent.comment);\n            if (comment) {\n                reflection.comment = new index_1.Comment(comment);\n            }\n        }\n        const comment = reflection.parent && reflection.parent.comment;\n        if (comment) {\n            let tag = comment.getTag(\"typeparam\", reflection.name);\n            if (!tag) {\n                tag = comment.getTag(\"template\", reflection.name);\n            }\n            if (!tag) {\n                tag = comment.getTag(\"param\", `<${reflection.name}>`);\n            }\n            if (!tag) {\n                tag = comment.getTag(\"param\", reflection.name);\n            }\n            if (tag) {\n                reflection.comment = new index_1.Comment(tag.text);\n                (0, utils_1.removeIfPresent)(comment.tags, tag);\n            }\n        }\n    }\n    /**\n     * Triggered when the converter has created a declaration or signature reflection.\n     *\n     * Invokes the comment parser.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    onDeclaration(context, reflection, node) {\n        var _a, _b;\n        if (reflection.kindOf(index_2.ReflectionKind.FunctionOrMethod | index_2.ReflectionKind.Constructor)) {\n            // We only want a comment on functions/methods if this is a set of overloaded functions.\n            // In that case, TypeDoc lets you put a comment on the implementation, and will copy it over to\n            // the available signatures so that you can avoid documenting things multiple times.\n            // Once TypeDoc has proper support for TSDoc, this will go away since the same thing will be\n            // possible by using a @inheritDoc tag to specify that docs should be copied from a specific signature.\n            let specialOverloadCase = false;\n            if (node &&\n                (ts.isFunctionDeclaration(node) ||\n                    ts.isMethodDeclaration(node) ||\n                    ts.isConstructorDeclaration(node))) {\n                const symbol = node.name && context.checker.getSymbolAtLocation(node.name);\n                if (symbol && symbol.declarations) {\n                    const declarations = symbol.declarations.filter((d) => ts.isFunctionDeclaration(d) ||\n                        ts.isMethodDeclaration(d) ||\n                        ts.isConstructorDeclaration(d));\n                    if (declarations.length > 1 &&\n                        \"body\" in declarations[declarations.length - 1]) {\n                        node = declarations[declarations.length - 1];\n                        specialOverloadCase = true;\n                    }\n                }\n            }\n            if (!specialOverloadCase)\n                return;\n        }\n        // Clean this up in 0.23. We should really accept a ts.Symbol so we don't need exportSymbol on Context\n        const exportNode = (_b = (_a = context.exportSymbol) === null || _a === void 0 ? void 0 : _a.getDeclarations()) === null || _b === void 0 ? void 0 : _b[0];\n        let rawComment = exportNode && (0, comment_1.getRawComment)(exportNode, this.application.logger);\n        rawComment !== null && rawComment !== void 0 ? rawComment : (rawComment = node && (0, comment_1.getRawComment)(node, this.application.logger));\n        if (!rawComment) {\n            return;\n        }\n        const comment = (0, comment_1.parseComment)(rawComment, reflection.comment);\n        if (reflection.kindOf(index_2.ReflectionKind.Module)) {\n            const tag = comment.getTag(\"module\");\n            if (tag) {\n                // If no name is specified, this is a flag to mark a comment as a module comment\n                // and should not result in a reflection rename.\n                const newName = tag.text.trim();\n                if (newName.length) {\n                    reflection.name = newName;\n                }\n                (0, utils_1.removeIfPresent)(comment.tags, tag);\n            }\n        }\n        this.applyModifiers(reflection, comment);\n        this.removeExcludedTags(comment);\n        reflection.comment = comment;\n    }\n    /**\n     * Triggered when the converter begins resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onBeginResolve(context) {\n        const excludeInternal = this.application.options.getValue(\"excludeInternal\");\n        const excludePrivate = this.application.options.getValue(\"excludePrivate\");\n        const excludeProtected = this.application.options.getValue(\"excludeProtected\");\n        const project = context.project;\n        const reflections = Object.values(project.reflections);\n        // Remove hidden reflections\n        const hidden = reflections.filter((reflection) => CommentPlugin_1.isHidden(reflection, excludeInternal, excludePrivate, excludeProtected));\n        hidden.forEach((reflection) => project.removeReflection(reflection));\n        // remove functions with empty signatures after their signatures have been removed\n        const [allRemoved, someRemoved] = (0, utils_1.partition)((0, utils_1.filterMap)(hidden, (reflection) => {\n            var _a;\n            return ((_a = reflection.parent) === null || _a === void 0 ? void 0 : _a.kindOf(index_2.ReflectionKind.FunctionOrMethod | index_2.ReflectionKind.Constructor))\n                ? reflection.parent\n                : void 0;\n        }), (method) => { var _a; return ((_a = method.signatures) === null || _a === void 0 ? void 0 : _a.length) === 0; });\n        allRemoved.forEach((reflection) => {\n            project.removeReflection(reflection);\n        });\n        someRemoved.forEach((reflection) => {\n            reflection.sources = (0, utils_1.unique)(reflection.signatures.reduce((c, s) => c.concat(s.sources || []), []));\n        });\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * Cleans up comment tags related to signatures like @param or @return\n     * and moves their data to the corresponding parameter reflections.\n     *\n     * This hook also copies over the comment of function implementations to their\n     * signatures.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(_context, reflection) {\n        if (!(reflection instanceof index_2.DeclarationReflection)) {\n            return;\n        }\n        if (reflection.type instanceof models_1.ReflectionType) {\n            this.addCommentToSignatures(reflection, reflection.type.declaration.getNonIndexSignatures());\n        }\n        else {\n            this.addCommentToSignatures(reflection, reflection.getNonIndexSignatures());\n        }\n    }\n    addCommentToSignatures(reflection, signatures) {\n        if (!signatures.length) {\n            return;\n        }\n        const comment = reflection.comment;\n        if (comment && comment.hasTag(\"returns\")) {\n            comment.returns = comment.getTag(\"returns\").text;\n            comment.removeTags(\"returns\");\n        }\n        signatures.forEach((signature) => {\n            var _a, _b;\n            let childComment = signature.comment;\n            if (childComment && childComment.hasTag(\"returns\")) {\n                childComment.returns = childComment.getTag(\"returns\").text;\n                childComment.removeTags(\"returns\");\n            }\n            if (comment) {\n                if (!childComment) {\n                    childComment = signature.comment = new index_1.Comment();\n                }\n                childComment.shortText || (childComment.shortText = comment.shortText);\n                childComment.text || (childComment.text = comment.text);\n                childComment.returns || (childComment.returns = comment.returns);\n                childComment.tags = childComment.tags.length\n                    ? childComment.tags\n                    : [...comment.tags];\n            }\n            (_a = signature.parameters) === null || _a === void 0 ? void 0 : _a.forEach((parameter, index) => {\n                var _a;\n                let tag;\n                if (childComment && parameter.name === \"__namedParameters\") {\n                    const commentParams = childComment === null || childComment === void 0 ? void 0 : childComment.tags.filter((tag) => tag.tagName === \"param\" &&\n                        !tag.paramName.includes(\".\"));\n                    if (((_a = signature.parameters) === null || _a === void 0 ? void 0 : _a.length) === commentParams.length &&\n                        commentParams[index].paramName) {\n                        parameter.name = commentParams[index].paramName;\n                    }\n                }\n                if (childComment) {\n                    moveNestedParamTags(childComment, parameter);\n                    tag = childComment.getTag(\"param\", parameter.name);\n                }\n                if (comment && !tag) {\n                    tag = comment.getTag(\"param\", parameter.name);\n                }\n                if (tag) {\n                    parameter.comment = new index_1.Comment(tag.text);\n                }\n            });\n            (_b = signature.typeParameters) === null || _b === void 0 ? void 0 : _b.forEach((parameter) => {\n                let tag;\n                if (childComment) {\n                    tag =\n                        childComment.getTag(\"typeparam\", parameter.name) ||\n                            childComment.getTag(\"template\", parameter.name) ||\n                            childComment.getTag(\"param\", `<${parameter.name}>`);\n                }\n                if (comment && !tag) {\n                    tag =\n                        comment.getTag(\"typeparam\", parameter.name) ||\n                            comment.getTag(\"template\", parameter.name) ||\n                            comment.getTag(\"param\", `<${parameter.name}>`);\n                }\n                if (tag) {\n                    parameter.comment = new index_1.Comment(tag.text);\n                }\n            });\n            childComment === null || childComment === void 0 ? void 0 : childComment.removeTags(\"param\");\n            childComment === null || childComment === void 0 ? void 0 : childComment.removeTags(\"typeparam\");\n            childComment === null || childComment === void 0 ? void 0 : childComment.removeTags(\"template\");\n        });\n        delete reflection.comment;\n    }\n    removeExcludedTags(comment) {\n        for (const tag of TAG_BLACKLIST) {\n            comment.removeTags(tag);\n        }\n        for (const tag of this.excludeTags) {\n            comment.removeTags(tag);\n        }\n    }\n    /**\n     * Determines whether or not a reflection has been hidden\n     *\n     * @param reflection Reflection to check if hidden\n     */\n    static isHidden(reflection, excludeInternal, excludePrivate, excludeProtected) {\n        const comment = reflection.comment;\n        if (reflection.flags.hasFlag(index_2.ReflectionFlag.Private) &&\n            excludePrivate) {\n            return true;\n        }\n        if (reflection.flags.hasFlag(index_2.ReflectionFlag.Protected) &&\n            excludeProtected) {\n            return true;\n        }\n        if (!comment) {\n            return false;\n        }\n        return (comment.hasTag(\"hidden\") ||\n            comment.hasTag(\"ignore\") ||\n            (comment.hasTag(\"internal\") && excludeInternal));\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"excludeTags\")\n], CommentPlugin.prototype, \"excludeTags\", void 0);\nCommentPlugin = CommentPlugin_1 = __decorate([\n    (0, components_1.Component)({ name: \"comment\" })\n], CommentPlugin);\nexports.CommentPlugin = CommentPlugin;\n// Moves tags like `@param foo.bar docs for bar` into the `bar` property of the `foo` parameter.\nfunction moveNestedParamTags(comment, parameter) {\n    var _a;\n    const visitor = {\n        reflection(target) {\n            const tags = comment.tags.filter((t) => t.tagName === \"param\" &&\n                t.paramName.startsWith(`${parameter.name}.`));\n            for (const tag of tags) {\n                const path = tag.paramName.split(\".\");\n                path.shift();\n                const child = target.declaration.getChildByName(path);\n                if (child && !child.comment) {\n                    child.comment = new index_1.Comment(tag.text);\n                }\n            }\n        },\n        // #1876, also do this for unions/intersections.\n        union(u) {\n            u.types.forEach((t) => t.visit(visitor));\n        },\n        intersection(i) {\n            i.types.forEach((t) => t.visit(visitor));\n        },\n    };\n    (_a = parameter.type) === null || _a === void 0 ? void 0 : _a.visit(visitor);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseComment = exports.getRawComment = exports.getJsDocCommentText = void 0;\nconst ts = require(\"typescript\");\nconst index_1 = require(\"../../models/comments/index\");\n/**\n * Check whether the given module declaration is the topmost.\n *\n * This function returns TRUE if there is no trailing module defined, in\n * the following example this would be the case only for module <code>C</code>.\n *\n * ```\n * module A.B.C { }\n * ```\n *\n * @param node  The module definition that should be tested.\n * @return TRUE if the given node is the topmost module declaration, FALSE otherwise.\n */\nfunction isTopmostModuleDeclaration(node) {\n    return node.getChildren().some(ts.isModuleBlock);\n}\n/**\n * Return the root module declaration of the given module declaration.\n *\n * In the following example this function would always return module\n * <code>A</code> no matter which of the modules was passed in.\n *\n * ```\n * module A.B.C { }\n * ```\n */\nfunction getRootModuleDeclaration(node) {\n    while (node.parent &&\n        node.parent.kind === ts.SyntaxKind.ModuleDeclaration) {\n        const parent = node.parent;\n        if (node.name.pos === parent.name.end + 1) {\n            node = parent;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\n * Derived from the internal ts utility\n * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L954\n * @param node\n * @param text\n */\nfunction getJSDocCommentRanges(node, text) {\n    var _a, _b;\n    const hasTrailingCommentRanges = [\n        ts.SyntaxKind.Parameter,\n        ts.SyntaxKind.FunctionExpression,\n        ts.SyntaxKind.ArrowFunction,\n        ts.SyntaxKind.ParenthesizedExpression,\n    ].includes(node.kind);\n    let commentRanges = (_a = ts.getLeadingCommentRanges(text, node.pos)) !== null && _a !== void 0 ? _a : [];\n    if (hasTrailingCommentRanges) {\n        commentRanges = ((_b = ts.getTrailingCommentRanges(text, node.pos)) !== null && _b !== void 0 ? _b : []).concat(commentRanges);\n    }\n    // True if the comment starts with '/**' but not if it is '/**/'\n    return commentRanges.filter(({ pos }) => text.substr(pos, 3) === \"/**\" && text[pos + 4] !== \"/\");\n}\nfunction getJsDocCommentText(comment) {\n    if (typeof comment === \"string\") {\n        return comment;\n    }\n    return comment === null || comment === void 0 ? void 0 : comment.map((val) => val.text).join(\"\");\n}\nexports.getJsDocCommentText = getJsDocCommentText;\n/**\n * Return the raw comment string for the given node.\n *\n * @param node  The node whose comment should be resolved.\n * @returns     The raw comment string or undefined if no comment could be found.\n */\nfunction getRawComment(node, logger) {\n    var _a, _b;\n    // This happens if we are converting a JS project that has @typedef \"interfaces\"\n    // with an @property tag, a @typedef type alias, a callback with parameters, etc.\n    if (ts.isJSDocTypedefTag(node) ||\n        ts.isJSDocPropertyTag(node) ||\n        ts.isJSDocParameterTag(node) ||\n        ts.isJSDocCallbackTag(node)) {\n        // Also strip off leading dashes:\n        // @property {string} name - docs\n        return (_a = getJsDocCommentText(node.comment)) === null || _a === void 0 ? void 0 : _a.replace(/^\\s*-\\s*/, \"\");\n    }\n    if (node.parent &&\n        node.parent.kind === ts.SyntaxKind.VariableDeclarationList) {\n        node = node.parent.parent;\n    }\n    else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {\n        if (!isTopmostModuleDeclaration(node)) {\n            return;\n        }\n        else {\n            node = getRootModuleDeclaration(node);\n        }\n    }\n    else if (node.kind === ts.SyntaxKind.NamespaceExport) {\n        node = node.parent;\n    }\n    else if (node.kind === ts.SyntaxKind.ExportSpecifier) {\n        node = node.parent.parent;\n    }\n    else if (node.kind === ts.SyntaxKind.FunctionType) {\n        node = node.parent;\n    }\n    const sourceFile = node.getSourceFile();\n    const comments = getJSDocCommentRanges(node, sourceFile.text);\n    if (comments.length) {\n        let comment;\n        if (node.kind === ts.SyntaxKind.SourceFile) {\n            const explicitPackageComment = (_b = comments.find((comment) => sourceFile.text\n                .substring(comment.pos, comment.end)\n                .includes(\"@module\"))) !== null && _b !== void 0 ? _b : comments.find((comment) => sourceFile.text\n                .substring(comment.pos, comment.end)\n                .includes(\"@packageDocumentation\"));\n            if (explicitPackageComment) {\n                comment = explicitPackageComment;\n            }\n            else if (comments.length > 1) {\n                // Legacy behavior, require more than one comment and use the first comment.\n                comment = comments[0];\n                logger.deprecated(`Specifying multiple comments at the start of a file to use the first comment as the comment for the module has been deprecated. Use @module or @packageDocumentation instead.\\n\\t${sourceFile.fileName}`, false);\n            }\n            else {\n                // Single comment that may be a license comment, or no comments, bail.\n                return;\n            }\n        }\n        else {\n            comment = comments[comments.length - 1];\n            // If a non-SourceFile node comment has this tag, it should not be attached to the node\n            // as it documents the module.\n            if (sourceFile.text\n                .substring(comment.pos, comment.end)\n                .includes(\"@module\") ||\n                sourceFile.text\n                    .substring(comment.pos, comment.end)\n                    .includes(\"@packageDocumentation\")) {\n                return;\n            }\n        }\n        return sourceFile.text.substring(comment.pos, comment.end);\n    }\n    else {\n        return;\n    }\n}\nexports.getRawComment = getRawComment;\n/**\n * Parse the given doc comment string.\n *\n * @param text     The doc comment string that should be parsed.\n * @param comment  The {@link Comment} instance the parsed results should be stored into.\n * @returns        A populated {@link Comment} instance.\n */\nfunction parseComment(text, comment = new index_1.Comment()) {\n    let currentTag;\n    let shortText = 0;\n    function consumeTypeData(line) {\n        line = line.replace(/^\\{(?!@)[^}]*\\}+/, \"\");\n        line = line.replace(/^\\[[^[][^\\]]*\\]+/, \"\");\n        return line.trim();\n    }\n    function readBareLine(line) {\n        if (currentTag) {\n            currentTag.text += \"\\n\" + line;\n        }\n        else if (line === \"\" && shortText === 0) {\n            // Ignore\n        }\n        else if (line === \"\" && shortText === 1) {\n            shortText = 2;\n        }\n        else {\n            if (shortText === 2) {\n                comment.text += (comment.text === \"\" ? \"\" : \"\\n\") + line;\n            }\n            else {\n                comment.shortText +=\n                    (comment.shortText === \"\" ? \"\" : \"\\n\") + line;\n                shortText = 1;\n            }\n        }\n    }\n    function readTagLine(line, tag) {\n        let tagName = tag[1].toLowerCase();\n        let paramName;\n        line = tag[2].trim();\n        if (tagName === \"return\") {\n            tagName = \"returns\";\n        }\n        if (tagName === \"example\") {\n            line = line.replace(/<\\/?caption>/g, \"\");\n        }\n        if (tagName === \"param\" ||\n            tagName === \"typeparam\" ||\n            tagName === \"template\" ||\n            tagName === \"inheritdoc\") {\n            line = consumeTypeData(line);\n            const param = /[^\\s]+/.exec(line);\n            if (param) {\n                paramName = param[0];\n                line = line.substr(paramName.length + 1).trim();\n            }\n            line = consumeTypeData(line);\n            line = line.replace(/^-\\s+/, \"\");\n        }\n        else if (tagName === \"returns\") {\n            line = consumeTypeData(line);\n        }\n        currentTag = new index_1.CommentTag(tagName, paramName, line);\n        comment.tags.push(currentTag);\n    }\n    const CODE_FENCE = /^\\s*```(?!.*```)/;\n    let inFencedCode = false;\n    function readLine(line) {\n        line = line.replace(/^\\s*\\*? ?/, \"\");\n        const rawLine = line;\n        line = line.replace(/\\s*$/, \"\");\n        if (CODE_FENCE.test(line)) {\n            inFencedCode = !inFencedCode;\n        }\n        // Four spaces can be used to make code blocks too.\n        if (!inFencedCode && !line.startsWith(\"    \")) {\n            const tag = /^\\s*@(\\S+)(.*)$/.exec(line);\n            if (tag) {\n                return readTagLine(line, tag);\n            }\n        }\n        if (inFencedCode) {\n            // This will not include code blocks declared with four spaces\n            readBareLine(rawLine);\n        }\n        else {\n            readBareLine(line);\n        }\n    }\n    text = text.replace(/^\\s*\\/\\*+/, \"\");\n    text = text.replace(/\\*+\\/\\s*$/, \"\");\n    text.split(/\\r\\n?|\\n/).forEach(readLine);\n    return comment;\n}\nexports.parseComment = parseComment;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecoratorPlugin = void 0;\nconst ts = require(\"typescript\");\nconst types_1 = require(\"../../models/types\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\n/**\n * A plugin that detects decorators.\n */\nlet DecoratorPlugin = class DecoratorPlugin extends components_1.ConverterComponent {\n    constructor() {\n        super(...arguments);\n        this.usages = new Map();\n    }\n    /**\n     * Create a new ImplementsPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_CREATE_DECLARATION]: this.onDeclaration,\n            [converter_1.Converter.EVENT_CREATE_PARAMETER]: this.onDeclaration,\n            [converter_1.Converter.EVENT_RESOLVE]: this.onBeginResolve,\n            [converter_1.Converter.EVENT_END]: () => this.usages.clear(),\n        });\n    }\n    /**\n     * Create an object describing the arguments a decorator is set with.\n     *\n     * @param args  The arguments resolved from the decorator's call expression.\n     * @param signature  The signature definition of the decorator being used.\n     * @returns An object describing the decorator parameters,\n     */\n    extractArguments(args, signature) {\n        const result = {};\n        args.forEach((arg, index) => {\n            if (index < signature.parameters.length) {\n                const parameter = signature.parameters[index];\n                result[parameter.name] = arg.getText();\n            }\n            else {\n                if (!result[\"...\"]) {\n                    result[\"...\"] = [];\n                }\n                result[\"...\"].push(arg.getText());\n            }\n        });\n        return result;\n    }\n    /**\n     * Triggered when the converter has created a declaration or signature reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    onDeclaration(context, reflection, node) {\n        var _a;\n        (_a = node === null || node === void 0 ? void 0 : node.decorators) === null || _a === void 0 ? void 0 : _a.forEach((decorator) => {\n            var _a, _b;\n            let callExpression;\n            let identifier;\n            switch (decorator.expression.kind) {\n                case ts.SyntaxKind.Identifier:\n                    identifier = decorator.expression;\n                    break;\n                case ts.SyntaxKind.CallExpression:\n                    callExpression = decorator.expression;\n                    identifier = callExpression.expression;\n                    break;\n                default:\n                    return;\n            }\n            const info = {\n                name: identifier.getText(),\n            };\n            const type = context.checker.getTypeAtLocation(identifier);\n            if (type && type.symbol) {\n                info.type = types_1.ReferenceType.createSymbolReference(context.resolveAliasedSymbol(type.symbol), context, info.name);\n                if (callExpression && callExpression.arguments) {\n                    const signature = context.checker.getResolvedSignature(callExpression);\n                    if (signature) {\n                        info.arguments = this.extractArguments(callExpression.arguments, signature);\n                    }\n                }\n                const usages = (_a = this.usages.get(type.symbol)) !== null && _a !== void 0 ? _a : [];\n                usages.push(types_1.ReferenceType.createResolvedReference(reflection.name, reflection, context.project));\n                this.usages.set(type.symbol, usages);\n            }\n            (_b = reflection.decorators) !== null && _b !== void 0 ? _b : (reflection.decorators = []);\n            reflection.decorators.push(info);\n        });\n    }\n    onBeginResolve(context) {\n        for (const [symbol, ref] of this.usages) {\n            const reflection = context.project.getReflectionFromSymbol(symbol);\n            if (reflection) {\n                reflection.decorates = ref;\n            }\n        }\n    }\n};\nDecoratorPlugin = __decorate([\n    (0, components_1.Component)({ name: \"decorator\" })\n], DecoratorPlugin);\nexports.DecoratorPlugin = DecoratorPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceLinkPlugin = exports.Repository = void 0;\nconst Path = require(\"path\");\nconst child_process_1 = require(\"child_process\");\nconst components_1 = require(\"../components\");\nconst base_path_1 = require(\"../utils/base-path\");\nconst converter_1 = require(\"../converter\");\nconst utils_1 = require(\"../../utils\");\nconst models_1 = require(\"../../models\");\nconst TEN_MEGABYTES = 1024 * 10000;\nfunction git(...args) {\n    return (0, child_process_1.spawnSync)(\"git\", args, {\n        encoding: \"utf-8\",\n        windowsHide: true,\n        maxBuffer: TEN_MEGABYTES,\n    });\n}\n/**\n * Stores data of a repository.\n */\nclass Repository {\n    /**\n     * Create a new Repository instance.\n     *\n     * @param path  The root path of the repository.\n     */\n    constructor(path, gitRevision, repoLinks) {\n        /**\n         * A list of all files tracked by the repository.\n         */\n        this.files = [];\n        /**\n         * The hostname for this GitHub/Bitbucket/.etc project.\n         *\n         * Defaults to: `github.com` (for normal, public GitHub instance projects)\n         *\n         * Can be the hostname for an enterprise version of GitHub, e.g. `github.acme.com`\n         * (if found as a match in the list of git remotes).\n         */\n        this.hostname = \"github.com\";\n        /**\n         * Whether this is a GitHub, Bitbucket, or other type of repository.\n         */\n        this.type = models_1.RepositoryType.GitHub;\n        this.path = path;\n        this.branch = gitRevision || \"master\";\n        for (let i = 0, c = repoLinks.length; i < c; i++) {\n            let match = /(github(?:\\.[a-z]+)*\\.[a-z]{2,})[:/]([^/]+)\\/(.*)/.exec(repoLinks[i]);\n            // Github Enterprise\n            if (!match) {\n                match = /(\\w+\\.githubprivate.com)[:/]([^/]+)\\/(.*)/.exec(repoLinks[i]);\n            }\n            if (!match) {\n                match = /(bitbucket.org)[:/]([^/]+)\\/(.*)/.exec(repoLinks[i]);\n            }\n            if (!match) {\n                match = /(gitlab.com)[:/]([^/]+)\\/(.*)/.exec(repoLinks[i]);\n            }\n            if (match) {\n                this.hostname = match[1];\n                this.user = match[2];\n                this.project = match[3];\n                if (this.project.substr(-4) === \".git\") {\n                    this.project = this.project.substr(0, this.project.length - 4);\n                }\n                break;\n            }\n        }\n        if (this.hostname.includes(\"bitbucket.org\")) {\n            this.type = models_1.RepositoryType.Bitbucket;\n        }\n        else if (this.hostname.includes(\"gitlab.com\")) {\n            this.type = models_1.RepositoryType.GitLab;\n        }\n        else {\n            this.type = models_1.RepositoryType.GitHub;\n        }\n        let out = git(\"-C\", path, \"ls-files\");\n        if (out.status === 0) {\n            out.stdout.split(\"\\n\").forEach((file) => {\n                if (file !== \"\") {\n                    this.files.push(base_path_1.BasePath.normalize(path + \"/\" + file));\n                }\n            });\n        }\n        if (!gitRevision) {\n            out = git(\"-C\", path, \"rev-parse\", \"--short\", \"HEAD\");\n            if (out.status === 0) {\n                this.branch = out.stdout.replace(\"\\n\", \"\");\n            }\n        }\n    }\n    /**\n     * Check whether the given file is tracked by this repository.\n     *\n     * @param fileName  The name of the file to test for.\n     * @returns TRUE when the file is part of the repository, otherwise FALSE.\n     */\n    contains(fileName) {\n        return this.files.includes(fileName);\n    }\n    /**\n     * Get the URL of the given file on GitHub or Bitbucket.\n     *\n     * @param fileName  The file whose URL should be determined.\n     * @returns A URL pointing to the web preview of the given file or undefined.\n     */\n    getURL(fileName) {\n        if (!this.user || !this.project || !this.contains(fileName)) {\n            return;\n        }\n        return [\n            `https://${this.hostname}`,\n            this.user,\n            this.project,\n            this.type === models_1.RepositoryType.GitLab ? \"-\" : undefined,\n            this.type === models_1.RepositoryType.Bitbucket ? \"src\" : \"blob\",\n            this.branch,\n            fileName.substr(this.path.length + 1),\n        ]\n            .filter((s) => !!s)\n            .join(\"/\");\n    }\n    /**\n     * Try to create a new repository instance.\n     *\n     * Checks whether the given path is the root of a valid repository and if so\n     * creates a new instance of {@link Repository}.\n     *\n     * @param path  The potential repository root.\n     * @returns A new instance of {@link Repository} or undefined.\n     */\n    static tryCreateRepository(path, gitRevision, gitRemote) {\n        const out = git(\"-C\", path, \"rev-parse\", \"--show-toplevel\");\n        const remotesOutput = git(\"-C\", path, \"remote\", \"get-url\", gitRemote);\n        if (out.status !== 0 || remotesOutput.status !== 0) {\n            return;\n        }\n        return new Repository(base_path_1.BasePath.normalize(out.stdout.replace(\"\\n\", \"\")), gitRevision, remotesOutput.stdout.split(\"\\n\"));\n    }\n    static getLineNumberAnchor(lineNumber, repositoryType) {\n        switch (repositoryType) {\n            default:\n            case models_1.RepositoryType.GitHub:\n            case models_1.RepositoryType.GitLab:\n                return \"L\" + lineNumber;\n            case models_1.RepositoryType.Bitbucket:\n                return \"lines-\" + lineNumber;\n        }\n    }\n}\nexports.Repository = Repository;\n/**\n * A handler that watches for repositories with GitHub origin and links\n * their source files to the related GitHub pages.\n */\nlet SourceLinkPlugin = class SourceLinkPlugin extends components_1.ConverterComponent {\n    constructor() {\n        super(...arguments);\n        /**\n         * List of known repositories.\n         */\n        this.repositories = {};\n        /**\n         * List of paths known to be not under git control.\n         */\n        this.ignoredPaths = [];\n    }\n    /**\n     * Create a new GitHubHandler instance.\n     *\n     * @param converter  The converter this plugin should be attached to.\n     */\n    initialize() {\n        if (git(\"--version\").status === 0) {\n            this.listenTo(this.owner, converter_1.Converter.EVENT_RESOLVE_END, this.onEndResolve);\n        }\n    }\n    /**\n     * Check whether the given file is placed inside a repository.\n     *\n     * @param fileName  The name of the file a repository should be looked for.\n     * @returns The found repository info or undefined.\n     */\n    getRepository(fileName) {\n        // Check for known non-repositories\n        const dirName = Path.dirname(fileName);\n        for (let i = 0, c = this.ignoredPaths.length; i < c; i++) {\n            if (this.ignoredPaths[i] === dirName) {\n                return;\n            }\n        }\n        // Check for known repositories\n        for (const path of Object.keys(this.repositories)) {\n            if (fileName.substr(0, path.length).toLowerCase() === path) {\n                return this.repositories[path];\n            }\n        }\n        // Try to create a new repository\n        const repository = Repository.tryCreateRepository(dirName, this.gitRevision, this.gitRemote);\n        if (repository) {\n            this.repositories[repository.path.toLowerCase()] = repository;\n            return repository;\n        }\n        // No repository found, add path to ignored paths\n        const segments = dirName.split(\"/\");\n        for (let i = segments.length; i > 0; i--) {\n            this.ignoredPaths.push(segments.slice(0, i).join(\"/\"));\n        }\n    }\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onEndResolve(context) {\n        const project = context.project;\n        project.files.forEach((sourceFile) => {\n            const repository = this.getRepository(sourceFile.fullFileName);\n            if (repository) {\n                sourceFile.url = repository.getURL(sourceFile.fullFileName);\n                sourceFile.repositoryType = repository.type;\n            }\n        });\n        for (const key in project.reflections) {\n            const reflection = project.reflections[key];\n            if (reflection.sources) {\n                reflection.sources.forEach((source) => {\n                    if (source.file && source.file.url) {\n                        source.url =\n                            source.file.url +\n                                \"#\" +\n                                Repository.getLineNumberAnchor(source.line, source.file.repositoryType);\n                    }\n                });\n            }\n        }\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"gitRevision\")\n], SourceLinkPlugin.prototype, \"gitRevision\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"gitRemote\")\n], SourceLinkPlugin.prototype, \"gitRemote\", void 0);\nSourceLinkPlugin = __decorate([\n    (0, components_1.Component)({ name: \"source-link\" })\n], SourceLinkPlugin);\nexports.SourceLinkPlugin = SourceLinkPlugin;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasePath = void 0;\nconst Path = require(\"path\");\n/**\n * Helper class that determines the common base path of a set of files.\n *\n * In the first step all files must be passed to {@link add}. Afterwards {@link trim}\n * can be used to retrieve the shortest path relative to the determined base path.\n */\nclass BasePath {\n    constructor() {\n        /**\n         * List of known base paths.\n         */\n        this.basePaths = [];\n    }\n    /**\n     * Add the given file path to this set of base paths.\n     *\n     * @param fileName  The absolute filename that should be added to the base path.\n     */\n    add(fileName) {\n        const fileDir = Path.dirname(BasePath.normalize(fileName));\n        const filePath = fileDir.split(\"/\");\n        basePaths: for (let n = 0, c = this.basePaths.length; n < c; n++) {\n            const basePath = this.basePaths[n].split(\"/\");\n            const mMax = Math.min(basePath.length, filePath.length);\n            for (let m = 0; m < mMax; m++) {\n                if (basePath[m] === filePath[m]) {\n                    continue;\n                }\n                if (m < 1) {\n                    // No match at all, try next known base path\n                    continue basePaths;\n                }\n                else {\n                    // Partial match, trim the known base path\n                    if (m < basePath.length) {\n                        this.basePaths[n] = basePath.slice(0, m).join(\"/\");\n                    }\n                    return;\n                }\n            }\n            // Complete match, exit\n            this.basePaths[n] = basePath.splice(0, mMax).join(\"/\");\n            return;\n        }\n        // Unknown base path, add it\n        this.basePaths.push(fileDir);\n    }\n    /**\n     * Trim the given filename by the determined base paths.\n     *\n     * @param fileName  The absolute filename that should be trimmed.\n     * @returns The trimmed version of the filename.\n     */\n    trim(fileName) {\n        fileName = BasePath.normalize(fileName);\n        for (let n = 0, c = this.basePaths.length; n < c; n++) {\n            const basePath = this.basePaths[n];\n            if (fileName.substr(0, basePath.length) === basePath) {\n                return fileName.substr(basePath.length + 1);\n            }\n        }\n        return fileName;\n    }\n    /**\n     * Reset this instance, ignore all paths already passed to {@link add}.\n     */\n    reset() {\n        this.basePaths = [];\n    }\n    /**\n     * Normalize the given path.\n     *\n     * @param path  The path that should be normalized.\n     * @returns Normalized version of the given path.\n     */\n    static normalize(path) {\n        // Ensure forward slashes\n        path = path.replace(/\\\\/g, \"/\");\n        // Remove all surrounding quotes\n        path = path.replace(/^[\"']+|[\"']+$/g, \"\");\n        // Make Windows drive letters lower case\n        return path.replace(/^([^:]+):\\//, (_m, m1) => m1.toUpperCase() + \":/\");\n    }\n}\nexports.BasePath = BasePath;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar GroupPlugin_1;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GroupPlugin = void 0;\nconst index_1 = require(\"../../models/reflections/index\");\nconst ReflectionGroup_1 = require(\"../../models/ReflectionGroup\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\nconst sort_1 = require(\"../../utils/sort\");\nconst utils_1 = require(\"../../utils\");\n/**\n * A handler that sorts and groups the found reflections in the resolving phase.\n *\n * The handler sets the groups property of all reflections.\n */\nlet GroupPlugin = GroupPlugin_1 = class GroupPlugin extends components_1.ConverterComponent {\n    /**\n     * Create a new GroupPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_RESOLVE]: this.onResolve,\n            [converter_1.Converter.EVENT_RESOLVE_END]: this.onEndResolve,\n        });\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(_context, reflection) {\n        reflection.kindString = GroupPlugin_1.getKindSingular(reflection.kind);\n        if (reflection instanceof index_1.ContainerReflection) {\n            this.group(reflection);\n        }\n    }\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onEndResolve(context) {\n        function walkDirectory(directory) {\n            directory.groups = GroupPlugin_1.getReflectionGroups(directory.getAllReflections());\n            for (const dir of Object.values(directory.directories)) {\n                walkDirectory(dir);\n            }\n        }\n        const project = context.project;\n        this.group(project);\n        walkDirectory(project.directory);\n        project.files.forEach((file) => {\n            file.groups = GroupPlugin_1.getReflectionGroups(file.reflections);\n        });\n    }\n    group(reflection) {\n        if (reflection.children &&\n            reflection.children.length > 0 &&\n            !reflection.groups) {\n            (0, sort_1.sortReflections)(reflection.children, this.sortStrategies);\n            reflection.groups = GroupPlugin_1.getReflectionGroups(reflection.children);\n        }\n    }\n    /**\n     * Create a grouped representation of the given list of reflections.\n     *\n     * Reflections are grouped by kind and sorted by weight and name.\n     *\n     * @param reflections  The reflections that should be grouped.\n     * @returns An array containing all children of the given reflection grouped by their kind.\n     */\n    static getReflectionGroups(reflections) {\n        const groups = [];\n        reflections.forEach((child) => {\n            for (let i = 0; i < groups.length; i++) {\n                const group = groups[i];\n                if (group.kind !== child.kind) {\n                    continue;\n                }\n                group.children.push(child);\n                return;\n            }\n            const group = new ReflectionGroup_1.ReflectionGroup(GroupPlugin_1.getKindPlural(child.kind), child.kind);\n            group.children.push(child);\n            groups.push(group);\n        });\n        groups.forEach((group) => {\n            let allInherited = true;\n            let allPrivate = true;\n            let allProtected = true;\n            let allExternal = true;\n            group.children.forEach((child) => {\n                allPrivate = child.flags.isPrivate && allPrivate;\n                allProtected =\n                    (child.flags.isPrivate || child.flags.isProtected) &&\n                        allProtected;\n                allExternal = child.flags.isExternal && allExternal;\n                if (child instanceof index_1.DeclarationReflection) {\n                    allInherited = !!child.inheritedFrom && allInherited;\n                }\n                else {\n                    allInherited = false;\n                }\n            });\n            group.allChildrenAreInherited = allInherited;\n            group.allChildrenArePrivate = allPrivate;\n            group.allChildrenAreProtectedOrPrivate = allProtected;\n            group.allChildrenAreExternal = allExternal;\n        });\n        return groups;\n    }\n    /**\n     * Transform the internal typescript kind identifier into a human readable version.\n     *\n     * @param kind  The original typescript kind identifier.\n     * @returns A human readable version of the given typescript kind identifier.\n     */\n    static getKindString(kind) {\n        let str = index_1.ReflectionKind[kind];\n        str = str.replace(/(.)([A-Z])/g, (_m, a, b) => a + \" \" + b.toLowerCase());\n        return str;\n    }\n    /**\n     * Return the singular name of a internal typescript kind identifier.\n     *\n     * @param kind The original internal typescript kind identifier.\n     * @returns The singular name of the given internal typescript kind identifier\n     */\n    static getKindSingular(kind) {\n        if (kind in GroupPlugin_1.SINGULARS) {\n            return GroupPlugin_1.SINGULARS[kind];\n        }\n        else {\n            return GroupPlugin_1.getKindString(kind);\n        }\n    }\n    /**\n     * Return the plural name of a internal typescript kind identifier.\n     *\n     * @param kind The original internal typescript kind identifier.\n     * @returns The plural name of the given internal typescript kind identifier\n     */\n    static getKindPlural(kind) {\n        if (kind in GroupPlugin_1.PLURALS) {\n            return GroupPlugin_1.PLURALS[kind];\n        }\n        else {\n            return this.getKindString(kind) + \"s\";\n        }\n    }\n};\n/**\n * Define the singular name of individual reflection kinds.\n */\nGroupPlugin.SINGULARS = {\n    [index_1.ReflectionKind.Enum]: \"Enumeration\",\n    [index_1.ReflectionKind.EnumMember]: \"Enumeration Member\",\n};\n/**\n * Define the plural name of individual reflection kinds.\n */\nGroupPlugin.PLURALS = {\n    [index_1.ReflectionKind.Class]: \"Classes\",\n    [index_1.ReflectionKind.Property]: \"Properties\",\n    [index_1.ReflectionKind.Enum]: \"Enumerations\",\n    [index_1.ReflectionKind.EnumMember]: \"Enumeration Members\",\n    [index_1.ReflectionKind.TypeAlias]: \"Type Aliases\",\n};\n__decorate([\n    (0, utils_1.BindOption)(\"sort\")\n], GroupPlugin.prototype, \"sortStrategies\", void 0);\nGroupPlugin = GroupPlugin_1 = __decorate([\n    (0, components_1.Component)({ name: \"group\" })\n], GroupPlugin);\nexports.GroupPlugin = GroupPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImplementsPlugin = void 0;\nconst ts = require(\"typescript\");\nconst index_1 = require(\"../../models/reflections/index\");\nconst types_1 = require(\"../../models/types\");\nconst array_1 = require(\"../../utils/array\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\nconst reflections_1 = require(\"../utils/reflections\");\n/**\n * A plugin that detects interface implementations of functions and\n * properties on classes and links them.\n */\nlet ImplementsPlugin = class ImplementsPlugin extends components_1.ConverterComponent {\n    constructor() {\n        super(...arguments);\n        this.resolved = new WeakSet();\n        this.postponed = new WeakMap();\n    }\n    /**\n     * Create a new ImplementsPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, converter_1.Converter.EVENT_RESOLVE, this.onResolve, -10);\n        this.listenTo(this.owner, converter_1.Converter.EVENT_CREATE_DECLARATION, this.onDeclaration, -1000);\n        this.listenTo(this.owner, converter_1.Converter.EVENT_CREATE_SIGNATURE, this.onSignature, 1000);\n    }\n    /**\n     * Mark all members of the given class to be the implementation of the matching interface member.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param classReflection  The reflection of the classReflection class.\n     * @param interfaceReflection  The reflection of the interfaceReflection interface.\n     */\n    analyzeClass(context, classReflection, interfaceReflection) {\n        if (!interfaceReflection.children) {\n            return;\n        }\n        interfaceReflection.children.forEach((interfaceMember) => {\n            let classMember;\n            if (!classReflection.children) {\n                return;\n            }\n            for (let index = 0, count = classReflection.children.length; index < count; index++) {\n                const child = classReflection.children[index];\n                if (child.name !== interfaceMember.name) {\n                    continue;\n                }\n                if (child.flags.isStatic !== interfaceMember.flags.isStatic) {\n                    continue;\n                }\n                classMember = child;\n                break;\n            }\n            if (!classMember) {\n                return;\n            }\n            const interfaceMemberName = interfaceReflection.name + \".\" + interfaceMember.name;\n            classMember.implementationOf =\n                types_1.ReferenceType.createResolvedReference(interfaceMemberName, interfaceMember, context.project);\n            (0, reflections_1.copyComment)(classMember, interfaceMember);\n            if (interfaceMember.kindOf(index_1.ReflectionKind.Property) &&\n                classMember.kindOf(index_1.ReflectionKind.Accessor)) {\n                if (classMember.getSignature) {\n                    (0, reflections_1.copyComment)(classMember.getSignature, interfaceMember);\n                    classMember.getSignature.implementationOf =\n                        classMember.implementationOf;\n                }\n                if (classMember.setSignature) {\n                    (0, reflections_1.copyComment)(classMember.setSignature, interfaceMember);\n                    classMember.setSignature.implementationOf =\n                        classMember.implementationOf;\n                }\n            }\n            if (interfaceMember.kindOf(index_1.ReflectionKind.FunctionOrMethod) &&\n                interfaceMember.signatures &&\n                classMember.signatures) {\n                for (const [clsSig, intSig] of (0, array_1.zip)(classMember.signatures, interfaceMember.signatures)) {\n                    if (clsSig.implementationOf) {\n                        clsSig.implementationOf =\n                            types_1.ReferenceType.createResolvedReference(clsSig.implementationOf.name, intSig, context.project);\n                    }\n                    (0, reflections_1.copyComment)(clsSig, intSig);\n                }\n            }\n        });\n    }\n    analyzeInheritance(context, reflection) {\n        var _a, _b, _c, _d, _e;\n        const extendedTypes = (0, array_1.filterMap)((_a = reflection.extendedTypes) !== null && _a !== void 0 ? _a : [], (type) => {\n            return type instanceof types_1.ReferenceType &&\n                type.reflection instanceof index_1.DeclarationReflection\n                ? type\n                : void 0;\n        });\n        for (const parent of extendedTypes) {\n            for (const parentMember of (_b = parent.reflection.children) !== null && _b !== void 0 ? _b : []) {\n                const child = (_c = reflection.children) === null || _c === void 0 ? void 0 : _c.find((child) => child.name == parentMember.name &&\n                    child.flags.isStatic === parentMember.flags.isStatic);\n                if (child) {\n                    const key = child.overwrites\n                        ? \"overwrites\"\n                        : \"inheritedFrom\";\n                    for (const [childSig, parentSig] of (0, array_1.zip)((_d = child.signatures) !== null && _d !== void 0 ? _d : [], (_e = parentMember.signatures) !== null && _e !== void 0 ? _e : [])) {\n                        childSig[key] = types_1.ReferenceType.createResolvedReference(`${parent.name}.${parentMember.name}`, parentSig, context.project);\n                        (0, reflections_1.copyComment)(childSig, parentSig);\n                    }\n                    child[key] = types_1.ReferenceType.createResolvedReference(`${parent.name}.${parentMember.name}`, parentMember, context.project);\n                    (0, reflections_1.copyComment)(child, parentMember);\n                }\n            }\n        }\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(context, reflection) {\n        this.tryResolve(context, reflection);\n    }\n    tryResolve(context, reflection) {\n        var _a, _b, _c, _d;\n        const requirements = (0, array_1.filterMap)([\n            ...((_a = reflection.implementedTypes) !== null && _a !== void 0 ? _a : []),\n            ...((_b = reflection.extendedTypes) !== null && _b !== void 0 ? _b : []),\n        ], (type) => {\n            return type instanceof types_1.ReferenceType ? type.reflection : void 0;\n        });\n        if (requirements.every((req) => this.resolved.has(req))) {\n            this.doResolve(context, reflection);\n            this.resolved.add(reflection);\n            for (const refl of (_c = this.postponed.get(reflection)) !== null && _c !== void 0 ? _c : []) {\n                this.tryResolve(context, refl);\n            }\n            this.postponed.delete(reflection);\n        }\n        else {\n            for (const req of requirements) {\n                const future = (_d = this.postponed.get(req)) !== null && _d !== void 0 ? _d : new Set();\n                future.add(reflection);\n                this.postponed.set(req, future);\n            }\n        }\n    }\n    doResolve(context, reflection) {\n        if (reflection.kindOf(index_1.ReflectionKind.Class) &&\n            reflection.implementedTypes) {\n            reflection.implementedTypes.forEach((type) => {\n                if (!(type instanceof types_1.ReferenceType)) {\n                    return;\n                }\n                if (type.reflection &&\n                    type.reflection.kindOf(index_1.ReflectionKind.Interface)) {\n                    this.analyzeClass(context, reflection, type.reflection);\n                }\n            });\n        }\n        if (reflection.kindOf([\n            index_1.ReflectionKind.Class,\n            index_1.ReflectionKind.Interface,\n        ]) &&\n            reflection.extendedTypes) {\n            this.analyzeInheritance(context, reflection);\n        }\n    }\n    getExtensionInfo(context, reflection) {\n        var _a;\n        if (!reflection || !reflection.kindOf(index_1.ReflectionKind.Inheritable)) {\n            return;\n        }\n        // Need this because we re-use reflections for type literals.\n        if (!reflection.parent ||\n            !reflection.parent.kindOf(index_1.ReflectionKind.ClassOrInterface)) {\n            return;\n        }\n        const symbol = context.project.getSymbolFromReflection(reflection.parent);\n        if (!symbol) {\n            return;\n        }\n        const declaration = (_a = symbol\n            .getDeclarations()) === null || _a === void 0 ? void 0 : _a.find((n) => ts.isClassDeclaration(n) || ts.isInterfaceDeclaration(n));\n        if (!declaration) {\n            return;\n        }\n        return { symbol, declaration };\n    }\n    onSignature(context, reflection) {\n        this.onDeclaration(context, reflection.parent);\n    }\n    /**\n     * Responsible for setting the {@link DeclarationReflection.inheritedFrom},\n     * {@link DeclarationReflection.overwrites}, and {@link DeclarationReflection.implementationOf}\n     * properties on the provided reflection temporarily, these links will be replaced\n     * during the resolve step with links which actually point to the right place.\n     */\n    onDeclaration(context, reflection) {\n        var _a, _b, _c, _d, _e;\n        const info = this.getExtensionInfo(context, reflection);\n        if (!info) {\n            return;\n        }\n        if (reflection.kind === index_1.ReflectionKind.Constructor) {\n            const ctor = info.declaration.members.find(ts.isConstructorDeclaration);\n            constructorInheritance(context, reflection, info.declaration, ctor);\n            return;\n        }\n        const childType = reflection.flags.isStatic\n            ? context.checker.getTypeOfSymbolAtLocation(info.symbol, info.declaration)\n            : context.checker.getDeclaredTypeOfSymbol(info.symbol);\n        const property = findProperty(reflection, childType);\n        if (!property) {\n            // We're probably broken... but I don't think this should be fatal.\n            context.logger.warn(`Failed to retrieve${reflection.flags.isStatic ? \" static\" : \"\"} member \"${(_a = reflection.escapedName) !== null && _a !== void 0 ? _a : reflection.name}\" of \"${(_b = reflection.parent) === null || _b === void 0 ? void 0 : _b.name}\" for inheritance analysis. Please report a bug.`);\n            return;\n        }\n        // Need to check both extends and implements clauses.\n        out: for (const clause of (_c = info.declaration.heritageClauses) !== null && _c !== void 0 ? _c : []) {\n            // No point checking implemented types for static members, they won't exist.\n            if (reflection.flags.isStatic &&\n                clause.token === ts.SyntaxKind.ImplementsKeyword) {\n                continue;\n            }\n            for (const expr of clause.types) {\n                const parentType = context.checker.getTypeAtLocation(reflection.flags.isStatic ? expr.expression : expr);\n                const parentProperty = findProperty(reflection, parentType);\n                if (parentProperty) {\n                    const isInherit = (_e = (_d = property\n                        .getDeclarations()) === null || _d === void 0 ? void 0 : _d.some((d) => d.parent !== info.declaration)) !== null && _e !== void 0 ? _e : true;\n                    createLink(context, reflection, clause, expr, parentProperty, isInherit);\n                    // Can't always break because we need to also set `implementationOf` if we\n                    // inherit from a base class and also implement an interface.\n                    if (clause.token === ts.SyntaxKind.ImplementsKeyword) {\n                        break out;\n                    }\n                }\n            }\n        }\n    }\n};\nImplementsPlugin = __decorate([\n    (0, components_1.Component)({ name: \"implements\" })\n], ImplementsPlugin);\nexports.ImplementsPlugin = ImplementsPlugin;\nfunction constructorInheritance(context, reflection, childDecl, constructorDecl) {\n    var _a, _b, _c, _d;\n    const extendsClause = (_a = childDecl.heritageClauses) === null || _a === void 0 ? void 0 : _a.find((cl) => cl.token === ts.SyntaxKind.ExtendsKeyword);\n    if (!extendsClause)\n        return;\n    const name = `${extendsClause.types[0].getText()}.constructor`;\n    const key = constructorDecl ? \"overwrites\" : \"inheritedFrom\";\n    (_b = reflection[key]) !== null && _b !== void 0 ? _b : (reflection[key] = types_1.ReferenceType.createBrokenReference(name, context.project));\n    for (const sig of (_c = reflection.signatures) !== null && _c !== void 0 ? _c : []) {\n        (_d = sig[key]) !== null && _d !== void 0 ? _d : (sig[key] = types_1.ReferenceType.createBrokenReference(name, context.project));\n    }\n}\nfunction findProperty(reflection, parent) {\n    return parent.getProperties().find((prop) => {\n        return reflection.escapedName\n            ? prop.escapedName === reflection.escapedName\n            : prop.name === reflection.escapedName;\n    });\n}\nfunction createLink(context, reflection, clause, expr, symbol, isOverwrite) {\n    var _a;\n    const project = context.project;\n    const name = `${expr.expression.getText()}.${symbol.name}`;\n    link(reflection);\n    link(reflection.getSignature);\n    link(reflection.setSignature);\n    link(reflection.indexSignature);\n    for (const sig of (_a = reflection.signatures) !== null && _a !== void 0 ? _a : []) {\n        link(sig);\n    }\n    // Intentionally create broken links here. These will be replaced with real links during\n    // resolution if we can do so.\n    function link(target) {\n        var _a, _b, _c;\n        if (!target)\n            return;\n        if (clause.token === ts.SyntaxKind.ImplementsKeyword) {\n            (_a = target.implementationOf) !== null && _a !== void 0 ? _a : (target.implementationOf = types_1.ReferenceType.createBrokenReference(name, project));\n            return;\n        }\n        if (isOverwrite) {\n            (_b = target.inheritedFrom) !== null && _b !== void 0 ? _b : (target.inheritedFrom = types_1.ReferenceType.createBrokenReference(name, project));\n        }\n        else {\n            (_c = target.overwrites) !== null && _c !== void 0 ? _c : (target.overwrites = types_1.ReferenceType.createBrokenReference(name, project));\n        }\n    }\n}\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PackagePlugin = void 0;\nconst Path = require(\"path\");\nconst FS = require(\"fs\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\nconst utils_1 = require(\"../../utils\");\nconst fs_1 = require(\"../../utils/fs\");\nconst paths_1 = require(\"../../utils/paths\");\n/**\n * A handler that tries to find the package.json and readme.md files of the\n * current project.\n */\nlet PackagePlugin = class PackagePlugin extends components_1.ConverterComponent {\n    /**\n     * Create a new PackageHandler instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_BEGIN]: this.onBegin,\n            [converter_1.Converter.EVENT_RESOLVE_BEGIN]: this.onBeginResolve,\n            [converter_1.Converter.EVENT_END]: () => {\n                delete this.readmeFile;\n                delete this.packageFile;\n            },\n        });\n    }\n    /**\n     * Triggered when the converter begins converting a project.\n     */\n    onBegin(_context) {\n        this.readmeFile = undefined;\n        this.packageFile = undefined;\n        // Path will be resolved already. This is kind of ugly, but...\n        const noReadmeFile = this.readme.endsWith(\"none\");\n        if (!noReadmeFile && this.readme) {\n            if (FS.existsSync(this.readme)) {\n                this.readmeFile = this.readme;\n            }\n        }\n        const packageAndReadmeFound = () => (noReadmeFile || this.readmeFile) && this.packageFile;\n        const reachedTopDirectory = (dirName) => dirName === Path.resolve(Path.join(dirName, \"..\"));\n        let dirName = Path.resolve((0, fs_1.getCommonDirectory)(this.application.options.getValue(\"entryPoints\")));\n        this.application.logger.verbose(`Begin readme.md/package.json search at ${(0, paths_1.nicePath)(dirName)}`);\n        while (!packageAndReadmeFound() && !reachedTopDirectory(dirName)) {\n            FS.readdirSync(dirName).forEach((file) => {\n                const lowercaseFileName = file.toLowerCase();\n                if (!noReadmeFile &&\n                    !this.readmeFile &&\n                    lowercaseFileName === \"readme.md\") {\n                    this.readmeFile = Path.join(dirName, file);\n                }\n                if (!this.packageFile && lowercaseFileName === \"package.json\") {\n                    this.packageFile = Path.join(dirName, file);\n                }\n            });\n            dirName = Path.resolve(Path.join(dirName, \"..\"));\n        }\n    }\n    /**\n     * Triggered when the converter begins resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onBeginResolve(context) {\n        const project = context.project;\n        if (this.readmeFile) {\n            project.readme = (0, utils_1.readFile)(this.readmeFile);\n        }\n        if (this.packageFile) {\n            project.packageInfo = JSON.parse((0, utils_1.readFile)(this.packageFile));\n            if (!project.name) {\n                if (!project.packageInfo.name) {\n                    context.logger.warn('The --name option was not specified, and package.json does not have a name field. Defaulting project name to \"Documentation\".');\n                    project.name = \"Documentation\";\n                }\n                else {\n                    project.name = String(project.packageInfo.name);\n                }\n            }\n            if (this.includeVersion) {\n                if (project.packageInfo.version) {\n                    project.name = `${project.name} - v${project.packageInfo.version}`;\n                }\n                else {\n                    context.logger.warn(\"--includeVersion was specified, but package.json does not specify a version.\");\n                }\n            }\n        }\n        else {\n            if (!project.name) {\n                context.logger.warn('The --name option was not specified, and no package.json was found. Defaulting project name to \"Documentation\".');\n                project.name = \"Documentation\";\n            }\n            if (this.includeVersion) {\n                context.logger.warn(\"--includeVersion was specified, but no package.json was found. Not adding package version to the documentation.\");\n            }\n        }\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"readme\")\n], PackagePlugin.prototype, \"readme\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"includeVersion\")\n], PackagePlugin.prototype, \"includeVersion\", void 0);\nPackagePlugin = __decorate([\n    (0, components_1.Component)({ name: \"package\" })\n], PackagePlugin);\nexports.PackagePlugin = PackagePlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourcePlugin = void 0;\nconst Path = require(\"path\");\nconst ts = require(\"typescript\");\nconst index_1 = require(\"../../models/reflections/index\");\nconst index_2 = require(\"../../models/sources/index\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\nconst utils_1 = require(\"../../utils\");\nconst nodes_1 = require(\"../utils/nodes\");\nconst fs_1 = require(\"../../utils/fs\");\nconst path_1 = require(\"path\");\nconst assert = require(\"assert\");\n/**\n * A handler that attaches source file information to reflections.\n */\nlet SourcePlugin = class SourcePlugin extends components_1.ConverterComponent {\n    constructor() {\n        super(...arguments);\n        /**\n         * A map of all generated {@link SourceFile} instances.\n         */\n        this.fileMappings = {};\n        /**\n         * All file names to find the base path from.\n         */\n        this.fileNames = new Set();\n    }\n    /**\n     * Create a new SourceHandler instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_END]: this.onEnd,\n            [converter_1.Converter.EVENT_CREATE_DECLARATION]: this.onDeclaration,\n            [converter_1.Converter.EVENT_CREATE_SIGNATURE]: this.onDeclaration,\n            [converter_1.Converter.EVENT_RESOLVE_BEGIN]: this.onBeginResolve,\n            [converter_1.Converter.EVENT_RESOLVE]: this.onResolve,\n            [converter_1.Converter.EVENT_RESOLVE_END]: this.onEndResolve,\n        });\n    }\n    getSourceFile(fileName, project) {\n        if (!this.fileMappings[fileName]) {\n            const file = new index_2.SourceFile(fileName);\n            this.fileMappings[fileName] = file;\n            project.files.push(file);\n        }\n        return this.fileMappings[fileName];\n    }\n    onEnd() {\n        this.fileMappings = {};\n        this.fileNames.clear();\n        this.basePath = void 0;\n    }\n    /**\n     * Triggered when the converter has created a declaration reflection.\n     *\n     * Attach the current source file to the {@link DeclarationReflection.sources} array.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently processed.\n     * @param node  The node that is currently processed if available.\n     */\n    onDeclaration(context, reflection, node) {\n        if (!node || this.disableSources) {\n            return;\n        }\n        const sourceFile = node.getSourceFile();\n        const fileName = sourceFile.fileName;\n        this.fileNames.add(fileName);\n        const file = this.getSourceFile(fileName, context.project);\n        let position;\n        if ((0, nodes_1.isNamedNode)(node)) {\n            position = ts.getLineAndCharacterOfPosition(sourceFile, node.name.getStart());\n        }\n        else {\n            position = ts.getLineAndCharacterOfPosition(sourceFile, node.getStart());\n        }\n        if (reflection instanceof index_1.DeclarationReflection) {\n            file.reflections.push(reflection);\n        }\n        if (!reflection.sources) {\n            reflection.sources = [];\n        }\n        reflection.sources.push({\n            file: file,\n            fileName: fileName,\n            line: position.line + 1,\n            character: position.character,\n        });\n    }\n    /**\n     * Triggered when the converter begins resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onBeginResolve(context) {\n        this.basePath = (0, fs_1.getCommonDirectory)([...this.fileNames]);\n        for (const file of context.project.files) {\n            const fileName = (file.fileName = (0, fs_1.normalizePath)((0, path_1.relative)(this.basePath, file.fileName)));\n            this.fileMappings[fileName] = file;\n        }\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(_context, reflection) {\n        var _a;\n        assert(this.basePath != null);\n        for (const source of (_a = reflection.sources) !== null && _a !== void 0 ? _a : []) {\n            source.fileName = (0, fs_1.normalizePath)((0, path_1.relative)(this.basePath, source.fileName));\n        }\n    }\n    /**\n     * Triggered when the converter has finished resolving a project.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     */\n    onEndResolve(context) {\n        const project = context.project;\n        const home = project.directory;\n        project.files.forEach((file) => {\n            const reflections = [];\n            file.reflections.forEach((reflection) => {\n                reflections.push(reflection);\n            });\n            let directory = home;\n            const path = Path.dirname(file.fileName);\n            if (path !== \".\") {\n                path.split(\"/\").forEach((pathPiece) => {\n                    if (!Object.prototype.hasOwnProperty.call(directory.directories, pathPiece)) {\n                        directory.directories[pathPiece] = new index_2.SourceDirectory(pathPiece, directory);\n                    }\n                    directory = directory.directories[pathPiece];\n                });\n            }\n            directory.files.push(file);\n            file.parent = directory;\n            file.reflections = reflections;\n        });\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"disableSources\")\n], SourcePlugin.prototype, \"disableSources\", void 0);\nSourcePlugin = __decorate([\n    (0, components_1.Component)({ name: \"source\" })\n], SourcePlugin);\nexports.SourcePlugin = SourcePlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypePlugin = void 0;\nconst index_1 = require(\"../../models/reflections/index\");\nconst types_1 = require(\"../../models/types\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\n/**\n * A handler that converts all instances of {@link LateResolvingType} to their renderable equivalents.\n */\nlet TypePlugin = class TypePlugin extends components_1.ConverterComponent {\n    constructor() {\n        super(...arguments);\n        this.reflections = new Set();\n    }\n    /**\n     * Create a new TypeHandler instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_RESOLVE]: this.onResolve,\n            [converter_1.Converter.EVENT_RESOLVE_END]: this.onResolveEnd,\n            [converter_1.Converter.EVENT_END]: () => this.reflections.clear(),\n        });\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(context, reflection) {\n        if (reflection.kindOf(index_1.ReflectionKind.ClassOrInterface)) {\n            this.postpone(reflection);\n            walk(reflection.implementedTypes, (target) => {\n                this.postpone(target);\n                if (!target.implementedBy) {\n                    target.implementedBy = [];\n                }\n                target.implementedBy.push(types_1.ReferenceType.createResolvedReference(reflection.name, reflection, context.project));\n            });\n            walk(reflection.extendedTypes, (target) => {\n                this.postpone(target);\n                if (!target.extendedBy) {\n                    target.extendedBy = [];\n                }\n                target.extendedBy.push(types_1.ReferenceType.createResolvedReference(reflection.name, reflection, context.project));\n            });\n        }\n        function walk(types, callback) {\n            if (!types) {\n                return;\n            }\n            types.forEach((type) => {\n                if (!(type instanceof types_1.ReferenceType)) {\n                    return;\n                }\n                if (!type.reflection ||\n                    !(type.reflection instanceof index_1.DeclarationReflection)) {\n                    return;\n                }\n                callback(type.reflection);\n            });\n        }\n    }\n    postpone(reflection) {\n        this.reflections.add(reflection);\n    }\n    /**\n     * Triggered when the converter has finished resolving a project.\n     */\n    onResolveEnd(context) {\n        this.reflections.forEach((reflection) => {\n            if (reflection.implementedBy) {\n                reflection.implementedBy.sort((a, b) => {\n                    if (a.name === b.name) {\n                        return 0;\n                    }\n                    return a.name > b.name ? 1 : -1;\n                });\n            }\n            let root;\n            let hierarchy;\n            function push(types) {\n                const level = { types: types };\n                if (hierarchy) {\n                    hierarchy.next = level;\n                    hierarchy = level;\n                }\n                else {\n                    root = hierarchy = level;\n                }\n            }\n            if (reflection.extendedTypes) {\n                push(reflection.extendedTypes);\n            }\n            push([\n                types_1.ReferenceType.createResolvedReference(reflection.name, reflection, context.project),\n            ]);\n            hierarchy.isTarget = true;\n            if (reflection.extendedBy) {\n                push(reflection.extendedBy);\n            }\n            reflection.typeHierarchy = root;\n        });\n    }\n};\nTypePlugin = __decorate([\n    (0, components_1.Component)({ name: \"type\" })\n], TypePlugin);\nexports.TypePlugin = TypePlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InheritDocPlugin = void 0;\nconst models_1 = require(\"../../models\");\nconst components_1 = require(\"../components\");\nconst converter_1 = require(\"../converter\");\nconst reflections_1 = require(\"../utils/reflections\");\nconst abstract_1 = require(\"../../models/reflections/abstract\");\n/**\n * A plugin that handles `inheritDoc` by copying documentation from another API item.\n *\n * What gets copied:\n * - short text\n * - text\n * - `@remarks` block\n * - `@params` block\n * - `@typeParam` block\n * - `@return` block\n */\nlet InheritDocPlugin = class InheritDocPlugin extends components_1.ConverterComponent {\n    /**\n     * Create a new InheritDocPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [converter_1.Converter.EVENT_RESOLVE]: this.onResolve,\n        }, undefined, -200);\n    }\n    /**\n     * Triggered when the converter resolves a reflection.\n     *\n     * Traverse through reflection descendant to check for `inheritDoc` tag.\n     * If encountered, the parameter of the tag iss used to determine a source reflection\n     * that will provide actual comment.\n     *\n     * @param context  The context object describing the current state the converter is in.\n     * @param reflection  The reflection that is currently resolved.\n     */\n    onResolve(_context, reflection) {\n        if (reflection instanceof models_1.ContainerReflection) {\n            const descendantsCallback = (item) => {\n                var _a, _b, _c, _d, _e;\n                item.traverse(descendantsCallback);\n                const inheritDoc = (_b = (_a = item.comment) === null || _a === void 0 ? void 0 : _a.getTag(\"inheritdoc\")) === null || _b === void 0 ? void 0 : _b.paramName;\n                const source = inheritDoc && reflection.findReflectionByName(inheritDoc);\n                let referencedReflection = source;\n                if (source instanceof models_1.DeclarationReflection &&\n                    item instanceof models_1.SignatureReflection) {\n                    const isFunction = source.kindOf(models_1.ReflectionKind.FunctionOrMethod);\n                    if (isFunction) {\n                        // Assumes that if there are overloads, they are declared in the same order as the parent.\n                        // TS doesn't check this, but if a user messes this up then they are almost\n                        // guaranteed to run into bugs where they can't call a method on a child class\n                        // but if they assign (without a type assertion) that child to a variable of the parent class\n                        // then they can call the method.\n                        const itemIndex = (_d = (_c = item.parent.signatures) === null || _c === void 0 ? void 0 : _c.indexOf(item)) !== null && _d !== void 0 ? _d : 0;\n                        referencedReflection = (_e = source.signatures) === null || _e === void 0 ? void 0 : _e[itemIndex];\n                    }\n                }\n                if (referencedReflection instanceof abstract_1.Reflection) {\n                    (0, reflections_1.copyComment)(item, referencedReflection);\n                }\n                return true;\n            };\n            reflection.traverse(descendantsCallback);\n        }\n    }\n};\nInheritDocPlugin = __decorate([\n    (0, components_1.Component)({ name: \"inheritDoc\" })\n], InheritDocPlugin);\nexports.InheritDocPlugin = InheritDocPlugin;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultThemeRenderContext = exports.DefaultTheme = exports.Theme = exports.Renderer = exports.UrlMapping = exports.MarkdownEvent = exports.RendererEvent = exports.PageEvent = void 0;\nvar events_1 = require(\"./events\");\nObject.defineProperty(exports, \"PageEvent\", { enumerable: true, get: function () { return events_1.PageEvent; } });\nObject.defineProperty(exports, \"RendererEvent\", { enumerable: true, get: function () { return events_1.RendererEvent; } });\nObject.defineProperty(exports, \"MarkdownEvent\", { enumerable: true, get: function () { return events_1.MarkdownEvent; } });\nvar UrlMapping_1 = require(\"./models/UrlMapping\");\nObject.defineProperty(exports, \"UrlMapping\", { enumerable: true, get: function () { return UrlMapping_1.UrlMapping; } });\nvar renderer_1 = require(\"./renderer\");\nObject.defineProperty(exports, \"Renderer\", { enumerable: true, get: function () { return renderer_1.Renderer; } });\nvar theme_1 = require(\"./theme\");\nObject.defineProperty(exports, \"Theme\", { enumerable: true, get: function () { return theme_1.Theme; } });\nvar DefaultTheme_1 = require(\"./themes/default/DefaultTheme\");\nObject.defineProperty(exports, \"DefaultTheme\", { enumerable: true, get: function () { return DefaultTheme_1.DefaultTheme; } });\nvar DefaultThemeRenderContext_1 = require(\"./themes/default/DefaultThemeRenderContext\");\nObject.defineProperty(exports, \"DefaultThemeRenderContext\", { enumerable: true, get: function () { return DefaultThemeRenderContext_1.DefaultThemeRenderContext; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarkdownEvent = exports.PageEvent = exports.RendererEvent = void 0;\nconst Path = require(\"path\");\nconst events_1 = require(\"../utils/events\");\n/**\n * An event emitted by the {@link Renderer} class at the very beginning and\n * ending of the entire rendering process.\n *\n * @see {@link Renderer.EVENT_BEGIN}\n * @see {@link Renderer.EVENT_END}\n */\nclass RendererEvent extends events_1.Event {\n    constructor(name, outputDirectory, project) {\n        super(name);\n        this.outputDirectory = outputDirectory;\n        this.project = project;\n    }\n    /**\n     * Create an {@link PageEvent} event based on this event and the given url mapping.\n     *\n     * @internal\n     * @param mapping  The mapping that defines the generated {@link PageEvent} state.\n     * @returns A newly created {@link PageEvent} instance.\n     */\n    createPageEvent(mapping) {\n        const event = new PageEvent(PageEvent.BEGIN);\n        event.project = this.project;\n        event.url = mapping.url;\n        event.model = mapping.model;\n        event.template = mapping.template;\n        event.filename = Path.join(this.outputDirectory, mapping.url);\n        return event;\n    }\n}\nexports.RendererEvent = RendererEvent;\n/**\n * Triggered before the renderer starts rendering a project.\n * @event\n */\nRendererEvent.BEGIN = \"beginRender\";\n/**\n * Triggered after the renderer has written all documents.\n * @event\n */\nRendererEvent.END = \"endRender\";\n/**\n * An event emitted by the {@link Renderer} class before and after the\n * markup of a page is rendered.\n *\n * @see {@link Renderer.EVENT_BEGIN_PAGE}\n * @see {@link Renderer.EVENT_END_PAGE}\n */\nclass PageEvent extends events_1.Event {\n}\nexports.PageEvent = PageEvent;\n/**\n * Triggered before a document will be rendered.\n * @event\n */\nPageEvent.BEGIN = \"beginPage\";\n/**\n * Triggered after a document has been rendered, just before it is written to disc.\n * @event\n */\nPageEvent.END = \"endPage\";\n/**\n * An event emitted by the {@link MarkedPlugin} on the {@link Renderer} after a chunk of\n * markdown has been processed. Allows other plugins to manipulate the result.\n *\n * @see {@link MarkedPlugin.EVENT_PARSE_MARKDOWN}\n */\nclass MarkdownEvent extends events_1.Event {\n    constructor(name, originalText, parsedText) {\n        super(name);\n        this.originalText = originalText;\n        this.parsedText = parsedText;\n    }\n}\nexports.MarkdownEvent = MarkdownEvent;\n/**\n * Triggered on the renderer when this plugin parses a markdown string.\n * @event\n */\nMarkdownEvent.PARSE = \"parseMarkdown\";\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UrlMapping = void 0;\nclass UrlMapping {\n    constructor(url, model, template) {\n        this.url = url;\n        this.model = model;\n        this.template = template;\n    }\n}\nexports.UrlMapping = UrlMapping;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Renderer = void 0;\n/**\n * Holds all logic used render and output the final documentation.\n *\n * The {@link Renderer} class is the central controller within this namespace. When invoked it creates\n * an instance of {@link Theme} which defines the layout of the documentation and fires a\n * series of {@link RendererEvent} events. Instances of {@link BasePlugin} can listen to these events and\n * alter the generated output.\n */\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst events_1 = require(\"./events\");\nconst fs_1 = require(\"../utils/fs\");\nconst DefaultTheme_1 = require(\"./themes/default/DefaultTheme\");\nconst components_1 = require(\"./components\");\nconst component_1 = require(\"../utils/component\");\nconst utils_1 = require(\"../utils\");\nconst highlighter_1 = require(\"../utils/highlighter\");\nconst models_1 = require(\"../models\");\n/**\n * The renderer processes a {@link ProjectReflection} using a {@link Theme} instance and writes\n * the emitted html documents to a output directory. You can specify which theme should be used\n * using the `--theme <name>` command line argument.\n *\n * {@link Renderer} is a subclass of {@link EventDispatcher} and triggers a series of events while\n * a project is being processed. You can listen to these events to control the flow or manipulate\n * the output.\n *\n *  * {@link Renderer.EVENT_BEGIN}<br>\n *    Triggered before the renderer starts rendering a project. The listener receives\n *    an instance of {@link RendererEvent}. By calling {@link RendererEvent.preventDefault} the entire\n *    render process can be canceled.\n *\n *    * {@link Renderer.EVENT_BEGIN_PAGE}<br>\n *      Triggered before a document will be rendered. The listener receives an instance of\n *      {@link PageEvent}. By calling {@link PageEvent.preventDefault} the generation of the\n *      document can be canceled.\n *\n *    * {@link Renderer.EVENT_END_PAGE}<br>\n *      Triggered after a document has been rendered, just before it is written to disc. The\n *      listener receives an instance of {@link PageEvent}. When calling\n *      {@link PageEvent.preventDefault} the the document will not be saved to disc.\n *\n *  * {@link Renderer.EVENT_END}<br>\n *    Triggered after the renderer has written all documents. The listener receives\n *    an instance of {@link RendererEvent}.\n */\nlet Renderer = class Renderer extends component_1.ChildableComponent {\n    constructor() {\n        super(...arguments);\n        this.themes = new Map([\n            [\"default\", DefaultTheme_1.DefaultTheme],\n        ]);\n        this.unknownSymbolResolvers = new Map();\n        /**\n         * Hooks which will be called when rendering pages.\n         * Note:\n         * - Hooks added during output will be discarded at the end of rendering.\n         * - Hooks added during a page render will be discarded at the end of that page's render.\n         *\n         * See {@link RendererHooks} for a description of each available hook, and when it will be called.\n         */\n        this.hooks = new utils_1.EventHooks();\n    }\n    /**\n     * Define a new theme that can be used to render output.\n     * This API will likely be changing in TypeDoc 0.23.\n     * (sorry... changing as soon as it's introduced)\n     * As it is, it provides reasonable flexibility, but doesn't give users a sufficiently\n     * easy way to overwrite parts of a theme.\n     * @param name\n     * @param theme\n     */\n    defineTheme(name, theme) {\n        if (this.themes.has(name)) {\n            throw new Error(`The theme \"${name}\" has already been defined.`);\n        }\n        this.themes.set(name, theme);\n    }\n    /**\n     * Adds a new resolver that the theme can used to try to figure out how to link to a symbol\n     * declared by a third-party library which is not included in the documentation.\n     * @param packageName the npm package name that this resolver can handle to limit which files it will be tried on.\n     *   If the resolver will create links for Node builtin types, it should be set to `@types/node`.\n     *   Links for builtin types live in the default lib files under `typescript`.\n     * @param resolver a function that will be called to create links for a given symbol name in the registered path.\n     *  If the provided name is not contained within the docs, should return `undefined`.\n     * @since 0.22.0\n     */\n    addUnknownSymbolResolver(packageName, resolver) {\n        const existing = this.unknownSymbolResolvers.get(packageName);\n        if (existing) {\n            existing.push(resolver);\n        }\n        else {\n            this.unknownSymbolResolvers.set(packageName, [resolver]);\n        }\n    }\n    /**\n     * Marked as internal for now. Using this requires the internal `getSymbol()` method on ReferenceType.\n     * Someday that needs to be fixed so that this can be made public. ReferenceTypes really shouldn't store\n     * symbols so that we don't need to keep the program around forever.\n     * @internal\n     */\n    attemptExternalResolution(type) {\n        if (!type.qualifiedName || !type.package) {\n            return;\n        }\n        const resolvers = this.unknownSymbolResolvers.get(type.package);\n        for (const resolver of resolvers || []) {\n            const resolved = resolver(type.qualifiedName);\n            if (resolved)\n                return resolved;\n        }\n    }\n    /**\n     * Render the given project reflection to the specified output directory.\n     *\n     * @param project  The project that should be rendered.\n     * @param outputDirectory  The path of the directory the documentation should be rendered to.\n     */\n    async render(project, outputDirectory) {\n        const momento = this.hooks.saveMomento();\n        const start = Date.now();\n        await (0, highlighter_1.loadHighlighter)(this.lightTheme, this.darkTheme);\n        this.application.logger.verbose(`Renderer: Loading highlighter took ${Date.now() - start}ms`);\n        if (!this.prepareTheme() ||\n            !(await this.prepareOutputDirectory(outputDirectory))) {\n            return;\n        }\n        const output = new events_1.RendererEvent(events_1.RendererEvent.BEGIN, outputDirectory, project);\n        output.urls = this.theme.getUrls(project);\n        this.trigger(output);\n        if (!output.isDefaultPrevented) {\n            output.urls.forEach((mapping) => {\n                this.renderDocument(output.createPageEvent(mapping));\n            });\n            this.trigger(events_1.RendererEvent.END, output);\n        }\n        this.theme = void 0;\n        this.hooks.restoreMomento(momento);\n    }\n    /**\n     * Render a single page.\n     *\n     * @param page An event describing the current page.\n     * @return TRUE if the page has been saved to disc, otherwise FALSE.\n     */\n    renderDocument(page) {\n        const momento = this.hooks.saveMomento();\n        this.trigger(events_1.PageEvent.BEGIN, page);\n        if (page.isDefaultPrevented) {\n            this.hooks.restoreMomento(momento);\n            return false;\n        }\n        if (page.model instanceof models_1.Reflection) {\n            page.contents = this.theme.render(page);\n        }\n        else {\n            throw new Error(\"Should be unreachable\");\n        }\n        this.trigger(events_1.PageEvent.END, page);\n        this.hooks.restoreMomento(momento);\n        if (page.isDefaultPrevented) {\n            return false;\n        }\n        try {\n            (0, fs_1.writeFileSync)(page.filename, page.contents);\n        }\n        catch (error) {\n            this.application.logger.error(`Could not write ${page.filename}`);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Ensure that a theme has been setup.\n     *\n     * If a the user has set a theme we try to find and load it. If no theme has\n     * been specified we load the default theme.\n     *\n     * @returns TRUE if a theme has been setup, otherwise FALSE.\n     */\n    prepareTheme() {\n        if (!this.theme) {\n            const ctor = this.themes.get(this.themeName);\n            if (!ctor) {\n                this.application.logger.error(`The theme '${this.themeName}' is not defined. The available themes are: ${[\n                    ...this.themes.keys(),\n                ].join(\", \")}`);\n                return false;\n            }\n            else {\n                this.theme = new ctor(this);\n            }\n        }\n        return true;\n    }\n    /**\n     * Prepare the output directory. If the directory does not exist, it will be\n     * created. If the directory exists, it will be emptied.\n     *\n     * @param directory  The path to the directory that should be prepared.\n     * @returns TRUE if the directory could be prepared, otherwise FALSE.\n     */\n    async prepareOutputDirectory(directory) {\n        if (this.cleanOutputDir) {\n            try {\n                await (0, fs_1.remove)(directory);\n            }\n            catch (error) {\n                this.application.logger.warn(\"Could not empty the output directory.\");\n                return false;\n            }\n        }\n        try {\n            fs.mkdirSync(directory, { recursive: true });\n        }\n        catch (error) {\n            this.application.logger.error(`Could not create output directory ${directory}.`);\n            return false;\n        }\n        if (this.githubPages) {\n            try {\n                const text = \"TypeDoc added this file to prevent GitHub Pages from \" +\n                    \"using Jekyll. You can turn off this behavior by setting \" +\n                    \"the `githubPages` option to false.\";\n                fs.writeFileSync(path.join(directory, \".nojekyll\"), text);\n            }\n            catch (error) {\n                this.application.logger.warn(\"Could not create .nojekyll file.\");\n                return false;\n            }\n        }\n        if (this.cname) {\n            fs.writeFileSync(path.join(directory, \"CNAME\"), this.cname);\n        }\n        return true;\n    }\n};\n/** @event */\nRenderer.EVENT_BEGIN_PAGE = events_1.PageEvent.BEGIN;\n/** @event */\nRenderer.EVENT_END_PAGE = events_1.PageEvent.END;\n/** @event */\nRenderer.EVENT_BEGIN = events_1.RendererEvent.BEGIN;\n/** @event */\nRenderer.EVENT_END = events_1.RendererEvent.END;\n__decorate([\n    (0, utils_1.BindOption)(\"theme\")\n], Renderer.prototype, \"themeName\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"cleanOutputDir\")\n], Renderer.prototype, \"cleanOutputDir\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"cname\")\n], Renderer.prototype, \"cname\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"gaID\")\n], Renderer.prototype, \"gaID\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"gaSite\")\n], Renderer.prototype, \"gaSite\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"githubPages\")\n], Renderer.prototype, \"githubPages\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"hideGenerator\")\n], Renderer.prototype, \"hideGenerator\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"lightHighlightTheme\")\n], Renderer.prototype, \"lightTheme\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"darkHighlightTheme\")\n], Renderer.prototype, \"darkTheme\", void 0);\nRenderer = __decorate([\n    (0, component_1.Component)({ name: \"renderer\", internal: true, childClass: components_1.RendererComponent })\n], Renderer);\nexports.Renderer = Renderer;\n// HACK: THIS HAS TO STAY DOWN HERE\n// if you try to move it up to the top of the file, then you'll run into stuff being used before it has been defined.\nrequire(\"./plugins\");\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultTheme = void 0;\nconst theme_1 = require(\"../../theme\");\nconst index_1 = require(\"../../../models/reflections/index\");\nconst UrlMapping_1 = require(\"../../models/UrlMapping\");\nconst events_1 = require(\"../../events\");\nconst DefaultThemeRenderContext_1 = require(\"./DefaultThemeRenderContext\");\nconst utils_1 = require(\"../../../utils\");\n/**\n * Default theme implementation of TypeDoc. If a theme does not provide a custom\n * {@link Theme} implementation, this theme class will be used.\n */\nclass DefaultTheme extends theme_1.Theme {\n    /**\n     * Create a new DefaultTheme instance.\n     *\n     * @param renderer  The renderer this theme is attached to.\n     * @param basePath  The base path of this theme.\n     */\n    constructor(renderer) {\n        super(renderer);\n        this.reflectionTemplate = (pageEvent) => {\n            return this.getRenderContext(pageEvent).reflectionTemplate(pageEvent);\n        };\n        this.indexTemplate = (pageEvent) => {\n            return this.getRenderContext(pageEvent).indexTemplate(pageEvent);\n        };\n        this.defaultLayoutTemplate = (pageEvent) => {\n            return this.getRenderContext(pageEvent).defaultLayout(pageEvent);\n        };\n        /**\n         * Mappings of reflections kinds to templates used by this theme.\n         */\n        this.mappings = [\n            {\n                kind: [index_1.ReflectionKind.Class],\n                isLeaf: false,\n                directory: \"classes\",\n                template: this.reflectionTemplate,\n            },\n            {\n                kind: [index_1.ReflectionKind.Interface],\n                isLeaf: false,\n                directory: \"interfaces\",\n                template: this.reflectionTemplate,\n            },\n            {\n                kind: [index_1.ReflectionKind.Enum],\n                isLeaf: false,\n                directory: \"enums\",\n                template: this.reflectionTemplate,\n            },\n            {\n                kind: [index_1.ReflectionKind.Namespace, index_1.ReflectionKind.Module],\n                isLeaf: false,\n                directory: \"modules\",\n                template: this.reflectionTemplate,\n            },\n        ];\n        this.markedPlugin = renderer.getComponent(\"marked\");\n        this.listenTo(renderer, events_1.RendererEvent.BEGIN, this.onRendererBegin, 1024);\n    }\n    getRenderContext(_pageEvent) {\n        if (!this._renderContext) {\n            this._renderContext = new DefaultThemeRenderContext_1.DefaultThemeRenderContext(this, this.application.options);\n        }\n        return this._renderContext;\n    }\n    /**\n     * Map the models of the given project to the desired output files.\n     *\n     * @param project  The project whose urls should be generated.\n     * @returns        A list of {@link UrlMapping} instances defining which models\n     *                 should be rendered to which files.\n     */\n    getUrls(project) {\n        var _a;\n        const urls = [];\n        if (false == hasReadme(this.application.options.getValue(\"readme\"))) {\n            project.url = \"index.html\";\n            urls.push(new UrlMapping_1.UrlMapping(\"index.html\", project, this.reflectionTemplate));\n        }\n        else {\n            project.url = \"modules.html\";\n            urls.push(new UrlMapping_1.UrlMapping(\"modules.html\", project, this.reflectionTemplate));\n            urls.push(new UrlMapping_1.UrlMapping(\"index.html\", project, this.indexTemplate));\n        }\n        (_a = project.children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n            if (child instanceof index_1.DeclarationReflection) {\n                this.buildUrls(child, urls);\n            }\n        });\n        return urls;\n    }\n    /**\n     * Triggered before the renderer starts rendering a project.\n     *\n     * @param event  An event object describing the current render operation.\n     */\n    onRendererBegin(event) {\n        if (event.project.groups) {\n            event.project.groups.forEach(DefaultTheme.applyGroupClasses);\n        }\n        for (const id in event.project.reflections) {\n            const reflection = event.project.reflections[id];\n            if (reflection instanceof index_1.DeclarationReflection) {\n                DefaultTheme.applyReflectionClasses(reflection);\n            }\n            if (reflection instanceof index_1.ContainerReflection && reflection.groups) {\n                reflection.groups.forEach(DefaultTheme.applyGroupClasses);\n            }\n        }\n    }\n    /**\n     * Return a url for the given reflection.\n     *\n     * @param reflection  The reflection the url should be generated for.\n     * @param relative    The parent reflection the url generation should stop on.\n     * @param separator   The separator used to generate the url.\n     * @returns           The generated url.\n     */\n    static getUrl(reflection, relative, separator = \".\") {\n        let url = reflection.getAlias();\n        if (reflection.parent && reflection.parent !== relative && !(reflection.parent instanceof index_1.ProjectReflection)) {\n            url = DefaultTheme.getUrl(reflection.parent, relative, separator) + separator + url;\n        }\n        return url;\n    }\n    /**\n     * Return the template mapping for the given reflection.\n     *\n     * @param reflection  The reflection whose mapping should be resolved.\n     * @returns           The found mapping or undefined if no mapping could be found.\n     */\n    getMapping(reflection) {\n        return this.mappings.find((mapping) => reflection.kindOf(mapping.kind));\n    }\n    /**\n     * Build the url for the the given reflection and all of its children.\n     *\n     * @param reflection  The reflection the url should be created for.\n     * @param urls        The array the url should be appended to.\n     * @returns           The altered urls array.\n     */\n    buildUrls(reflection, urls) {\n        const mapping = this.getMapping(reflection);\n        if (mapping) {\n            if (!reflection.url || !DefaultTheme.URL_PREFIX.test(reflection.url)) {\n                const url = [mapping.directory, DefaultTheme.getUrl(reflection) + \".html\"].join(\"/\");\n                urls.push(new UrlMapping_1.UrlMapping(url, reflection, mapping.template));\n                reflection.url = url;\n                reflection.hasOwnDocument = true;\n            }\n            for (const child of reflection.children || []) {\n                if (mapping.isLeaf) {\n                    DefaultTheme.applyAnchorUrl(child, reflection);\n                }\n                else {\n                    this.buildUrls(child, urls);\n                }\n            }\n        }\n        else if (reflection.parent) {\n            DefaultTheme.applyAnchorUrl(reflection, reflection.parent);\n        }\n        return urls;\n    }\n    render(page) {\n        const templateOutput = this.defaultLayoutTemplate(page);\n        return \"<!DOCTYPE html>\" + utils_1.JSX.renderElement(templateOutput);\n    }\n    /**\n     * Generate an anchor url for the given reflection and all of its children.\n     *\n     * @param reflection  The reflection an anchor url should be created for.\n     * @param container   The nearest reflection having an own document.\n     */\n    static applyAnchorUrl(reflection, container) {\n        if (!reflection.url || !DefaultTheme.URL_PREFIX.test(reflection.url)) {\n            const anchor = DefaultTheme.getUrl(reflection, container, \".\");\n            reflection.url = container.url + \"#\" + anchor;\n            reflection.anchor = anchor;\n            reflection.hasOwnDocument = false;\n        }\n        reflection.traverse((child) => {\n            if (child instanceof index_1.DeclarationReflection) {\n                DefaultTheme.applyAnchorUrl(child, container);\n            }\n            return true;\n        });\n    }\n    /**\n     * Generate the css classes for the given reflection and apply them to the\n     * {@link DeclarationReflection.cssClasses} property.\n     *\n     * @param reflection  The reflection whose cssClasses property should be generated.\n     */\n    static applyReflectionClasses(reflection) {\n        const classes = [];\n        let kind;\n        if (reflection.kind === index_1.ReflectionKind.Accessor) {\n            if (!reflection.getSignature) {\n                classes.push(\"tsd-kind-set-signature\");\n            }\n            else if (!reflection.setSignature) {\n                classes.push(\"tsd-kind-get-signature\");\n            }\n            else {\n                classes.push(\"tsd-kind-accessor\");\n            }\n        }\n        else {\n            kind = index_1.ReflectionKind[reflection.kind];\n            classes.push(DefaultTheme.toStyleClass(\"tsd-kind-\" + kind));\n        }\n        if (reflection.parent && reflection.parent instanceof index_1.DeclarationReflection) {\n            kind = index_1.ReflectionKind[reflection.parent.kind];\n            classes.push(DefaultTheme.toStyleClass(`tsd-parent-kind-${kind}`));\n        }\n        let hasTypeParameters = !!reflection.typeParameters;\n        reflection.getAllSignatures().forEach((signature) => {\n            hasTypeParameters = hasTypeParameters || !!signature.typeParameters;\n        });\n        if (hasTypeParameters) {\n            classes.push(\"tsd-has-type-parameter\");\n        }\n        if (reflection.overwrites) {\n            classes.push(\"tsd-is-overwrite\");\n        }\n        if (reflection.inheritedFrom) {\n            classes.push(\"tsd-is-inherited\");\n        }\n        if (reflection.flags.isPrivate) {\n            classes.push(\"tsd-is-private\");\n        }\n        if (reflection.flags.isProtected) {\n            classes.push(\"tsd-is-protected\");\n        }\n        if (reflection.flags.isStatic) {\n            classes.push(\"tsd-is-static\");\n        }\n        if (reflection.flags.isExternal) {\n            classes.push(\"tsd-is-external\");\n        }\n        reflection.cssClasses = classes.join(\" \");\n    }\n    /**\n     * Generate the css classes for the given reflection group and apply them to the\n     * {@link ReflectionGroup.cssClasses} property.\n     *\n     * @param group  The reflection group whose cssClasses property should be generated.\n     */\n    static applyGroupClasses(group) {\n        const classes = [];\n        if (group.allChildrenAreInherited) {\n            classes.push(\"tsd-is-inherited\");\n        }\n        if (group.allChildrenArePrivate) {\n            classes.push(\"tsd-is-private\");\n        }\n        if (group.allChildrenAreProtectedOrPrivate) {\n            classes.push(\"tsd-is-private-protected\");\n        }\n        if (group.allChildrenAreExternal) {\n            classes.push(\"tsd-is-external\");\n        }\n        group.cssClasses = classes.join(\" \");\n    }\n    /**\n     * Transform a space separated string into a string suitable to be used as a\n     * css class, e.g. \"constructor method\" > \"Constructor-method\".\n     */\n    static toStyleClass(str) {\n        return str.replace(/(\\w)([A-Z])/g, (_m, m1, m2) => m1 + \"-\" + m2).toLowerCase();\n    }\n}\nexports.DefaultTheme = DefaultTheme;\nDefaultTheme.URL_PREFIX = /^(http|ftp)s?:\\/\\//;\nfunction hasReadme(readme) {\n    return !readme.endsWith(\"none\");\n}\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Theme = void 0;\nconst components_1 = require(\"./components\");\nconst component_1 = require(\"../utils/component\");\n/**\n * Base class of all themes.\n *\n * The theme class controls which files will be created through the {@link Theme.getUrls}\n * function. It returns an array of {@link UrlMapping} instances defining the target files, models\n * and templates to use. Additionally themes can subscribe to the events emitted by\n * {@link Renderer} to control and manipulate the output process.\n */\nlet Theme = class Theme extends components_1.RendererComponent {\n    /**\n     * Create a new BaseTheme instance.\n     *\n     * @param renderer  The renderer this theme is attached to.\n     */\n    constructor(renderer) {\n        super(renderer);\n    }\n};\nTheme = __decorate([\n    (0, component_1.Component)({ name: \"theme\", internal: true })\n], Theme);\nexports.Theme = Theme;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextAwareRendererComponent = exports.RendererComponent = exports.Component = void 0;\nconst Path = require(\"path\");\nconst component_1 = require(\"../utils/component\");\nObject.defineProperty(exports, \"Component\", { enumerable: true, get: function () { return component_1.Component; } });\nconst index_1 = require(\"../models/reflections/index\");\nconst events_1 = require(\"./events\");\nclass RendererComponent extends component_1.AbstractComponent {\n}\nexports.RendererComponent = RendererComponent;\n/**\n * A plugin for the renderer that reads the current render context.\n */\nclass ContextAwareRendererComponent extends RendererComponent {\n    constructor() {\n        super(...arguments);\n        /**\n         * Regular expression to test if a string looks like an external url.\n         */\n        this.urlPrefix = /^(http|ftp)s?:\\/\\//;\n    }\n    /**\n     * Create a new ContextAwareRendererPlugin instance.\n     *\n     * @param renderer  The renderer this plugin should be attached to.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [events_1.RendererEvent.BEGIN]: this.onBeginRenderer,\n            [events_1.PageEvent.BEGIN]: this.onBeginPage,\n        });\n    }\n    /**\n     * Transform the given absolute path into a relative path.\n     *\n     * @param absolute  The absolute path to transform.\n     * @returns A path relative to the document currently processed.\n     */\n    getRelativeUrl(absolute) {\n        if (this.urlPrefix.test(absolute)) {\n            return absolute;\n        }\n        else {\n            const relative = Path.relative(Path.dirname(this.location), Path.dirname(absolute));\n            return Path.join(relative, Path.basename(absolute)).replace(/\\\\/g, \"/\");\n        }\n    }\n    /**\n     * Triggered before the renderer starts rendering a project.\n     *\n     * @param event  An event object describing the current render operation.\n     */\n    onBeginRenderer(event) {\n        this.project = event.project;\n    }\n    /**\n     * Triggered before a document will be rendered.\n     *\n     * @param page  An event object describing the current render operation.\n     */\n    onBeginPage(page) {\n        this.location = page.url;\n        this.reflection =\n            page.model instanceof index_1.DeclarationReflection\n                ? page.model\n                : undefined;\n    }\n}\nexports.ContextAwareRendererComponent = ContextAwareRendererComponent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultThemeRenderContext = void 0;\nconst default_1 = require(\"./layouts/default\");\nconst partials_1 = require(\"./partials\");\nconst analytics_1 = require(\"./partials/analytics\");\nconst breadcrumb_1 = require(\"./partials/breadcrumb\");\nconst comment_1 = require(\"./partials/comment\");\nconst footer_1 = require(\"./partials/footer\");\nconst header_1 = require(\"./partials/header\");\nconst hierarchy_1 = require(\"./partials/hierarchy\");\nconst member_1 = require(\"./partials/member\");\nconst member_declaration_1 = require(\"./partials/member.declaration\");\nconst member_getterSetter_1 = require(\"./partials/member.getterSetter\");\nconst member_reference_1 = require(\"./partials/member.reference\");\nconst member_signature_body_1 = require(\"./partials/member.signature.body\");\nconst member_signature_title_1 = require(\"./partials/member.signature.title\");\nconst member_signatures_1 = require(\"./partials/member.signatures\");\nconst member_sources_1 = require(\"./partials/member.sources\");\nconst members_1 = require(\"./partials/members\");\nconst members_group_1 = require(\"./partials/members.group\");\nconst navigation_1 = require(\"./partials/navigation\");\nconst parameter_1 = require(\"./partials/parameter\");\nconst type_1 = require(\"./partials/type\");\nconst typeAndParent_1 = require(\"./partials/typeAndParent\");\nconst typeParameters_1 = require(\"./partials/typeParameters\");\nconst templates_1 = require(\"./templates\");\nconst reflection_1 = require(\"./templates/reflection\");\nfunction bind(fn, first) {\n    return (...r) => fn(first, ...r);\n}\nclass DefaultThemeRenderContext {\n    constructor(theme, options) {\n        this.theme = theme;\n        this.hook = (name) => this.theme.owner.hooks.emit(name, this);\n        /** Avoid this in favor of urlTo if possible */\n        this.relativeURL = (url) => {\n            return url ? this.theme.markedPlugin.getRelativeUrl(url) : url;\n        };\n        this.urlTo = (reflection) => this.relativeURL(reflection.url);\n        this.markdown = (md) => {\n            return md ? this.theme.markedPlugin.parseMarkdown(md) : \"\";\n        };\n        this.attemptExternalResolution = (type) => {\n            return this.theme.owner.attemptExternalResolution(type);\n        };\n        this.reflectionTemplate = bind(reflection_1.reflectionTemplate, this);\n        this.indexTemplate = bind(templates_1.indexTemplate, this);\n        this.defaultLayout = bind(default_1.defaultLayout, this);\n        this.analytics = bind(analytics_1.analytics, this);\n        this.breadcrumb = bind(breadcrumb_1.breadcrumb, this);\n        this.comment = bind(comment_1.comment, this);\n        this.footer = bind(footer_1.footer, this);\n        this.header = bind(header_1.header, this);\n        this.hierarchy = bind(hierarchy_1.hierarchy, this);\n        this.index = bind(partials_1.index, this);\n        this.member = bind(member_1.member, this);\n        this.memberDeclaration = bind(member_declaration_1.memberDeclaration, this);\n        this.memberGetterSetter = bind(member_getterSetter_1.memberGetterSetter, this);\n        this.memberReference = bind(member_reference_1.memberReference, this);\n        this.memberSignatureBody = bind(member_signature_body_1.memberSignatureBody, this);\n        this.memberSignatureTitle = bind(member_signature_title_1.memberSignatureTitle, this);\n        this.memberSignatures = bind(member_signatures_1.memberSignatures, this);\n        this.memberSources = bind(member_sources_1.memberSources, this);\n        this.members = bind(members_1.members, this);\n        this.membersGroup = bind(members_group_1.membersGroup, this);\n        this.navigation = bind(navigation_1.navigation, this);\n        this.parameter = bind(parameter_1.parameter, this);\n        this.type = bind(type_1.type, this);\n        this.typeAndParent = bind(typeAndParent_1.typeAndParent, this);\n        this.typeParameters = bind(typeParameters_1.typeParameters, this);\n        this.options = options;\n    }\n}\nexports.DefaultThemeRenderContext = DefaultThemeRenderContext;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultLayout = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst defaultLayout = (context, props) => (utils_1.JSX.createElement(\"html\", { class: \"default\" },\n    utils_1.JSX.createElement(\"head\", null,\n        utils_1.JSX.createElement(\"meta\", { charSet: \"utf-8\" }),\n        context.hook(\"head.begin\"),\n        utils_1.JSX.createElement(\"meta\", { \"http-equiv\": \"x-ua-compatible\", content: \"IE=edge\" }),\n        utils_1.JSX.createElement(\"title\", null, props.model.name === props.project.name\n            ? props.project.name\n            : `${props.model.name} | ${props.project.name}`),\n        utils_1.JSX.createElement(\"meta\", { name: \"description\", content: \"Documentation for \" + props.project.name }),\n        utils_1.JSX.createElement(\"meta\", { name: \"viewport\", content: \"width=device-width, initial-scale=1\" }),\n        utils_1.JSX.createElement(\"link\", { rel: \"stylesheet\", href: context.relativeURL(\"assets/style.css\") }),\n        utils_1.JSX.createElement(\"link\", { rel: \"stylesheet\", href: context.relativeURL(\"assets/highlight.css\") }),\n        context.options.getValue(\"customCss\") && (utils_1.JSX.createElement(\"link\", { rel: \"stylesheet\", href: context.relativeURL(\"assets/custom.css\") })),\n        utils_1.JSX.createElement(\"script\", { async: true, src: context.relativeURL(\"assets/search.js\"), id: \"search-script\" }),\n        context.hook(\"head.end\")),\n    utils_1.JSX.createElement(\"body\", null,\n        context.hook(\"body.begin\"),\n        utils_1.JSX.createElement(\"script\", null,\n            utils_1.JSX.createElement(utils_1.Raw, { html: 'document.body.classList.add(localStorage.getItem(\"tsd-theme\") || \"os\")' })),\n        context.header(props),\n        utils_1.JSX.createElement(\"div\", { class: \"container container-main\" },\n            utils_1.JSX.createElement(\"div\", { class: \"row\" },\n                utils_1.JSX.createElement(\"div\", { class: \"col-8 col-content\" },\n                    context.hook(\"content.begin\"),\n                    props.template(props),\n                    context.hook(\"content.end\")),\n                utils_1.JSX.createElement(\"div\", { class: \"col-4 col-menu menu-sticky-wrap menu-highlight\" },\n                    context.hook(\"navigation.begin\"),\n                    context.navigation(props),\n                    context.hook(\"navigation.end\")))),\n        context.footer(props),\n        utils_1.JSX.createElement(\"div\", { class: \"overlay\" }),\n        utils_1.JSX.createElement(\"script\", { src: context.relativeURL(\"assets/main.js\") }),\n        context.analytics(),\n        context.hook(\"body.end\"))));\nexports.defaultLayout = defaultLayout;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.index = void 0;\nconst lib_1 = require(\"../../lib\");\nconst utils_1 = require(\"../../../../utils\");\nfunction renderCategory({ urlTo }, item, prependName = \"\") {\n    return (utils_1.JSX.createElement(\"section\", { class: \"tsd-index-section\" },\n        utils_1.JSX.createElement(\"h3\", null, prependName ? `${prependName} ${item.title}` : item.title),\n        utils_1.JSX.createElement(\"ul\", { class: \"tsd-index-list\" }, item.children.map((item) => (utils_1.JSX.createElement(\"li\", { class: item.cssClasses },\n            utils_1.JSX.createElement(\"a\", { href: urlTo(item), class: \"tsd-kind-icon\" }, item.name ? (0, lib_1.wbr)(item.name) : utils_1.JSX.createElement(\"em\", null, (0, lib_1.wbr)(item.kindString)))))))));\n}\nfunction index(context, props) {\n    if (props.categories && props.categories.length) {\n        return (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel-group tsd-index-group\" },\n            utils_1.JSX.createElement(\"h2\", null, \"Index\"),\n            utils_1.JSX.createElement(\"section\", { class: \"tsd-panel tsd-index-panel\" },\n                utils_1.JSX.createElement(\"div\", { class: \"tsd-index-content\" }, props.categories.map((item) => renderCategory(context, item))))));\n    }\n    if (props.groups && props.groups.length) {\n        return (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel-group tsd-index-group\" },\n            utils_1.JSX.createElement(\"h2\", null, \"Index\"),\n            utils_1.JSX.createElement(\"section\", { class: \"tsd-panel tsd-index-panel\" },\n                utils_1.JSX.createElement(\"div\", { class: \"tsd-index-content\" }, props.groups.map((item) => (utils_1.JSX.createElement(\"section\", { class: \"tsd-index-section \" + item.cssClasses }, item.categories ? (item.categories.map((item2) => renderCategory(context, item2, item.title))) : (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                    utils_1.JSX.createElement(\"h3\", null, item.title),\n                    utils_1.JSX.createElement(\"ul\", { class: \"tsd-index-list\" }, item.children.map((item) => (utils_1.JSX.createElement(\"li\", { class: item.cssClasses },\n                        utils_1.JSX.createElement(\"a\", { href: context.urlTo(item), class: \"tsd-kind-icon\" }, item.name ? (0, lib_1.wbr)(item.name) : utils_1.JSX.createElement(\"em\", null, (0, lib_1.wbr)(item.kindString))))))))))))))));\n    }\n}\nexports.index = index;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderTypeParametersSignature = exports.hasTypeParameters = exports.classNames = exports.renderFlags = exports.join = exports.wbr = exports.stringify = void 0;\nconst models_1 = require(\"../../models\");\nconst utils_1 = require(\"../../utils\");\nfunction stringify(data) {\n    if (typeof data === \"bigint\") {\n        return data.toString() + \"n\";\n    }\n    return JSON.stringify(data);\n}\nexports.stringify = stringify;\n/**\n * Insert word break tags ``<wbr>`` into the given string.\n *\n * Breaks the given string at ``_``, ``-`` and capital letters.\n *\n * @param str The string that should be split.\n * @return The original string containing ``<wbr>`` tags where possible.\n */\nfunction wbr(str) {\n    // TODO surely there is a better way to do this, but I'm tired.\n    const ret = [];\n    const re = /[\\s\\S]*?(?:([^_-][_-])(?=[^_-])|([^A-Z])(?=[A-Z][^A-Z]))/g;\n    let match;\n    let i = 0;\n    while ((match = re.exec(str))) {\n        ret.push(match[0]);\n        ret.push(utils_1.JSX.createElement(\"wbr\", null));\n        i += match[0].length;\n    }\n    ret.push(str.slice(i));\n    return ret;\n}\nexports.wbr = wbr;\nfunction join(joiner, list, cb) {\n    const result = [];\n    for (const item of list) {\n        if (result.length > 0) {\n            result.push(joiner);\n        }\n        result.push(cb(item));\n    }\n    return utils_1.JSX.createElement(utils_1.JSX.Fragment, null, result);\n}\nexports.join = join;\nfunction renderFlags(flags) {\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null, flags.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        utils_1.JSX.createElement(\"span\", { class: \"tsd-flag ts-flag\" + item }, item),\n        \" \")))));\n}\nexports.renderFlags = renderFlags;\nfunction classNames(names) {\n    return Object.entries(names)\n        .filter(([, include]) => include)\n        .map(([key]) => key)\n        .join(\" \");\n}\nexports.classNames = classNames;\nfunction hasTypeParameters(reflection) {\n    if (reflection instanceof models_1.DeclarationReflection || reflection instanceof models_1.SignatureReflection) {\n        return reflection.typeParameters != null;\n    }\n    return false;\n}\nexports.hasTypeParameters = hasTypeParameters;\nfunction renderTypeParametersSignature(typeParameters) {\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null, !!typeParameters && typeParameters.length > 0 && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"<\"),\n        join(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \", \"), typeParameters, (item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            item.varianceModifier ? `${item.varianceModifier} ` : \"\",\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\", \"data-tsd-kind\": item.kindString }, item.name)))),\n        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \">\")))));\n}\nexports.renderTypeParametersSignature = renderTypeParametersSignature;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.analytics = void 0;\nconst utils_1 = require(\"../../../../utils\");\nfunction analytics(context) {\n    const gaID = context.options.getValue(\"gaID\");\n    const gaSite = context.options.getValue(\"gaSite\");\n    if (!gaID)\n        return;\n    const script = `\n(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','//www.google-analytics.com/analytics.js','ga');\nga('create', '${gaID}', '${gaSite}');\nga('send', 'pageview');\n`.trim();\n    return (utils_1.JSX.createElement(\"script\", null,\n        utils_1.JSX.createElement(utils_1.JSX.Raw, { html: script })));\n}\nexports.analytics = analytics;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.breadcrumb = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst breadcrumb = (context, props) => props.parent ? (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n    context.breadcrumb(props.parent),\n    utils_1.JSX.createElement(\"li\", null, props.url ? utils_1.JSX.createElement(\"a\", { href: context.urlTo(props) }, props.name) : utils_1.JSX.createElement(\"span\", null, props.name)))) : props.url ? (utils_1.JSX.createElement(\"li\", null,\n    utils_1.JSX.createElement(\"a\", { href: context.urlTo(props) }, props.name))) : undefined;\nexports.breadcrumb = breadcrumb;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.comment = void 0;\nconst utils_1 = require(\"../../../../utils\");\nfunction comment({ markdown }, props) {\n    var _a, _b;\n    if (!((_a = props.comment) === null || _a === void 0 ? void 0 : _a.hasVisibleComponent()))\n        return;\n    return (utils_1.JSX.createElement(\"div\", { class: \"tsd-comment tsd-typography\" },\n        !!props.comment.shortText && (utils_1.JSX.createElement(\"div\", { class: \"lead\" },\n            utils_1.JSX.createElement(utils_1.Raw, { html: \"\\n\" + markdown(props.comment.shortText) }))),\n        !!props.comment.text && (utils_1.JSX.createElement(\"div\", null,\n            utils_1.JSX.createElement(utils_1.Raw, { html: markdown(props.comment.text) }))),\n        ((_b = props.comment.tags) === null || _b === void 0 ? void 0 : _b.length) > 0 && (utils_1.JSX.createElement(\"dl\", { class: \"tsd-comment-tags\" }, props.comment.tags.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"dt\", null,\n                item.tagName,\n                item.paramName ? ` ${item.paramName}` : \"\"),\n            utils_1.JSX.createElement(\"dd\", null,\n                utils_1.JSX.createElement(utils_1.Raw, { html: markdown(item.text) })))))))));\n}\nexports.comment = comment;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.footer = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst lib_1 = require(\"../../lib\");\nfunction footer(context, props) {\n    var _a;\n    const hideLegend = context.options.getValue(\"hideLegend\");\n    const hideGenerator = context.options.getValue(\"hideGenerator\");\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        utils_1.JSX.createElement(\"footer\", { class: (0, lib_1.classNames)({\n                \"with-border-bottom\": !hideGenerator,\n            }) },\n            utils_1.JSX.createElement(\"div\", { class: \"container\" },\n                !hideLegend && ((_a = props.legend) === null || _a === void 0 ? void 0 : _a.length) && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                    utils_1.JSX.createElement(\"h2\", null, \"Legend\"),\n                    utils_1.JSX.createElement(\"div\", { class: \"tsd-legend-group\" }, props.legend.map((item) => (utils_1.JSX.createElement(\"ul\", { class: \"tsd-legend\" }, item.map((item) => (utils_1.JSX.createElement(\"li\", { class: item.classes.join(\" \") },\n                        utils_1.JSX.createElement(\"span\", { class: \"tsd-kind-icon\" }, item.name)))))))))),\n                utils_1.JSX.createElement(\"h2\", null, \"Settings\"),\n                utils_1.JSX.createElement(\"p\", null,\n                    \"Theme\",\n                    \" \",\n                    utils_1.JSX.createElement(\"select\", { id: \"theme\" },\n                        utils_1.JSX.createElement(\"option\", { value: \"os\" }, \"OS\"),\n                        utils_1.JSX.createElement(\"option\", { value: \"light\" }, \"Light\"),\n                        utils_1.JSX.createElement(\"option\", { value: \"dark\" }, \"Dark\"))))),\n        !hideGenerator && (utils_1.JSX.createElement(\"div\", { class: \"container tsd-generator\" },\n            utils_1.JSX.createElement(\"p\", null,\n                \"Generated using \",\n                utils_1.JSX.createElement(\"a\", { href: \"https://typedoc.org/\", target: \"_blank\" }, \"TypeDoc\"))))));\n}\nexports.footer = footer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.header = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst lib_1 = require(\"../../lib\");\nconst header = (context, props) => {\n    var _a;\n    return (utils_1.JSX.createElement(\"header\", null,\n        utils_1.JSX.createElement(\"div\", { class: \"tsd-page-toolbar\" },\n            utils_1.JSX.createElement(\"div\", { class: \"container\" },\n                utils_1.JSX.createElement(\"div\", { class: \"table-wrap\" },\n                    utils_1.JSX.createElement(\"div\", { class: \"table-cell\", id: \"tsd-search\", \"data-base\": context.relativeURL(\"./\") },\n                        utils_1.JSX.createElement(\"div\", { class: \"field\" },\n                            utils_1.JSX.createElement(\"label\", { for: \"tsd-search-field\", class: \"tsd-widget search no-caption\" }, \"Search\"),\n                            utils_1.JSX.createElement(\"input\", { type: \"text\", id: \"tsd-search-field\" })),\n                        utils_1.JSX.createElement(\"ul\", { class: \"results\" },\n                            utils_1.JSX.createElement(\"li\", { class: \"state loading\" }, \"Preparing search index...\"),\n                            utils_1.JSX.createElement(\"li\", { class: \"state failure\" }, \"The search index is not available\")),\n                        utils_1.JSX.createElement(\"a\", { href: context.relativeURL(\"index.html\"), class: \"title\" }, props.project.name)),\n                    utils_1.JSX.createElement(\"div\", { class: \"table-cell\", id: \"tsd-widgets\" },\n                        utils_1.JSX.createElement(\"div\", { id: \"tsd-filter\" },\n                            utils_1.JSX.createElement(\"a\", { href: \"#\", class: \"tsd-widget options no-caption\", \"data-toggle\": \"options\" }, \"Options\"),\n                            utils_1.JSX.createElement(\"div\", { class: \"tsd-filter-group\" },\n                                utils_1.JSX.createElement(\"div\", { class: \"tsd-select\", id: \"tsd-filter-visibility\" },\n                                    utils_1.JSX.createElement(\"span\", { class: \"tsd-select-label\" }, \"All\"),\n                                    utils_1.JSX.createElement(\"ul\", { class: \"tsd-select-list\" },\n                                        utils_1.JSX.createElement(\"li\", { \"data-value\": \"public\" }, \"Public\"),\n                                        utils_1.JSX.createElement(\"li\", { \"data-value\": \"protected\" }, \"Public/Protected\"),\n                                        utils_1.JSX.createElement(\"li\", { \"data-value\": \"private\", class: \"selected\" }, \"All\"))),\n                                \" \",\n                                utils_1.JSX.createElement(\"input\", { type: \"checkbox\", id: \"tsd-filter-inherited\", checked: true }),\n                                utils_1.JSX.createElement(\"label\", { class: \"tsd-widget\", for: \"tsd-filter-inherited\" }, \"Inherited\"),\n                                !context.options.getValue(\"excludeExternals\") && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                                    utils_1.JSX.createElement(\"input\", { type: \"checkbox\", id: \"tsd-filter-externals\", checked: true }),\n                                    utils_1.JSX.createElement(\"label\", { class: \"tsd-widget\", for: \"tsd-filter-externals\" }, \"Externals\"))))),\n                        utils_1.JSX.createElement(\"a\", { href: \"#\", class: \"tsd-widget menu no-caption\", \"data-toggle\": \"menu\" }, \"Menu\"))))),\n        utils_1.JSX.createElement(\"div\", { class: \"tsd-page-title\" },\n            utils_1.JSX.createElement(\"div\", { class: \"container\" },\n                !!props.model.parent && utils_1.JSX.createElement(\"ul\", { class: \"tsd-breadcrumb\" }, context.breadcrumb(props.model)),\n                utils_1.JSX.createElement(\"h1\", null,\n                    props.model.kindString !== \"Project\" && `${(_a = props.model.kindString) !== null && _a !== void 0 ? _a : \"\"} `,\n                    props.model.name,\n                    (0, lib_1.hasTypeParameters)(props.model) && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                        \"<\",\n                        (0, lib_1.join)(\", \", props.model.typeParameters, (item) => item.name),\n                        \">\")),\n                    \" \",\n                    (0, lib_1.renderFlags)(props.model.flags))))));\n};\nexports.header = header;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hierarchy = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst hierarchy = (context, props) => (utils_1.JSX.createElement(\"ul\", { class: \"tsd-hierarchy\" }, props.types.map((item, i, l) => (utils_1.JSX.createElement(\"li\", null,\n    props.isTarget ? utils_1.JSX.createElement(\"span\", { class: \"target\" }, item.toString()) : context.type(item),\n    i === l.length - 1 && !!props.next && context.hierarchy(props.next))))));\nexports.hierarchy = hierarchy;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.member = void 0;\nconst lib_1 = require(\"../../lib\");\nconst utils_1 = require(\"../../../../utils\");\nconst models_1 = require(\"../../../../models\");\nconst anchor_icon_1 = require(\"./anchor-icon\");\nconst member = (context, props) => {\n    var _a;\n    return (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel tsd-member \" + props.cssClasses },\n        utils_1.JSX.createElement(\"a\", { id: props.anchor, class: \"tsd-anchor\" }),\n        !!props.name && (utils_1.JSX.createElement(\"h3\", { class: \"tsd-anchor-link\" },\n            (0, lib_1.renderFlags)(props.flags),\n            (0, lib_1.wbr)(props.name),\n            (0, anchor_icon_1.anchorIcon)(props.anchor))),\n        props.signatures\n            ? context.memberSignatures(props)\n            : props.hasGetterOrSetter()\n                ? context.memberGetterSetter(props)\n                : props instanceof models_1.ReferenceReflection\n                    ? context.memberReference(props)\n                    : context.memberDeclaration(props), (_a = props.groups) === null || _a === void 0 ? void 0 :\n        _a.map((item) => item.children.map((item) => !item.hasOwnDocument && context.member(item)))));\n};\nexports.member = member;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.anchorIcon = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst anchorIcon = (anchor) => (utils_1.JSX.createElement(\"a\", { href: `#${anchor}`, \"aria-label\": \"Permalink\", class: \"tsd-anchor-icon\" },\n    utils_1.JSX.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", class: \"icon icon-tabler icon-tabler-link\", viewBox: \"0 0 24 24\", \"stroke-width\": \"2\", stroke: \"currentColor\", fill: \"none\", \"stroke-linecap\": \"round\", \"stroke-linejoin\": \"round\" },\n        utils_1.JSX.createElement(\"path\", { stroke: \"none\", d: \"M0 0h24v24H0z\", fill: \"none\" }),\n        utils_1.JSX.createElement(\"path\", { d: \"M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5\" }),\n        utils_1.JSX.createElement(\"path\", { d: \"M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5\" }))));\nexports.anchorIcon = anchorIcon;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberDeclaration = void 0;\nconst models_1 = require(\"../../../../models\");\nconst utils_1 = require(\"../../../../utils\");\nconst lib_1 = require(\"../../lib\");\nconst memberDeclaration = (context, props) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n    utils_1.JSX.createElement(\"div\", { class: \"tsd-signature tsd-kind-icon\" },\n        (0, lib_1.wbr)(props.name),\n        (0, lib_1.renderTypeParametersSignature)(props.typeParameters),\n        props.type && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                !!props.flags.isOptional && \"?\",\n                \":\"),\n            \" \",\n            context.type(props.type))),\n        !!props.defaultValue && props.kind !== models_1.ReflectionKind.EnumMember && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                \" = \",\n                props.defaultValue)))),\n    context.memberSources(props),\n    context.comment(props),\n    !!props.typeParameters && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        utils_1.JSX.createElement(\"h4\", { class: \"tsd-type-parameters-title\" }, \"Type Parameters\"),\n        context.typeParameters(props.typeParameters))),\n    props.type instanceof models_1.ReflectionType && (utils_1.JSX.createElement(\"div\", { class: \"tsd-type-declaration\" },\n        utils_1.JSX.createElement(\"h4\", null, \"Type declaration\"),\n        context.parameter(props.type.declaration)))));\nexports.memberDeclaration = memberDeclaration;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberGetterSetter = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst memberGetterSetter = (context, props) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n    utils_1.JSX.createElement(\"ul\", { class: \"tsd-signatures \" + props.cssClasses },\n        !!props.getSignature && (utils_1.JSX.createElement(\"li\", { class: \"tsd-signature tsd-kind-icon\" },\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"get\"),\n            \" \",\n            props.name,\n            context.memberSignatureTitle(props.getSignature, { hideName: true }))),\n        !!props.setSignature && (utils_1.JSX.createElement(\"li\", { class: \"tsd-signature tsd-kind-icon\" },\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"set\"),\n            \" \",\n            props.name,\n            context.memberSignatureTitle(props.setSignature, { hideName: true })))),\n    utils_1.JSX.createElement(\"ul\", { class: \"tsd-descriptions\" },\n        !!props.getSignature && utils_1.JSX.createElement(\"li\", { class: \"tsd-description\" }, context.memberSignatureBody(props.getSignature)),\n        !!props.setSignature && utils_1.JSX.createElement(\"li\", { class: \"tsd-description\" }, context.memberSignatureBody(props.setSignature)))));\nexports.memberGetterSetter = memberGetterSetter;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberReference = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst memberReference = ({ urlTo }, props) => {\n    const referenced = props.tryGetTargetReflectionDeep();\n    if (!referenced) {\n        return utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            \"Re-exports \",\n            props.name);\n    }\n    if (props.name === referenced.name) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            \"Re-exports \",\n            utils_1.JSX.createElement(\"a\", { href: urlTo(referenced) }, referenced.name)));\n    }\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        \"Renames and re-exports \",\n        utils_1.JSX.createElement(\"a\", { href: urlTo(referenced) }, referenced.name)));\n};\nexports.memberReference = memberReference;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberSignatureBody = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst models_1 = require(\"../../../../models\");\nconst lib_1 = require(\"../../lib\");\nconst memberSignatureBody = (context, props, { hideSources = false } = {}) => {\n    var _a;\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        !hideSources && context.memberSources(props),\n        context.comment(props),\n        !!props.typeParameters && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"h4\", { class: \"tsd-type-parameters-title\" }, \"Type Parameters\"),\n            context.typeParameters(props.typeParameters))),\n        props.parameters && props.parameters.length > 0 && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"h4\", { class: \"tsd-parameters-title\" }, \"Parameters\"),\n            utils_1.JSX.createElement(\"ul\", { class: \"tsd-parameters\" }, props.parameters.map((item) => (utils_1.JSX.createElement(\"li\", null,\n                utils_1.JSX.createElement(\"h5\", null,\n                    (0, lib_1.renderFlags)(item.flags),\n                    !!item.flags.isRest && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"...\"),\n                    item.name,\n                    \": \",\n                    context.type(item.type),\n                    item.defaultValue != null && (utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                        \" = \",\n                        item.defaultValue))),\n                context.comment(item),\n                item.type instanceof models_1.ReflectionType && context.parameter(item.type.declaration))))))),\n        props.type && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"h4\", { class: \"tsd-returns-title\" },\n                \"Returns \",\n                context.type(props.type)),\n            !!((_a = props.comment) === null || _a === void 0 ? void 0 : _a.returns) && (utils_1.JSX.createElement(\"div\", null,\n                utils_1.JSX.createElement(utils_1.Raw, { html: context.markdown(props.comment.returns) }))),\n            props.type instanceof models_1.ReflectionType && context.parameter(props.type.declaration)))));\n};\nexports.memberSignatureBody = memberSignatureBody;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberSignatureTitle = void 0;\nconst lib_1 = require(\"../../lib\");\nconst utils_1 = require(\"../../../../utils\");\nconst memberSignatureTitle = (context, props, { hideName = false, arrowStyle = false } = {}) => {\n    var _a;\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        !hideName ? ((0, lib_1.wbr)(props.name)) : (utils_1.JSX.createElement(utils_1.JSX.Fragment, null, props.kindString === \"Constructor signature\" && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            !!props.flags.isAbstract && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"abstract \"),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"new \"))))),\n        (0, lib_1.renderTypeParametersSignature)(props.typeParameters),\n        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(\"),\n        (0, lib_1.join)(\", \", (_a = props.parameters) !== null && _a !== void 0 ? _a : [], (item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            !!item.flags.isRest && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"...\"),\n            item.name,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                !!item.flags.isOptional && \"?\",\n                !!item.defaultValue && \"?\",\n                \": \"),\n            context.type(item.type)))),\n        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \")\"),\n        !!props.type && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, arrowStyle ? \" => \" : \": \"),\n            context.type(props.type)))));\n};\nexports.memberSignatureTitle = memberSignatureTitle;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberSignatures = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst memberSignatures = (context, props) => {\n    var _a, _b;\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        utils_1.JSX.createElement(\"ul\", { class: \"tsd-signatures \" + props.cssClasses }, (_a = props.signatures) === null || _a === void 0 ? void 0 : _a.map((item) => (utils_1.JSX.createElement(\"li\", { class: \"tsd-signature tsd-kind-icon\" }, context.memberSignatureTitle(item))))),\n        utils_1.JSX.createElement(\"ul\", { class: \"tsd-descriptions\" }, (_b = props.signatures) === null || _b === void 0 ? void 0 : _b.map((item) => (utils_1.JSX.createElement(\"li\", { class: \"tsd-description\" }, context.memberSignatureBody(item)))))));\n};\nexports.memberSignatures = memberSignatures;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memberSources = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst memberSources = (context, props) => {\n    const sources = [];\n    if (props.implementationOf) {\n        sources.push(utils_1.JSX.createElement(\"p\", null,\n            \"Implementation of \",\n            context.typeAndParent(props.implementationOf)));\n    }\n    if (props.inheritedFrom) {\n        sources.push(utils_1.JSX.createElement(\"p\", null,\n            \"Inherited from \",\n            context.typeAndParent(props.inheritedFrom)));\n    }\n    if (props.overwrites) {\n        sources.push(utils_1.JSX.createElement(\"p\", null,\n            \"Overrides \",\n            context.typeAndParent(props.overwrites)));\n    }\n    if (props.sources) {\n        sources.push(utils_1.JSX.createElement(\"ul\", null, props.sources.map((item) => item.url ? (utils_1.JSX.createElement(\"li\", null,\n            \"Defined in \",\n            utils_1.JSX.createElement(\"a\", { href: item.url },\n                item.fileName,\n                \":\",\n                item.line))) : (utils_1.JSX.createElement(\"li\", null,\n            \"Defined in \",\n            item.fileName,\n            \":\",\n            item.line)))));\n    }\n    if (sources.length === 0) {\n        return utils_1.JSX.createElement(utils_1.JSX.Fragment, null);\n    }\n    return utils_1.JSX.createElement(\"aside\", { class: \"tsd-sources\" }, sources);\n};\nexports.memberSources = memberSources;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.members = void 0;\nconst utils_1 = require(\"../../../../utils\");\nfunction members(context, props) {\n    var _a;\n    if (props.categories && props.categories.length) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null, props.categories.map((item) => !item.allChildrenHaveOwnDocument() && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel-group tsd-member-group \" + props.cssClasses },\n            utils_1.JSX.createElement(\"h2\", null, item.title),\n            item.children.map((item) => !item.hasOwnDocument && context.member(item)))))));\n    }\n    return utils_1.JSX.createElement(utils_1.JSX.Fragment, null, (_a = props.groups) === null || _a === void 0 ? void 0 : _a.map((item) => !item.allChildrenHaveOwnDocument() && context.membersGroup(item)));\n}\nexports.members = members;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.membersGroup = void 0;\nconst utils_1 = require(\"../../../../utils\");\nfunction membersGroup(context, group) {\n    if (group.categories) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null, group.categories.map((item) => (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel-group tsd-member-group \" + group.cssClasses },\n            utils_1.JSX.createElement(\"h2\", null,\n                !!item.title && utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                    item.title,\n                    \" \"),\n                group.title),\n            item.children.map((item) => !item.hasOwnDocument && context.member(item)))))));\n    }\n    return (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel-group tsd-member-group \" + group.cssClasses },\n        utils_1.JSX.createElement(\"h2\", null, group.title),\n        group.children.map((item) => !item.hasOwnDocument && context.member(item))));\n}\nexports.membersGroup = membersGroup;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.navigation = void 0;\nconst models_1 = require(\"../../../../models\");\nconst utils_1 = require(\"../../../../utils\");\nconst lib_1 = require(\"../../lib\");\nfunction navigation(context, props) {\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        primaryNavigation(context, props),\n        secondaryNavigation(context, props)));\n}\nexports.navigation = navigation;\nfunction primaryNavigation(context, props) {\n    // Create the navigation for the current page:\n    // If there are modules marked as \"external\" then put them in their own group.\n    const modules = props.model.project.getChildrenByKind(models_1.ReflectionKind.SomeModule);\n    const projectLinkName = modules.some((m) => m.kindOf(models_1.ReflectionKind.Module)) ? \"Modules\" : \"Exports\";\n    const [ext, int] = (0, utils_1.partition)(modules, (m) => m.flags.isExternal);\n    if (ext.length === 0) {\n        return (utils_1.JSX.createElement(\"nav\", { class: \"tsd-navigation primary\" },\n            utils_1.JSX.createElement(\"ul\", null,\n                utils_1.JSX.createElement(\"li\", { class: (0, lib_1.classNames)({ current: props.model.isProject() }) },\n                    utils_1.JSX.createElement(\"a\", { href: context.urlTo(props.model.project) }, projectLinkName)),\n                int.map(link))));\n    }\n    return (utils_1.JSX.createElement(\"nav\", { class: \"tsd-navigation primary\" },\n        utils_1.JSX.createElement(\"ul\", null,\n            utils_1.JSX.createElement(\"li\", { class: (0, lib_1.classNames)({ current: props.model.isProject() }) },\n                utils_1.JSX.createElement(\"a\", { href: context.urlTo(props.model.project) }, projectLinkName)),\n            utils_1.JSX.createElement(\"li\", { class: \"label tsd-is-external\" },\n                utils_1.JSX.createElement(\"span\", null, \"Internals\")),\n            int.map(link),\n            utils_1.JSX.createElement(\"li\", { class: \"label tsd-is-external\" },\n                utils_1.JSX.createElement(\"span\", null, \"Externals\")),\n            ext.map(link))));\n    function link(mod) {\n        var _a;\n        const current = inPath(mod, props.model);\n        let childNav;\n        if (current) {\n            const childModules = (_a = mod.children) === null || _a === void 0 ? void 0 : _a.filter((m) => m.kindOf(models_1.ReflectionKind.SomeModule));\n            if (childModules === null || childModules === void 0 ? void 0 : childModules.length) {\n                childNav = utils_1.JSX.createElement(\"ul\", null, childModules.map(link));\n            }\n        }\n        return (utils_1.JSX.createElement(\"li\", { class: (0, lib_1.classNames)({ current }) + \" \" + mod.cssClasses },\n            utils_1.JSX.createElement(\"a\", { href: context.urlTo(mod) }, (0, lib_1.wbr)(mod.name)),\n            childNav));\n    }\n}\nfunction secondaryNavigation(context, props) {\n    const children = props.model instanceof models_1.ContainerReflection ? props.model.children || [] : [];\n    // Multiple entry points, and on main project page.\n    if (props.model.isProject() && props.model.getChildrenByKind(models_1.ReflectionKind.Module).length) {\n        return;\n    }\n    // TODO: TypeDoc 0.21 did special things here. If there were more than 40\n    // children of this page's parent, it only displayed this page's children.\n    // Otherwise, it displayed *everything*. For now, only display page children.\n    // It seems weird to do this according to a random hardcoded number. At the very\n    // least this should be added as a configurable flag, but maybe even the whole\n    // behavior should be configurable globally...\n    const pageNavigation = (utils_1.JSX.createElement(\"ul\", null, children\n        .filter((child) => !child.kindOf(models_1.ReflectionKind.SomeModule))\n        .map((child) => {\n        return (utils_1.JSX.createElement(\"li\", { class: child.cssClasses },\n            utils_1.JSX.createElement(\"a\", { href: context.urlTo(child), class: \"tsd-kind-icon\" }, (0, lib_1.wbr)(child.name))));\n    })));\n    if (props.model.kindOf(models_1.ReflectionKind.SomeModule | models_1.ReflectionKind.Project)) {\n        return utils_1.JSX.createElement(\"nav\", { class: \"tsd-navigation secondary menu-sticky\" }, pageNavigation);\n    }\n    return (utils_1.JSX.createElement(\"nav\", { class: \"tsd-navigation secondary menu-sticky\" },\n        utils_1.JSX.createElement(\"ul\", null,\n            utils_1.JSX.createElement(\"li\", { class: \"current \" + props.model.cssClasses },\n                utils_1.JSX.createElement(\"a\", { href: context.urlTo(props.model), class: \"tsd-kind-icon\" }, (0, lib_1.wbr)(props.model.name)),\n                pageNavigation))));\n}\nfunction inPath(thisPage, toCheck) {\n    while (toCheck) {\n        if (toCheck.isProject())\n            return false;\n        if (thisPage === toCheck)\n            return true;\n        toCheck = toCheck.parent;\n    }\n    return false;\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parameter = void 0;\nconst lib_1 = require(\"../../lib\");\nconst utils_1 = require(\"../../../../utils\");\nconst models_1 = require(\"../../../../models\");\nconst parameter = (context, props) => {\n    var _a, _b, _c;\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        utils_1.JSX.createElement(\"ul\", { class: \"tsd-parameters\" },\n            !!props.signatures && (utils_1.JSX.createElement(\"li\", { class: \"tsd-parameter-signature\" },\n                utils_1.JSX.createElement(\"ul\", { class: \"tsd-signatures \" + props.cssClasses }, props.signatures.map((item) => (utils_1.JSX.createElement(\"li\", { class: \"tsd-signature tsd-kind-icon\" }, context.memberSignatureTitle(item, { hideName: true }))))),\n                utils_1.JSX.createElement(\"ul\", { class: \"tsd-descriptions\" }, props.signatures.map((item) => (utils_1.JSX.createElement(\"li\", { class: \"tsd-description\" }, context.memberSignatureBody(item, { hideSources: true }))))))),\n            !!props.indexSignature && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"li\", { class: \"tsd-parameter-index-signature\" },\n                    utils_1.JSX.createElement(\"h5\", null,\n                        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"[\"), (_b = (_a = props.indexSignature) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 :\n                        _b.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                            !!item.flags.isRest && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"...\"),\n                            item.name,\n                            \": \",\n                            context.type(item.type)))),\n                        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"]: \"),\n                        context.type(props.indexSignature.type)),\n                    context.comment(props.indexSignature),\n                    props.indexSignature.type instanceof models_1.ReflectionType &&\n                        context.parameter(props.indexSignature.type.declaration)))), (_c = props.children) === null || _c === void 0 ? void 0 :\n            _c.map((item) => {\n                var _a;\n                return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null, item.signatures ? (utils_1.JSX.createElement(\"li\", { class: \"tsd-parameter\" },\n                    utils_1.JSX.createElement(\"h5\", null,\n                        !!item.flags.isRest && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"...\"),\n                        (0, lib_1.wbr)(item.name),\n                        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                            !!item.flags.isOptional && \"?\",\n                            \":\"),\n                        \"function\"),\n                    context.memberSignatures(item))) : item.type ? (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                    utils_1.JSX.createElement(\"li\", { class: \"tsd-parameter\" },\n                        utils_1.JSX.createElement(\"h5\", null,\n                            (0, lib_1.renderFlags)(item.flags),\n                            !!item.flags.isRest && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"...\"),\n                            (0, lib_1.wbr)(item.name),\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                                !!item.flags.isOptional && \"?\",\n                                \": \"),\n                            context.type(item.type)),\n                        context.comment(item),\n                        !!item.children && context.parameter(item),\n                        item.type instanceof models_1.ReflectionType && context.parameter(item.type.declaration)))) : (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                    item.getSignature && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                        utils_1.JSX.createElement(\"li\", { class: \"tsd-parameter\" },\n                            utils_1.JSX.createElement(\"h5\", null,\n                                (0, lib_1.renderFlags)(item.getSignature.flags),\n                                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"get \"),\n                                (0, lib_1.wbr)(item.name),\n                                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(): \"),\n                                context.type(item.getSignature.type)),\n                            context.comment(item.getSignature)))),\n                    item.setSignature && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                        utils_1.JSX.createElement(\"li\", { class: \"tsd-parameter\" },\n                            utils_1.JSX.createElement(\"h5\", null,\n                                (0, lib_1.renderFlags)(item.setSignature.flags),\n                                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"set \"),\n                                (0, lib_1.wbr)(item.name),\n                                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(\"), (_a = item.setSignature.parameters) === null || _a === void 0 ? void 0 :\n                                _a.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                                    item.name,\n                                    utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \": \"),\n                                    context.type(item.type)))),\n                                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"): \"),\n                                context.type(item.setSignature.type)),\n                            context.comment(item.setSignature))))))));\n            }))));\n};\nexports.parameter = parameter;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.type = void 0;\nconst models_1 = require(\"../../../../models\");\nconst utils_1 = require(\"../../../../utils\");\nconst lib_1 = require(\"../../lib\");\nconst EXPORTABLE = models_1.ReflectionKind.Class |\n    models_1.ReflectionKind.Interface |\n    models_1.ReflectionKind.Enum |\n    models_1.ReflectionKind.TypeAlias |\n    models_1.ReflectionKind.Function |\n    models_1.ReflectionKind.Variable;\nconst nameCollisionCache = new WeakMap();\nfunction getNameCollisionCount(project, name) {\n    var _a, _b;\n    let collisions = nameCollisionCache.get(project);\n    if (collisions === undefined) {\n        collisions = {};\n        for (const reflection of project.getReflectionsByKind(EXPORTABLE)) {\n            collisions[reflection.name] = ((_a = collisions[reflection.name]) !== null && _a !== void 0 ? _a : 0) + 1;\n        }\n        nameCollisionCache.set(project, collisions);\n    }\n    return (_b = collisions[name]) !== null && _b !== void 0 ? _b : 0;\n}\n/**\n * Returns a (hopefully) globally unique path for the given reflection.\n *\n * This only works for exportable symbols, so e.g. methods are not affected by this.\n *\n * If the given reflection has a globally unique name already, then it will be returned as is. If the name is\n * ambiguous (i.e. there are two classes with the same name in different namespaces), then the namespaces path of the\n * reflection will be returned.\n */\nfunction getUniquePath(reflection) {\n    if (reflection.kindOf(EXPORTABLE)) {\n        if (getNameCollisionCount(reflection.project, reflection.name) >= 2) {\n            return getNamespacedPath(reflection);\n        }\n    }\n    return [reflection];\n}\nfunction getNamespacedPath(reflection) {\n    const path = [reflection];\n    let parent = reflection.parent;\n    while (parent && parent.kindOf(models_1.ReflectionKind.Namespace)) {\n        path.unshift(parent);\n        parent = parent.parent;\n    }\n    return path;\n}\nfunction renderUniquePath(context, reflection) {\n    return (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \".\"), getUniquePath(reflection), (item) => (utils_1.JSX.createElement(\"a\", { href: context.urlTo(item), class: \"tsd-signature-type\", \"data-tsd-kind\": item.kindString }, item.name)));\n}\n// The type helper accepts an optional needsParens parameter that is checked\n// if an inner type may result in invalid output without them. For example:\n// 1 | 2[] !== (1 | 2)[]\n// () => 1 | 2 !== (() => 1) | 2\nconst typeRenderers = {\n    array(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            renderType(context, type.elementType, models_1.TypeContext.arrayElement),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"[]\")));\n    },\n    conditional(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            renderType(context, type.checkType, models_1.TypeContext.conditionalCheck),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" extends \"),\n            renderType(context, type.extendsType, models_1.TypeContext.conditionalExtends),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" ? \"),\n            renderType(context, type.trueType, models_1.TypeContext.conditionalTrue),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" : \"),\n            renderType(context, type.falseType, models_1.TypeContext.conditionalFalse)));\n    },\n    indexedAccess(context, type) {\n        let indexType = renderType(context, type.indexType, models_1.TypeContext.indexedIndex);\n        if (type.objectType instanceof models_1.ReferenceType &&\n            type.objectType.reflection &&\n            type.indexType instanceof models_1.LiteralType &&\n            typeof type.indexType.value === \"string\") {\n            const childReflection = type.objectType.reflection.getChildByName([type.indexType.value]);\n            if (childReflection) {\n                indexType = utils_1.JSX.createElement(\"a\", { href: context.urlTo(childReflection) }, indexType);\n            }\n        }\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            renderType(context, type.objectType, models_1.TypeContext.indexedObject),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"[\"),\n            indexType,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"]\")));\n    },\n    inferred(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"infer \"),\n            \" \",\n            type.name,\n            type.constraint && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" extends \"),\n                renderType(context, type.constraint, models_1.TypeContext.inferredConstraint)))));\n    },\n    intersection(context, type) {\n        return (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" & \"), type.types, (item) => renderType(context, item, models_1.TypeContext.intersectionElement));\n    },\n    intrinsic(_context, type) {\n        return utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, type.name);\n    },\n    literal(_context, type) {\n        return utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, (0, lib_1.stringify)(type.value));\n    },\n    mapped(context, type) {\n        const children = [];\n        switch (type.readonlyModifier) {\n            case \"+\":\n                children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"readonly \"));\n                break;\n            case \"-\":\n                children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"-readonly \"));\n                break;\n        }\n        children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"[ \"), utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, type.parameter), utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" in \"), renderType(context, type.parameterType, models_1.TypeContext.mappedParameter));\n        if (type.nameType) {\n            children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" as \"), renderType(context, type.nameType, models_1.TypeContext.mappedName));\n        }\n        children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"]\"));\n        switch (type.optionalModifier) {\n            case \"+\":\n                children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"?: \"));\n                break;\n            case \"-\":\n                children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"-?: \"));\n                break;\n            default:\n                children.push(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \": \"));\n        }\n        children.push(renderType(context, type.templateType, models_1.TypeContext.mappedTemplate));\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"{\"),\n            \" \",\n            children,\n            \" \",\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"}\")));\n    },\n    \"named-tuple-member\"(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            type.name,\n            type.isOptional ? (utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"?: \")) : (utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \": \")),\n            renderType(context, type.element, models_1.TypeContext.tupleElement)));\n    },\n    optional(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            renderType(context, type.elementType, models_1.TypeContext.optionalElement),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"?\")));\n    },\n    predicate(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            !!type.asserts && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"asserts \"),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, type.name),\n            !!type.targetType && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" is \"),\n                renderType(context, type.targetType, models_1.TypeContext.predicateTarget)))));\n    },\n    query(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"typeof \"),\n            renderType(context, type.queryType, models_1.TypeContext.queryTypeTarget)));\n    },\n    reference(context, type) {\n        var _a;\n        const reflection = type.reflection;\n        let name;\n        if (reflection) {\n            if (reflection.kindOf(models_1.ReflectionKind.TypeParameter)) {\n                // Don't generate a link will always point to this page, but do set the kind.\n                name = (utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\", \"data-tsd-kind\": reflection.kindString }, reflection.name));\n            }\n            else {\n                name = renderUniquePath(context, reflection);\n            }\n        }\n        else {\n            const externalUrl = context.attemptExternalResolution(type);\n            if (externalUrl) {\n                name = (utils_1.JSX.createElement(\"a\", { href: externalUrl, class: \"tsd-signature-type external\", target: \"_blank\" }, type.name));\n            }\n            else {\n                name = utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, type.name);\n            }\n        }\n        if ((_a = type.typeArguments) === null || _a === void 0 ? void 0 : _a.length) {\n            return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                name,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"<\"),\n                (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \", \"), type.typeArguments, (item) => renderType(context, item, models_1.TypeContext.referenceTypeArgument)),\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \">\")));\n        }\n        return name;\n    },\n    reflection(context, type) {\n        var _a;\n        if (type.declaration.children) {\n            // Object literal\n            return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"{ \"),\n                (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"; \"), type.declaration.children, (item) => {\n                    var _a;\n                    if (item.getSignature && item.setSignature) {\n                        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                            item.name,\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \": \"),\n                            renderType(context, item.getSignature.type, models_1.TypeContext.none)));\n                    }\n                    if (item.getSignature) {\n                        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"get \"),\n                            item.name,\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(): \"),\n                            renderType(context, item.getSignature.type, models_1.TypeContext.none)));\n                    }\n                    if (item.setSignature) {\n                        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"set \"),\n                            item.name,\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(\"), (_a = item.setSignature.parameters) === null || _a === void 0 ? void 0 :\n                            _a.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                                item.name,\n                                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \": \"),\n                                renderType(context, item.type, models_1.TypeContext.none)))),\n                            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \")\")));\n                    }\n                    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                        item.name,\n                        utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, item.flags.isOptional ? \"?: \" : \": \"),\n                        renderType(context, item.type, models_1.TypeContext.none)));\n                }),\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" }\")));\n        }\n        if (((_a = type.declaration.signatures) === null || _a === void 0 ? void 0 : _a.length) === 1) {\n            return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(\"),\n                context.memberSignatureTitle(type.declaration.signatures[0], {\n                    hideName: true,\n                    arrowStyle: true,\n                }),\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \")\")));\n        }\n        if (type.declaration.signatures) {\n            return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                    \"{\",\n                    \" \"),\n                (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"; \"), type.declaration.signatures, (item) => context.memberSignatureTitle(item, { hideName: true })),\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" }\")));\n        }\n        return utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"{}\");\n    },\n    rest(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"...\"),\n            renderType(context, type.elementType, models_1.TypeContext.restElement)));\n    },\n    \"template-literal\"(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"`\"),\n            type.head && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, type.head),\n            type.tail.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"${\"),\n                renderType(context, item[0], models_1.TypeContext.templateLiteralElement),\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"}\"),\n                item[1] && utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, item[1])))),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"`\")));\n    },\n    tuple(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"[\"),\n            (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \", \"), type.elements, (item) => renderType(context, item, models_1.TypeContext.tupleElement)),\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"]\")));\n    },\n    typeOperator(context, type) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" },\n                type.operator,\n                \" \"),\n            renderType(context, type.target, models_1.TypeContext.typeOperatorTarget)));\n    },\n    union(context, type) {\n        return (0, lib_1.join)(utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" | \"), type.types, (item) => renderType(context, item, models_1.TypeContext.unionElement));\n    },\n    unknown(_context, type) {\n        return utils_1.JSX.createElement(utils_1.JSX.Fragment, null, type.name);\n    },\n};\nfunction renderType(context, type, where) {\n    if (!type) {\n        return utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-type\" }, \"any\");\n    }\n    const renderFn = typeRenderers[type.type];\n    const rendered = renderFn(context, type);\n    if (type.needsParenthesis(where)) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"(\"),\n            rendered,\n            utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \")\")));\n    }\n    return rendered;\n}\nfunction type(context, type) {\n    return renderType(context, type, models_1.TypeContext.none);\n}\nexports.type = type;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.typeAndParent = void 0;\nconst models_1 = require(\"../../../../models\");\nconst utils_1 = require(\"../../../../utils\");\nconst typeAndParent = (context, props) => {\n    if (!props)\n        return utils_1.JSX.createElement(utils_1.JSX.Fragment, null, \"void\");\n    if (props instanceof models_1.ArrayType) {\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            context.typeAndParent(props.elementType),\n            \"[]\"));\n    }\n    if (props instanceof models_1.ReferenceType && props.reflection) {\n        const refl = props.reflection instanceof models_1.SignatureReflection ? props.reflection.parent : props.reflection;\n        const parent = refl === null || refl === void 0 ? void 0 : refl.parent;\n        return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            (parent === null || parent === void 0 ? void 0 : parent.url) ? utils_1.JSX.createElement(\"a\", { href: context.urlTo(parent) }, parent.name) : parent === null || parent === void 0 ? void 0 : parent.name,\n            \".\",\n            (refl === null || refl === void 0 ? void 0 : refl.url) ? utils_1.JSX.createElement(\"a\", { href: context.urlTo(refl) }, refl.name) : refl === null || refl === void 0 ? void 0 : refl.name));\n    }\n    return utils_1.JSX.createElement(utils_1.JSX.Fragment, null, props.toString());\n};\nexports.typeAndParent = typeAndParent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.typeParameters = void 0;\nconst utils_1 = require(\"../../../../utils\");\nfunction typeParameters(context, typeParameters) {\n    return (utils_1.JSX.createElement(\"ul\", { class: \"tsd-type-parameters\" }, typeParameters === null || typeParameters === void 0 ? void 0 : typeParameters.map((item) => (utils_1.JSX.createElement(\"li\", null,\n        utils_1.JSX.createElement(\"h4\", null,\n            item.varianceModifier ? `${item.varianceModifier} ` : \"\",\n            item.name,\n            !!item.type && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \" extends \"),\n                context.type(item.type))),\n            !!item.default && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                \" = \",\n                context.type(item.default)))),\n        context.comment(item))))));\n}\nexports.typeParameters = typeParameters;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indexTemplate = void 0;\nconst utils_1 = require(\"../../../../utils\");\nconst indexTemplate = ({ markdown }, props) => (utils_1.JSX.createElement(\"div\", { class: \"tsd-panel tsd-typography\" },\n    utils_1.JSX.createElement(utils_1.Raw, { html: markdown(props.model.readme) })));\nexports.indexTemplate = indexTemplate;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reflectionTemplate = void 0;\nconst lib_1 = require(\"../../lib\");\nconst models_1 = require(\"../../../../models\");\nconst utils_1 = require(\"../../../../utils\");\nconst reflectionTemplate = (context, props) => {\n    var _a;\n    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n        props.model.hasComment() && utils_1.JSX.createElement(\"section\", { class: \"tsd-panel tsd-comment\" }, context.comment(props.model)),\n        (0, lib_1.hasTypeParameters)(props.model) && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel tsd-type-parameters\" },\n            utils_1.JSX.createElement(\"h3\", null, \"Type Parameters\"),\n            context.typeParameters(props.model.typeParameters))),\n        props.model instanceof models_1.DeclarationReflection && (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n            !!props.model.typeHierarchy && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel tsd-hierarchy\" },\n                utils_1.JSX.createElement(\"h3\", null, \"Hierarchy\"),\n                context.hierarchy(props.model.typeHierarchy))),\n            !!props.model.implementedTypes && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel\" },\n                utils_1.JSX.createElement(\"h3\", null, \"Implements\"),\n                utils_1.JSX.createElement(\"ul\", { class: \"tsd-hierarchy\" }, props.model.implementedTypes.map((item) => (utils_1.JSX.createElement(\"li\", null, context.type(item))))))),\n            !!props.model.implementedBy && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel\" },\n                utils_1.JSX.createElement(\"h3\", null, \"Implemented by\"),\n                utils_1.JSX.createElement(\"ul\", { class: \"tsd-hierarchy\" }, props.model.implementedBy.map((item) => (utils_1.JSX.createElement(\"li\", null, context.type(item))))))),\n            !!props.model.signatures && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel\" },\n                utils_1.JSX.createElement(\"h3\", { class: \"tsd-before-signature\" }, \"Callable\"),\n                context.memberSignatures(props.model))),\n            !!props.model.indexSignature && (utils_1.JSX.createElement(\"section\", { class: \"tsd-panel \" + props.model.cssClasses },\n                utils_1.JSX.createElement(\"h3\", { class: \"tsd-before-signature\" }, \"Indexable\"),\n                utils_1.JSX.createElement(\"div\", { class: \"tsd-signature tsd-kind-icon\" },\n                    utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"[\"),\n                    props.model.indexSignature.parameters.map((item) => (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,\n                        item.name,\n                        \": \",\n                        context.type(item.type)))),\n                    utils_1.JSX.createElement(\"span\", { class: \"tsd-signature-symbol\" }, \"]:\"),\n                    context.type(props.model.indexSignature.type)),\n                context.comment(props.model.indexSignature),\n                ((_a = props.model.indexSignature) === null || _a === void 0 ? void 0 : _a.type) instanceof models_1.ReflectionType &&\n                    context.parameter(props.model.indexSignature.type.declaration))))),\n        context.index(props.model),\n        context.members(props.model)));\n};\nexports.reflectionTemplate = reflectionTemplate;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStyles = exports.highlight = exports.getSupportedLanguages = exports.isSupportedLanguage = exports.loadHighlighter = void 0;\nconst assert_1 = require(\"assert\");\nconst shiki_1 = require(\"shiki\");\nconst array_1 = require(\"./array\");\nconst JSX = require(\"./jsx\");\nconst aliases = new Map();\nfor (const lang of shiki_1.BUNDLED_LANGUAGES) {\n    for (const alias of lang.aliases || []) {\n        aliases.set(alias, lang.id);\n    }\n}\nconst supportedLanguages = (0, array_1.unique)([\"text\", ...aliases.keys(), ...shiki_1.BUNDLED_LANGUAGES.map((lang) => lang.id)]).sort();\nclass DoubleHighlighter {\n    constructor(highlighter, light, dark) {\n        this.highlighter = highlighter;\n        this.light = light;\n        this.dark = dark;\n        this.schemes = new Map();\n    }\n    highlight(code, lang) {\n        const lightTokens = this.highlighter.codeToThemedTokens(code, lang, this.light, { includeExplanation: false });\n        const darkTokens = this.highlighter.codeToThemedTokens(code, lang, this.dark, { includeExplanation: false });\n        // If this fails... something went *very* wrong.\n        (0, assert_1.ok)(lightTokens.length === darkTokens.length);\n        const docEls = [];\n        for (let line = 0; line < lightTokens.length; line++) {\n            const lightLine = lightTokens[line];\n            const darkLine = darkTokens[line];\n            // Different themes can have different grammars... so unfortunately we have to deal with different\n            // sets of tokens.Example: light_plus and dark_plus tokenize \" = \" differently in the `schemes`\n            // declaration for this file.\n            const lineEls = [];\n            while (lightLine.length && darkLine.length) {\n                // Simple case, same token.\n                if (lightLine[0].content === darkLine[0].content) {\n                    lineEls.push(JSX.createElement(\"span\", { class: this.getClass(lightLine[0].color, darkLine[0].color) }, lightLine[0].content));\n                    lightLine.shift();\n                    darkLine.shift();\n                    continue;\n                }\n                if (lightLine[0].content.length < darkLine[0].content.length) {\n                    lineEls.push(JSX.createElement(\"span\", { class: this.getClass(lightLine[0].color, darkLine[0].color) }, lightLine[0].content));\n                    darkLine[0].content = darkLine[0].content.substr(lightLine[0].content.length);\n                    lightLine.shift();\n                    continue;\n                }\n                lineEls.push(JSX.createElement(\"span\", { class: this.getClass(lightLine[0].color, darkLine[0].color) }, darkLine[0].content));\n                lightLine[0].content = lightLine[0].content.substr(darkLine[0].content.length);\n                darkLine.shift();\n            }\n            if (line + 1 !== lightTokens.length) {\n                lineEls.push(JSX.createElement(\"br\", null));\n            }\n            docEls.push(lineEls);\n        }\n        return JSX.renderElement(JSX.createElement(JSX.Fragment, null, docEls));\n    }\n    getStyles() {\n        const style = [\":root {\"];\n        const lightRules = [];\n        const darkRules = [];\n        let i = 0;\n        for (const key of this.schemes.keys()) {\n            const [light, dark] = key.split(\" | \");\n            style.push(`    --light-hl-${i}: ${light};`);\n            style.push(`    --dark-hl-${i}: ${dark};`);\n            lightRules.push(`    --hl-${i}: var(--light-hl-${i});`);\n            darkRules.push(`    --hl-${i}: var(--dark-hl-${i});`);\n            i++;\n        }\n        // GH#1836, our page background is white, but it would be nice to be able to see\n        // a difference between the code blocks and the background of the page. There's\n        // probably a better solution to this... revisit once #1794 is merged.\n        let lightBackground = this.highlighter.getTheme(this.light).bg;\n        if (isWhite(lightBackground)) {\n            lightBackground = \"#F5F5F5\";\n        }\n        style.push(`    --light-code-background: ${lightBackground};`);\n        style.push(`    --dark-code-background: ${this.highlighter.getTheme(this.dark).bg};`);\n        lightRules.push(`    --code-background: var(--light-code-background);`);\n        darkRules.push(`    --code-background: var(--dark-code-background);`);\n        style.push(\"}\", \"\");\n        style.push(\"@media (prefers-color-scheme: light) { :root {\");\n        style.push(...lightRules);\n        style.push(\"} }\", \"\");\n        style.push(\"@media (prefers-color-scheme: dark) { :root {\");\n        style.push(...darkRules);\n        style.push(\"} }\", \"\");\n        style.push(\"body.light {\");\n        style.push(...lightRules);\n        style.push(\"}\", \"\");\n        style.push(\"body.dark {\");\n        style.push(...darkRules);\n        style.push(\"}\", \"\");\n        for (i = 0; i < this.schemes.size; i++) {\n            style.push(`.hl-${i} { color: var(--hl-${i}); }`);\n        }\n        style.push(\"pre, code { background: var(--code-background); }\", \"\");\n        return style.join(\"\\n\");\n    }\n    getClass(lightColor, darkColor) {\n        const key = `${lightColor} | ${darkColor}`;\n        let scheme = this.schemes.get(key);\n        if (scheme == null) {\n            scheme = `hl-${this.schemes.size}`;\n            this.schemes.set(key, scheme);\n        }\n        return scheme;\n    }\n}\nlet highlighter;\nasync function loadHighlighter(lightTheme, darkTheme) {\n    if (highlighter)\n        return;\n    const hl = await (0, shiki_1.getHighlighter)({ themes: [lightTheme, darkTheme] });\n    highlighter = new DoubleHighlighter(hl, lightTheme, darkTheme);\n}\nexports.loadHighlighter = loadHighlighter;\nfunction isSupportedLanguage(lang) {\n    return getSupportedLanguages().includes(lang);\n}\nexports.isSupportedLanguage = isSupportedLanguage;\nfunction getSupportedLanguages() {\n    return supportedLanguages;\n}\nexports.getSupportedLanguages = getSupportedLanguages;\nfunction highlight(code, lang) {\n    var _a;\n    (0, assert_1.ok)(highlighter, \"Tried to highlight with an uninitialized highlighter\");\n    if (!isSupportedLanguage(lang)) {\n        return code;\n    }\n    if (lang === \"text\") {\n        return JSX.renderElement(JSX.createElement(JSX.Fragment, null, code));\n    }\n    return highlighter.highlight(code, (_a = aliases.get(lang)) !== null && _a !== void 0 ? _a : lang);\n}\nexports.highlight = highlight;\nfunction getStyles() {\n    (0, assert_1.ok)(highlighter, \"Tried to highlight with an uninitialized highlighter\");\n    return highlighter.getStyles();\n}\nexports.getStyles = getStyles;\nfunction isWhite(color) {\n    const colors = new Set(color.toLowerCase().replace(/[^a-f0-9]/g, \"\"));\n    return colors.size === 1 && colors.has(\"f\");\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LegendPlugin = exports.MarkedPlugin = exports.MarkedLinksPlugin = exports.JavascriptIndexPlugin = exports.AssetsPlugin = void 0;\nvar AssetsPlugin_1 = require(\"./AssetsPlugin\");\nObject.defineProperty(exports, \"AssetsPlugin\", { enumerable: true, get: function () { return AssetsPlugin_1.AssetsPlugin; } });\nvar JavascriptIndexPlugin_1 = require(\"./JavascriptIndexPlugin\");\nObject.defineProperty(exports, \"JavascriptIndexPlugin\", { enumerable: true, get: function () { return JavascriptIndexPlugin_1.JavascriptIndexPlugin; } });\nvar MarkedLinksPlugin_1 = require(\"./MarkedLinksPlugin\");\nObject.defineProperty(exports, \"MarkedLinksPlugin\", { enumerable: true, get: function () { return MarkedLinksPlugin_1.MarkedLinksPlugin; } });\nvar MarkedPlugin_1 = require(\"../themes/MarkedPlugin\");\nObject.defineProperty(exports, \"MarkedPlugin\", { enumerable: true, get: function () { return MarkedPlugin_1.MarkedPlugin; } });\nvar LegendPlugin_1 = require(\"./LegendPlugin\");\nObject.defineProperty(exports, \"LegendPlugin\", { enumerable: true, get: function () { return LegendPlugin_1.LegendPlugin; } });\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AssetsPlugin = void 0;\nconst components_1 = require(\"../components\");\nconst events_1 = require(\"../events\");\nconst fs_1 = require(\"../../utils/fs\");\nconst DefaultTheme_1 = require(\"../themes/default/DefaultTheme\");\nconst highlighter_1 = require(\"../../utils/highlighter\");\nconst utils_1 = require(\"../../utils\");\nconst fs_2 = require(\"fs\");\nconst path_1 = require(\"path\");\n/**\n * A plugin that copies the subdirectory assets from the current themes\n * source folder to the output directory.\n */\nlet AssetsPlugin = class AssetsPlugin extends components_1.RendererComponent {\n    /**\n     * Create a new AssetsPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [events_1.RendererEvent.END]: this.onRenderEnd,\n            [events_1.RendererEvent.BEGIN]: (event) => {\n                const dest = (0, path_1.join)(event.outputDirectory, \"assets\");\n                if (this.customCss) {\n                    if ((0, fs_2.existsSync)(this.customCss)) {\n                        (0, fs_1.copySync)(this.customCss, (0, path_1.join)(dest, \"custom.css\"));\n                    }\n                    else {\n                        this.application.logger.error(`Custom CSS file at ${this.customCss} does not exist.`);\n                        event.preventDefault();\n                    }\n                }\n            },\n        });\n    }\n    /**\n     * Triggered before the renderer starts rendering a project.\n     *\n     * @param event  An event object describing the current render operation.\n     */\n    onRenderEnd(event) {\n        if (this.owner.theme instanceof DefaultTheme_1.DefaultTheme) {\n            const src = (0, path_1.join)(__dirname, \"..\", \"..\", \"..\", \"..\", \"static\");\n            const dest = (0, path_1.join)(event.outputDirectory, \"assets\");\n            (0, fs_1.copySync)(src, dest);\n            (0, fs_1.writeFileSync)((0, path_1.join)(dest, \"highlight.css\"), (0, highlighter_1.getStyles)());\n        }\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"customCss\")\n], AssetsPlugin.prototype, \"customCss\", void 0);\nAssetsPlugin = __decorate([\n    (0, components_1.Component)({ name: \"assets\" })\n], AssetsPlugin);\nexports.AssetsPlugin = AssetsPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JavascriptIndexPlugin = void 0;\nconst Path = require(\"path\");\nconst lunr_1 = require(\"lunr\");\nconst models_1 = require(\"../../models\");\nconst plugins_1 = require(\"../../converter/plugins\");\nconst components_1 = require(\"../components\");\nconst events_1 = require(\"../events\");\nconst utils_1 = require(\"../../utils\");\nconst DefaultTheme_1 = require(\"../themes/default/DefaultTheme\");\n/**\n * A plugin that exports an index of the project to a javascript file.\n *\n * The resulting javascript file can be used to build a simple search function.\n */\nlet JavascriptIndexPlugin = class JavascriptIndexPlugin extends components_1.RendererComponent {\n    /**\n     * Create a new JavascriptIndexPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, events_1.RendererEvent.BEGIN, this.onRendererBegin);\n    }\n    /**\n     * Triggered after a document has been rendered, just before it is written to disc.\n     *\n     * @param event  An event object describing the current render operation.\n     */\n    onRendererBegin(event) {\n        var _a, _b, _c;\n        if (!(this.owner.theme instanceof DefaultTheme_1.DefaultTheme)) {\n            return;\n        }\n        if (event.isDefaultPrevented) {\n            return;\n        }\n        const rows = [];\n        const kinds = {};\n        const kindBoosts = (_a = this.application.options.getValue(\"searchGroupBoosts\")) !== null && _a !== void 0 ? _a : {};\n        for (const reflection of event.project.getReflectionsByKind(models_1.ReflectionKind.All)) {\n            if (!(reflection instanceof models_1.DeclarationReflection)) {\n                continue;\n            }\n            if (!reflection.url ||\n                !reflection.name ||\n                reflection.flags.isExternal ||\n                reflection.name === \"\") {\n                continue;\n            }\n            let parent = reflection.parent;\n            let boost = (_b = reflection.relevanceBoost) !== null && _b !== void 0 ? _b : 1;\n            if (parent instanceof models_1.ProjectReflection) {\n                parent = undefined;\n            }\n            if (!kinds[reflection.kind]) {\n                kinds[reflection.kind] = plugins_1.GroupPlugin.getKindSingular(reflection.kind);\n                const kindBoost = kindBoosts[(_c = kinds[reflection.kind]) !== null && _c !== void 0 ? _c : \"\"];\n                if (kindBoost != undefined) {\n                    boost *= kindBoost;\n                }\n            }\n            const row = {\n                id: rows.length,\n                kind: reflection.kind,\n                name: reflection.name,\n                url: reflection.url,\n                classes: reflection.cssClasses,\n            };\n            if (boost !== 1) {\n                row.boost = boost;\n            }\n            if (parent) {\n                row.parent = parent.getFullName();\n            }\n            rows.push(row);\n        }\n        const builder = new lunr_1.Builder();\n        builder.pipeline.add(lunr_1.trimmer);\n        builder.ref(\"id\");\n        builder.field(\"name\", { boost: 10 });\n        builder.field(\"parent\");\n        rows.forEach((row) => builder.add(row));\n        const index = builder.build();\n        const jsonFileName = Path.join(event.outputDirectory, \"assets\", \"search.js\");\n        const jsonData = JSON.stringify({\n            kinds,\n            rows,\n            index,\n        });\n        (0, utils_1.writeFileSync)(jsonFileName, `window.searchData = JSON.parse(${JSON.stringify(jsonData)});`);\n    }\n};\nJavascriptIndexPlugin = __decorate([\n    (0, components_1.Component)({ name: \"javascript-index\" })\n], JavascriptIndexPlugin);\nexports.JavascriptIndexPlugin = JavascriptIndexPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar MarkedLinksPlugin_1;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarkedLinksPlugin = void 0;\nconst Util = require(\"util\");\nconst components_1 = require(\"../components\");\nconst events_1 = require(\"../events\");\nconst utils_1 = require(\"../../utils\");\n/**\n * A plugin that builds links in markdown texts.\n */\nlet MarkedLinksPlugin = MarkedLinksPlugin_1 = class MarkedLinksPlugin extends components_1.ContextAwareRendererComponent {\n    constructor() {\n        super(...arguments);\n        /**\n         * Regular expression for detecting bracket links.\n         */\n        this.brackets = /\\[\\[([^\\]]+)\\]\\]/g;\n        /**\n         * Regular expression for detecting inline tags like {&amp;link ...}.\n         */\n        this.inlineTag = /(?:\\[(.+?)\\])?\\{@(link|linkcode|linkplain)\\s+((?:.|\\n)+?)\\}/gi;\n        this.warnings = [];\n    }\n    /**\n     * Create a new MarkedLinksPlugin instance.\n     */\n    initialize() {\n        super.initialize();\n        this.listenTo(this.owner, {\n            [events_1.MarkdownEvent.PARSE]: this.onParseMarkdown,\n            [events_1.RendererEvent.END]: this.onEndRenderer,\n        }, undefined, 100);\n    }\n    /**\n     * Find all references to symbols within the given text and transform them into a link.\n     *\n     * This function is aware of the current context and will try to find the symbol within the\n     * current reflection. It will walk up the reflection chain till the symbol is found or the\n     * root reflection is reached. As a last resort the function will search the entire project\n     * for the given symbol.\n     *\n     * @param text  The text that should be parsed.\n     * @returns The text with symbol references replaced by links.\n     */\n    replaceBrackets(text) {\n        return text.replace(this.brackets, (match, content) => {\n            const monospace = content[0] === \"`\" && content[content.length - 1] === \"`\";\n            const split = MarkedLinksPlugin_1.splitLinkText(monospace ? content.slice(1, -1) : content);\n            return this.buildLink(match, split.target, split.caption, monospace);\n        });\n    }\n    /**\n     * Find symbol {&amp;link ...} strings in text and turn into html links\n     *\n     * @param text  The string in which to replace the inline tags.\n     * @return      The updated string.\n     */\n    replaceInlineTags(text) {\n        return text.replace(this.inlineTag, (match, leading, tagName, content) => {\n            const split = MarkedLinksPlugin_1.splitLinkText(content);\n            const target = split.target;\n            const caption = leading || split.caption;\n            const monospace = tagName === \"linkcode\";\n            return this.buildLink(match, target, caption, monospace);\n        });\n    }\n    /**\n     * Format a link with the given text and target.\n     *\n     * @param original   The original link string, will be returned if the target cannot be resolved..\n     * @param target     The link target.\n     * @param caption    The caption of the link.\n     * @param monospace  Whether to use monospace formatting or not.\n     * @returns A html link tag.\n     */\n    buildLink(original, target, caption, monospace) {\n        let attributes = \"\";\n        if (this.urlPrefix.test(target)) {\n            attributes = ' class=\"external\"';\n        }\n        else {\n            let reflection;\n            if (this.reflection) {\n                reflection = this.reflection.findReflectionByName(target);\n            }\n            else if (this.project) {\n                reflection = this.project.findReflectionByName(target);\n            }\n            if (reflection && reflection.url) {\n                if (this.urlPrefix.test(reflection.url)) {\n                    target = reflection.url;\n                    attributes = ' class=\"external\"';\n                }\n                else {\n                    target = this.getRelativeUrl(reflection.url);\n                }\n            }\n            else {\n                const fullName = (this.reflection ||\n                    this.project).getFriendlyFullName();\n                this.warnings.push(`In ${fullName}: ${original}`);\n                return original;\n            }\n        }\n        if (monospace) {\n            caption = \"<code>\" + caption + \"</code>\";\n        }\n        return Util.format('<a href=\"%s\"%s>%s</a>', target, attributes, caption);\n    }\n    /**\n     * Triggered when {@link MarkedPlugin} parses a markdown string.\n     *\n     * @param event\n     */\n    onParseMarkdown(event) {\n        event.parsedText = this.replaceInlineTags(this.replaceBrackets(event.parsedText));\n    }\n    /**\n     * Triggered when {@link Renderer} is finished\n     */\n    onEndRenderer(_event) {\n        const enabled = this.listInvalidSymbolLinks || this.validation.invalidLink;\n        if (this.listInvalidSymbolLinks) {\n            this.application.logger.warn(\"listInvalidSymbolLinks is deprecated and will be removed in 0.23, set validation.invalidLink instead.\");\n        }\n        if (enabled && this.warnings.length > 0) {\n            this.application.logger.warn(\"\\n[MarkedLinksPlugin]: Found invalid symbol reference(s) in JSDocs, \" +\n                \"they will not render as links in the generated documentation.\" +\n                \"\\n  \" +\n                this.warnings.join(\"\\n  \"));\n        }\n        this.warnings = [];\n    }\n    /**\n     * Split the given link into text and target at first pipe or space.\n     *\n     * @param text  The source string that should be checked for a split character.\n     * @returns An object containing the link text and target.\n     */\n    static splitLinkText(text) {\n        let splitIndex = text.indexOf(\"|\");\n        if (splitIndex === -1) {\n            splitIndex = text.search(/\\s/);\n        }\n        if (splitIndex !== -1) {\n            return {\n                caption: text\n                    .substr(splitIndex + 1)\n                    .replace(/\\n+/, \" \")\n                    .trim(),\n                target: text.substr(0, splitIndex).trim(),\n            };\n        }\n        else {\n            return {\n                caption: text,\n                target: text,\n            };\n        }\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"listInvalidSymbolLinks\")\n], MarkedLinksPlugin.prototype, \"listInvalidSymbolLinks\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"validation\")\n], MarkedLinksPlugin.prototype, \"validation\", void 0);\nMarkedLinksPlugin = MarkedLinksPlugin_1 = __decorate([\n    (0, components_1.Component)({ name: \"marked-links\" })\n], MarkedLinksPlugin);\nexports.MarkedLinksPlugin = MarkedLinksPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MarkedPlugin = void 0;\nconst fs = require(\"fs\");\nconst Path = require(\"path\");\nconst Marked = require(\"marked\");\nconst components_1 = require(\"../components\");\nconst events_1 = require(\"../events\");\nconst utils_1 = require(\"../../utils\");\nconst highlighter_1 = require(\"../../utils/highlighter\");\nconst customMarkedRenderer = new Marked.Renderer();\ncustomMarkedRenderer.heading = (text, level, _, slugger) => {\n    const slug = slugger.slug(text);\n    return `\n<a href=\"#${slug}\" id=\"${slug}\" style=\"color: inherit; text-decoration: none;\">\n  <h${level}>${text}</h${level}>\n</a>\n`;\n};\n/**\n * Implements markdown and relativeURL helpers for templates.\n * @internal\n */\nlet MarkedPlugin = class MarkedPlugin extends components_1.ContextAwareRendererComponent {\n    constructor() {\n        super(...arguments);\n        /**\n         * The pattern used to find references in markdown.\n         */\n        this.includePattern = /\\[\\[include:([^\\]]+?)\\]\\]/g;\n        /**\n         * The pattern used to find media links.\n         */\n        this.mediaPattern = /media:\\/\\/([^ \")\\]}]+)/g;\n    }\n    /**\n     * Create a new MarkedPlugin instance.\n     */\n    initialize() {\n        super.initialize();\n        this.listenTo(this.owner, events_1.MarkdownEvent.PARSE, this.onParseMarkdown);\n    }\n    /**\n     * Highlight the syntax of the given text using HighlightJS.\n     *\n     * @param text  The text that should be highlighted.\n     * @param lang  The language that should be used to highlight the string.\n     * @return A html string with syntax highlighting.\n     */\n    getHighlighted(text, lang) {\n        var _a;\n        lang = lang || \"typescript\";\n        lang = lang.toLowerCase();\n        if (!(0, highlighter_1.isSupportedLanguage)(lang)) {\n            // Extra newline because of the progress bar\n            this.application.logger.warn(`\nUnsupported highlight language \"${lang}\" will not be highlighted. Run typedoc --help for a list of supported languages.\ntarget code block :\n\\t${text.split(\"\\n\").join(\"\\n\\t\")}\nsource files :${(_a = this.sources) === null || _a === void 0 ? void 0 : _a.map((source) => `\\n\\t${source.fileName}`).join()}\noutput file :\n\\t${this.outputFileName}`);\n            return text;\n        }\n        return (0, highlighter_1.highlight)(text, lang);\n    }\n    /**\n     * Parse the given markdown string and return the resulting html.\n     *\n     * @param text  The markdown string that should be parsed.\n     * @returns The resulting html string.\n     */\n    parseMarkdown(text) {\n        if (this.includes) {\n            text = text.replace(this.includePattern, (_match, path) => {\n                path = Path.join(this.includes, path.trim());\n                if (fs.existsSync(path) && fs.statSync(path).isFile()) {\n                    const contents = (0, utils_1.readFile)(path);\n                    return contents;\n                }\n                else {\n                    this.application.logger.warn(\"Could not find file to include: \" + path);\n                    return \"\";\n                }\n            });\n        }\n        if (this.mediaDirectory) {\n            text = text.replace(this.mediaPattern, (match, path) => {\n                const fileName = Path.join(this.mediaDirectory, path);\n                if (fs.existsSync(fileName) &&\n                    fs.statSync(fileName).isFile()) {\n                    return this.getRelativeUrl(\"media\") + \"/\" + path;\n                }\n                else {\n                    this.application.logger.warn(\"Could not find media file: \" + fileName);\n                    return match;\n                }\n            });\n        }\n        const event = new events_1.MarkdownEvent(events_1.MarkdownEvent.PARSE, text, text);\n        this.owner.trigger(event);\n        return event.parsedText;\n    }\n    /**\n     * Triggered before the renderer starts rendering a project.\n     *\n     * @param event  An event object describing the current render operation.\n     */\n    onBeginRenderer(event) {\n        super.onBeginRenderer(event);\n        Marked.marked.setOptions(this.createMarkedOptions());\n        delete this.includes;\n        if (this.includeSource) {\n            if (fs.existsSync(this.includeSource) &&\n                fs.statSync(this.includeSource).isDirectory()) {\n                this.includes = this.includeSource;\n            }\n            else {\n                this.application.logger.warn(\"Could not find provided includes directory: \" +\n                    this.includeSource);\n            }\n        }\n        if (this.mediaSource) {\n            if (fs.existsSync(this.mediaSource) &&\n                fs.statSync(this.mediaSource).isDirectory()) {\n                this.mediaDirectory = Path.join(event.outputDirectory, \"media\");\n                (0, utils_1.copySync)(this.mediaSource, this.mediaDirectory);\n            }\n            else {\n                this.mediaDirectory = undefined;\n                this.application.logger.warn(\"Could not find provided media directory: \" +\n                    this.mediaSource);\n            }\n        }\n    }\n    /**\n     * Creates an object with options that are passed to the markdown parser.\n     *\n     * @returns The options object for the markdown parser.\n     */\n    createMarkedOptions() {\n        var _a, _b, _c, _d;\n        const markedOptions = ((_a = this.application.options.getValue(\"markedOptions\")) !== null && _a !== void 0 ? _a : {});\n        // Set some default values if they are not specified via the TypeDoc option\n        (_b = markedOptions.highlight) !== null && _b !== void 0 ? _b : (markedOptions.highlight = (text, lang) => this.getHighlighted(text, lang));\n        (_c = markedOptions.renderer) !== null && _c !== void 0 ? _c : (markedOptions.renderer = customMarkedRenderer);\n        (_d = markedOptions.mangle) !== null && _d !== void 0 ? _d : (markedOptions.mangle = false); // See https://github.com/TypeStrong/typedoc/issues/1395\n        return markedOptions;\n    }\n    /**\n     * Triggered when {@link MarkedPlugin} parses a markdown string.\n     *\n     * @param event\n     */\n    onParseMarkdown(event) {\n        event.parsedText = Marked.marked(event.parsedText);\n    }\n};\n__decorate([\n    (0, utils_1.BindOption)(\"includes\")\n], MarkedPlugin.prototype, \"includeSource\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"media\")\n], MarkedPlugin.prototype, \"mediaSource\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"lightHighlightTheme\")\n], MarkedPlugin.prototype, \"lightTheme\", void 0);\n__decorate([\n    (0, utils_1.BindOption)(\"darkHighlightTheme\")\n], MarkedPlugin.prototype, \"darkTheme\", void 0);\nMarkedPlugin = __decorate([\n    (0, components_1.Component)({ name: \"marked\" })\n], MarkedPlugin);\nexports.MarkedPlugin = MarkedPlugin;\n","\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LegendPlugin = exports.LegendBuilder = void 0;\nconst index_1 = require(\"../../models/reflections/index\");\nconst components_1 = require(\"../components\");\nconst events_1 = require(\"../events\");\nconst ignoredClasses = new Set([\"tsd-parent-kind-module\", \"tsd-is-overwrite\"]);\nconst completeLegend = [\n    [\n        { name: \"Namespace\", classes: [\"tsd-kind-namespace\"] },\n        { name: \"Object literal\", classes: [\"tsd-kind-object-literal\"] },\n        { name: \"Variable\", classes: [\"tsd-kind-variable\"] },\n        { name: \"Function\", classes: [\"tsd-kind-function\"] },\n        {\n            name: \"Function with type parameter\",\n            classes: [\"tsd-kind-function\", \"tsd-has-type-parameter\"],\n        },\n        { name: \"Index signature\", classes: [\"tsd-kind-index-signature\"] },\n        { name: \"Type alias\", classes: [\"tsd-kind-type-alias\"] },\n        {\n            name: \"Type alias with type parameter\",\n            classes: [\"tsd-kind-type-alias\", \"tsd-has-type-parameter\"],\n        },\n    ],\n    [\n        { name: \"Enumeration\", classes: [\"tsd-kind-enum\"] },\n        { name: \"Enumeration Member\", classes: [\"tsd-kind-enum-member\"] },\n        {\n            name: \"Property\",\n            classes: [\"tsd-kind-property\", \"tsd-parent-kind-enum\"],\n        },\n        {\n            name: \"Method\",\n            classes: [\"tsd-kind-method\", \"tsd-parent-kind-enum\"],\n        },\n    ],\n    [\n        { name: \"Interface\", classes: [\"tsd-kind-interface\"] },\n        {\n            name: \"Interface with type parameter\",\n            classes: [\"tsd-kind-interface\", \"tsd-has-type-parameter\"],\n        },\n        {\n            name: \"Constructor\",\n            classes: [\"tsd-kind-constructor\", \"tsd-parent-kind-interface\"],\n        },\n        {\n            name: \"Property\",\n            classes: [\"tsd-kind-property\", \"tsd-parent-kind-interface\"],\n        },\n        {\n            name: \"Method\",\n            classes: [\"tsd-kind-method\", \"tsd-parent-kind-interface\"],\n        },\n        {\n            name: \"Index signature\",\n            classes: [\"tsd-kind-index-signature\", \"tsd-parent-kind-interface\"],\n        },\n    ],\n    [\n        { name: \"Class\", classes: [\"tsd-kind-class\"] },\n        {\n            name: \"Class with type parameter\",\n            classes: [\"tsd-kind-class\", \"tsd-has-type-parameter\"],\n        },\n        {\n            name: \"Constructor\",\n            classes: [\"tsd-kind-constructor\", \"tsd-parent-kind-class\"],\n        },\n        {\n            name: \"Property\",\n            classes: [\"tsd-kind-property\", \"tsd-parent-kind-class\"],\n        },\n        {\n            name: \"Method\",\n            classes: [\"tsd-kind-method\", \"tsd-parent-kind-class\"],\n        },\n        {\n            name: \"Accessor\",\n            classes: [\"tsd-kind-accessor\", \"tsd-parent-kind-class\"],\n        },\n        {\n            name: \"Index signature\",\n            classes: [\"tsd-kind-index-signature\", \"tsd-parent-kind-class\"],\n        },\n    ],\n    [\n        {\n            name: \"Inherited constructor\",\n            classes: [\n                \"tsd-kind-constructor\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-inherited\",\n            ],\n        },\n        {\n            name: \"Inherited property\",\n            classes: [\n                \"tsd-kind-property\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-inherited\",\n            ],\n        },\n        {\n            name: \"Inherited method\",\n            classes: [\n                \"tsd-kind-method\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-inherited\",\n            ],\n        },\n        {\n            name: \"Inherited accessor\",\n            classes: [\n                \"tsd-kind-accessor\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-inherited\",\n            ],\n        },\n    ],\n    [\n        {\n            name: \"Protected property\",\n            classes: [\n                \"tsd-kind-property\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-protected\",\n            ],\n        },\n        {\n            name: \"Protected method\",\n            classes: [\n                \"tsd-kind-method\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-protected\",\n            ],\n        },\n        {\n            name: \"Protected accessor\",\n            classes: [\n                \"tsd-kind-accessor\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-protected\",\n            ],\n        },\n    ],\n    [\n        {\n            name: \"Private property\",\n            classes: [\n                \"tsd-kind-property\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-private\",\n            ],\n        },\n        {\n            name: \"Private method\",\n            classes: [\n                \"tsd-kind-method\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-private\",\n            ],\n        },\n        {\n            name: \"Private accessor\",\n            classes: [\n                \"tsd-kind-accessor\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-private\",\n            ],\n        },\n    ],\n    [\n        {\n            name: \"Static property\",\n            classes: [\n                \"tsd-kind-property\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-static\",\n            ],\n        },\n        {\n            name: \"Static method\",\n            classes: [\n                \"tsd-kind-method\",\n                \"tsd-parent-kind-class\",\n                \"tsd-is-static\",\n            ],\n        },\n    ],\n];\nclass LegendBuilder {\n    constructor() {\n        this._classesList = [];\n    }\n    build() {\n        const filteredLegend = completeLegend\n            .map((list) => {\n            return list.filter((item) => {\n                for (const classes of this._classesList) {\n                    if (this.isArrayEqualToSet(item.classes, classes)) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        })\n            .filter((list) => list.length);\n        return filteredLegend;\n    }\n    registerCssClasses(classArray) {\n        let exists = false;\n        const items = classArray.filter((cls) => !ignoredClasses.has(cls));\n        for (const classes of this._classesList) {\n            if (this.isArrayEqualToSet(items, classes)) {\n                exists = true;\n                break;\n            }\n        }\n        if (!exists) {\n            this._classesList.push(new Set(items));\n        }\n    }\n    isArrayEqualToSet(a, b) {\n        if (a.length !== b.size) {\n            return false;\n        }\n        for (const value of a) {\n            if (!b.has(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.LegendBuilder = LegendBuilder;\n/**\n * A plugin that generates the legend for the current page.\n *\n * This plugin sets the {@link PageEvent.legend} property.\n */\nlet LegendPlugin = class LegendPlugin extends components_1.RendererComponent {\n    /**\n     * Create a new LegendPlugin instance.\n     */\n    initialize() {\n        this.listenTo(this.owner, {\n            [events_1.RendererEvent.BEGIN]: this.onRenderBegin,\n            [events_1.PageEvent.BEGIN]: this.onRendererBeginPage,\n            [events_1.RendererEvent.END]: () => (this._project = void 0),\n        });\n    }\n    onRenderBegin(event) {\n        this._project = event.project;\n    }\n    /**\n     * Triggered before a document will be rendered.\n     *\n     * @param page  An event object describing the current render operation.\n     */\n    onRendererBeginPage(page) {\n        var _a, _b;\n        const model = page.model;\n        const builder = new LegendBuilder();\n        // immediate children\n        this.buildLegend(model, builder);\n        // top level items (as appears in navigation)\n        (_b = (_a = this._project) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.forEach((reflection) => {\n            if (reflection !== model) {\n                this.buildLegend(reflection, builder);\n            }\n        });\n        page.legend = builder.build().sort((a, b) => b.length - a.length);\n    }\n    buildLegend(model, builder) {\n        var _a, _b;\n        if (model instanceof index_1.DeclarationReflection) {\n            const children = (model.children || [])\n                .concat(...(((_a = model.groups) === null || _a === void 0 ? void 0 : _a.map((group) => group.children)) || []))\n                .concat(...model.getAllSignatures())\n                .concat(model.indexSignature)\n                .filter((item) => item);\n            for (const child of children) {\n                const cssClasses = (_b = child === null || child === void 0 ? void 0 : child.cssClasses) === null || _b === void 0 ? void 0 : _b.split(\" \");\n                if (cssClasses) {\n                    builder.registerCssClasses(cssClasses);\n                }\n            }\n        }\n    }\n};\nLegendPlugin = __decorate([\n    (0, components_1.Component)({ name: \"legend\" })\n], LegendPlugin);\nexports.LegendPlugin = LegendPlugin;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JSONOutput = exports.UnknownTypeSerializer = exports.TypeSerializer = exports.TypeParameterReflectionSerializer = exports.TypeOperatorTypeSerializer = exports.TupleTypeSerializer = exports.SourceReferenceWrapper = exports.SourceReferenceContainerSerializer = exports.SignatureReflectionSerializer = exports.ReflectionTypeSerializer = exports.ReflectionSerializer = exports.ReflectionGroupSerializer = exports.ReflectionCategorySerializer = exports.ReferenceTypeSerializer = exports.ParameterReflectionSerializer = exports.LiteralTypeSerializer = exports.IntrinsicTypeSerializer = exports.IntersectionTypeSerializer = exports.DecoratorWrapper = exports.DecoratorContainerSerializer = exports.DeclarationReflectionSerializer = exports.ContainerReflectionSerializer = exports.CommentTagSerializer = exports.CommentSerializer = exports.ArrayTypeSerializer = exports.Serializer = exports.SerializeEvent = exports.TypeSerializerComponent = exports.SerializerComponent = exports.ReflectionSerializerComponent = void 0;\nvar components_1 = require(\"./components\");\nObject.defineProperty(exports, \"ReflectionSerializerComponent\", { enumerable: true, get: function () { return components_1.ReflectionSerializerComponent; } });\nObject.defineProperty(exports, \"SerializerComponent\", { enumerable: true, get: function () { return components_1.SerializerComponent; } });\nObject.defineProperty(exports, \"TypeSerializerComponent\", { enumerable: true, get: function () { return components_1.TypeSerializerComponent; } });\nvar events_1 = require(\"./events\");\nObject.defineProperty(exports, \"SerializeEvent\", { enumerable: true, get: function () { return events_1.SerializeEvent; } });\nvar serializer_1 = require(\"./serializer\");\nObject.defineProperty(exports, \"Serializer\", { enumerable: true, get: function () { return serializer_1.Serializer; } });\nvar serializers_1 = require(\"./serializers\");\nObject.defineProperty(exports, \"ArrayTypeSerializer\", { enumerable: true, get: function () { return serializers_1.ArrayTypeSerializer; } });\nObject.defineProperty(exports, \"CommentSerializer\", { enumerable: true, get: function () { return serializers_1.CommentSerializer; } });\nObject.defineProperty(exports, \"CommentTagSerializer\", { enumerable: true, get: function () { return serializers_1.CommentTagSerializer; } });\nObject.defineProperty(exports, \"ContainerReflectionSerializer\", { enumerable: true, get: function () { return serializers_1.ContainerReflectionSerializer; } });\nObject.defineProperty(exports, \"DeclarationReflectionSerializer\", { enumerable: true, get: function () { return serializers_1.DeclarationReflectionSerializer; } });\nObject.defineProperty(exports, \"DecoratorContainerSerializer\", { enumerable: true, get: function () { return serializers_1.DecoratorContainerSerializer; } });\nObject.defineProperty(exports, \"DecoratorWrapper\", { enumerable: true, get: function () { return serializers_1.DecoratorWrapper; } });\nObject.defineProperty(exports, \"IntersectionTypeSerializer\", { enumerable: true, get: function () { return serializers_1.IntersectionTypeSerializer; } });\nObject.defineProperty(exports, \"IntrinsicTypeSerializer\", { enumerable: true, get: function () { return serializers_1.IntrinsicTypeSerializer; } });\nObject.defineProperty(exports, \"LiteralTypeSerializer\", { enumerable: true, get: function () { return serializers_1.LiteralTypeSerializer; } });\nObject.defineProperty(exports, \"ParameterReflectionSerializer\", { enumerable: true, get: function () { return serializers_1.ParameterReflectionSerializer; } });\nObject.defineProperty(exports, \"ReferenceTypeSerializer\", { enumerable: true, get: function () { return serializers_1.ReferenceTypeSerializer; } });\nObject.defineProperty(exports, \"ReflectionCategorySerializer\", { enumerable: true, get: function () { return serializers_1.ReflectionCategorySerializer; } });\nObject.defineProperty(exports, \"ReflectionGroupSerializer\", { enumerable: true, get: function () { return serializers_1.ReflectionGroupSerializer; } });\nObject.defineProperty(exports, \"ReflectionSerializer\", { enumerable: true, get: function () { return serializers_1.ReflectionSerializer; } });\nObject.defineProperty(exports, \"ReflectionTypeSerializer\", { enumerable: true, get: function () { return serializers_1.ReflectionTypeSerializer; } });\nObject.defineProperty(exports, \"SignatureReflectionSerializer\", { enumerable: true, get: function () { return serializers_1.SignatureReflectionSerializer; } });\nObject.defineProperty(exports, \"SourceReferenceContainerSerializer\", { enumerable: true, get: function () { return serializers_1.SourceReferenceContainerSerializer; } });\nObject.defineProperty(exports, \"SourceReferenceWrapper\", { enumerable: true, get: function () { return serializers_1.SourceReferenceWrapper; } });\nObject.defineProperty(exports, \"TupleTypeSerializer\", { enumerable: true, get: function () { return serializers_1.TupleTypeSerializer; } });\nObject.defineProperty(exports, \"TypeOperatorTypeSerializer\", { enumerable: true, get: function () { return serializers_1.TypeOperatorTypeSerializer; } });\nObject.defineProperty(exports, \"TypeParameterReflectionSerializer\", { enumerable: true, get: function () { return serializers_1.TypeParameterReflectionSerializer; } });\nObject.defineProperty(exports, \"TypeSerializer\", { enumerable: true, get: function () { return serializers_1.TypeSerializer; } });\nObject.defineProperty(exports, \"UnknownTypeSerializer\", { enumerable: true, get: function () { return serializers_1.UnknownTypeSerializer; } });\nconst JSONOutput = require(\"./schema\");\nexports.JSONOutput = JSONOutput;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeSerializerComponent = exports.ReflectionSerializerComponent = exports.SerializerComponent = void 0;\nconst models_1 = require(\"../models\");\n/**\n * Represents Serializer plugin component.\n *\n * Like {@link Converter} plugins each {@link Serializer} plugin defines a predicate that instructs if an\n * object can be serialized by it, this is done dynamically at runtime via a `supports` method.\n *\n * Additionally, each {@link Serializer} plugin must define a predicate that instructs the group\n * it belongs to.\n *\n * Serializers are grouped to improve performance when finding serializers that apply to a node,\n * this makes it possible to skip the `supports` calls for `Type`s when searching for a\n * `Reflection` and vise versa.\n */\nclass SerializerComponent {\n    constructor(owner) {\n        this.owner = owner;\n    }\n    /**\n     * The priority this serializer should be executed with.\n     * A higher priority means the {@link Serializer} will be applied earlier.\n     */\n    get priority() {\n        return (this.constructor[\"PRIORITY\"] ||\n            SerializerComponent.PRIORITY);\n    }\n}\nexports.SerializerComponent = SerializerComponent;\n/**\n * The priority this serializer should be executed with.\n * A higher priority means the {@link Serializer} will be applied earlier.\n */\nSerializerComponent.PRIORITY = 0;\nclass ReflectionSerializerComponent extends SerializerComponent {\n    /**\n     * Filter for instances of {@link Reflection}\n     */\n    serializeGroup(instance) {\n        return instance instanceof models_1.Reflection;\n    }\n}\nexports.ReflectionSerializerComponent = ReflectionSerializerComponent;\nclass TypeSerializerComponent extends SerializerComponent {\n    /**\n     * Filter for instances of {@link Type}\n     */\n    serializeGroup(instance) {\n        return instance instanceof models_1.Type;\n    }\n}\nexports.TypeSerializerComponent = TypeSerializerComponent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SerializeEvent = void 0;\nconst events_1 = require(\"../utils/events\");\n/**\n * An event emitted by the {@link Serializer} class at the very beginning and\n * ending of the a project serialization process.\n *\n * @see {@link Serializer.EVENT_BEGIN}\n * @see {@link Serializer.EVENT_END}\n */\nclass SerializeEvent extends events_1.Event {\n    constructor(name, project, output) {\n        super(name);\n        this.project = project;\n        this.output = output;\n    }\n}\nexports.SerializeEvent = SerializeEvent;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Serializer = void 0;\nconst utils_1 = require(\"../utils\");\nconst events_1 = require(\"./events\");\nconst S = require(\"./serializers\");\nclass Serializer extends utils_1.EventDispatcher {\n    constructor() {\n        super();\n        /**\n         * Serializers, sorted by their `serializeGroup` function to enable higher performance.\n         */\n        this.serializers = new Map();\n        addSerializers(this);\n    }\n    addSerializer(serializer) {\n        let group = this.serializers.get(serializer.serializeGroup);\n        if (!group) {\n            this.serializers.set(serializer.serializeGroup, (group = []));\n        }\n        group.push(serializer);\n        group.sort((a, b) => b.priority - a.priority);\n    }\n    toObject(value, init = {}) {\n        if (value == null || typeof value !== \"object\") {\n            return value; // Serializing some primitive\n        }\n        if (Array.isArray(value)) {\n            if (value.length === 0) {\n                return undefined;\n            }\n            return value.map((val) => this.toObject(val));\n        }\n        // Note: This type *could* potentially lie, if a serializer declares a partial type but fails to provide\n        // the defined property, but the benefit of being mostly typed is probably worth it.\n        // TypeScript errors out if init is correctly typed as `Partial<ModelToObject<T>>`\n        return this.findSerializers(value).reduce((result, curr) => curr.toObject(value, result), init);\n    }\n    /**\n     * Same as toObject but emits {@link Serializer.EVENT_BEGIN} and {@link Serializer.EVENT_END} events.\n     * @param value\n     * @param eventData Partial information to set in the event\n     */\n    projectToObject(value, eventData = {}) {\n        const eventBegin = new events_1.SerializeEvent(Serializer.EVENT_BEGIN, value, {});\n        if (eventData.begin) {\n            eventBegin.outputDirectory = eventData.begin.outputDirectory;\n            eventBegin.outputFile = eventData.begin.outputFile;\n        }\n        this.trigger(eventBegin);\n        const project = this.toObject(value, eventBegin.output);\n        const eventEnd = new events_1.SerializeEvent(Serializer.EVENT_END, value, project);\n        if (eventData.end) {\n            eventBegin.outputDirectory = eventData.end.outputDirectory;\n            eventBegin.outputFile = eventData.end.outputFile;\n        }\n        this.trigger(eventEnd);\n        return project;\n    }\n    findSerializers(value) {\n        const routes = [];\n        for (const [groupSupports, components] of this.serializers.entries()) {\n            if (groupSupports(value)) {\n                for (const component of components) {\n                    if (component.supports(value)) {\n                        routes.push(component);\n                    }\n                }\n            }\n        }\n        return routes;\n    }\n}\nexports.Serializer = Serializer;\n/**\n * Triggered when the {@link Serializer} begins transforming a project.\n * @event EVENT_BEGIN\n */\nSerializer.EVENT_BEGIN = \"begin\";\n/**\n * Triggered when the {@link Serializer} has finished transforming a project.\n * @event EVENT_END\n */\nSerializer.EVENT_END = \"end\";\nconst serializerComponents = [\n    S.CommentTagSerializer,\n    S.CommentSerializer,\n    S.ReflectionSerializer,\n    S.ReferenceReflectionSerializer,\n    S.ContainerReflectionSerializer,\n    S.DeclarationReflectionSerializer,\n    S.ParameterReflectionSerializer,\n    S.SignatureReflectionSerializer,\n    S.TypeParameterReflectionSerializer,\n    S.SourceReferenceContainerSerializer,\n    S.TypeSerializer,\n    S.ArrayTypeSerializer,\n    S.ConditionalTypeSerializer,\n    S.IndexedAccessTypeSerializer,\n    S.InferredTypeSerializer,\n    S.IntersectionTypeSerializer,\n    S.IntrinsicTypeSerializer,\n    S.OptionalTypeSerializer,\n    S.PredicateTypeSerializer,\n    S.QueryTypeSerializer,\n    S.ReferenceTypeSerializer,\n    S.ReferenceTypeSerializer,\n    S.ReflectionTypeSerializer,\n    S.RestTypeSerializer,\n    S.LiteralTypeSerializer,\n    S.TupleTypeSerializer,\n    S.TemplateLiteralTypeSerializer,\n    S.NamedTupleMemberTypeSerializer,\n    S.MappedTypeSerializer,\n    S.TypeOperatorTypeSerializer,\n    S.UnionTypeSerializer,\n    S.UnknownTypeSerializer,\n    S.DecoratorContainerSerializer,\n    S.ReflectionCategorySerializer,\n    S.ReflectionGroupSerializer,\n];\nfunction addSerializers(owner) {\n    for (const component of serializerComponents) {\n        owner.addSerializer(new component(owner));\n    }\n}\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./reflections\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./comments\"), exports);\n__exportStar(require(\"./sources\"), exports);\n__exportStar(require(\"./decorator\"), exports);\n__exportStar(require(\"./reflection-group\"), exports);\n__exportStar(require(\"./reflection-category\"), exports);\n__exportStar(require(\"./models\"), exports);\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./abstract\"), exports);\n__exportStar(require(\"./container\"), exports);\n__exportStar(require(\"./declaration\"), exports);\n__exportStar(require(\"./parameter\"), exports);\n__exportStar(require(\"./reference\"), exports);\n__exportStar(require(\"./signature\"), exports);\n__exportStar(require(\"./type-parameter\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nconst models_2 = require(\"../models\");\nclass ReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.Reflection;\n    }\n    toObject(reflection, obj) {\n        var _a;\n        const result = {\n            ...obj,\n            id: reflection.id,\n            name: reflection.name,\n            kind: reflection.kind,\n            kindString: reflection.kindString,\n            flags: {},\n            comment: this.owner.toObject(reflection.comment),\n            decorates: this.owner.toObject(reflection.decorates),\n            decorators: this.owner.toObject((_a = reflection.decorators) === null || _a === void 0 ? void 0 : _a.map((d) => new models_2.DecoratorWrapper(d))),\n        };\n        if (reflection.originalName !== reflection.name) {\n            result.originalName = reflection.originalName;\n        }\n        const flags = [\n            \"isPrivate\",\n            \"isProtected\",\n            \"isPublic\",\n            \"isStatic\",\n            \"isExternal\",\n            \"isOptional\",\n            \"isRest\",\n            \"hasExportAssignment\",\n            \"isAbstract\",\n            \"isConst\",\n            \"isReadonly\",\n        ];\n        for (const key of flags) {\n            if (reflection.flags[key] === true) {\n                result.flags[key] = true;\n            }\n        }\n        return result;\n    }\n}\nexports.ReflectionSerializer = ReflectionSerializer;\nReflectionSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecoratorWrapper = exports.SourceReferenceWrapper = void 0;\nvar source_reference_wrapper_1 = require(\"./source-reference-wrapper\");\nObject.defineProperty(exports, \"SourceReferenceWrapper\", { enumerable: true, get: function () { return source_reference_wrapper_1.SourceReferenceWrapper; } });\nvar decorator_wrapper_1 = require(\"./decorator-wrapper\");\nObject.defineProperty(exports, \"DecoratorWrapper\", { enumerable: true, get: function () { return decorator_wrapper_1.DecoratorWrapper; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceReferenceWrapper = void 0;\n/**\n * An internal concrete implementation for the [[ SourceReference ]] interface\n * so it can be identified\n */\nclass SourceReferenceWrapper {\n    constructor(sourceReference) {\n        this.sourceReference = sourceReference;\n    }\n}\nexports.SourceReferenceWrapper = SourceReferenceWrapper;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecoratorWrapper = void 0;\n/**\n * An internal concrete implementation for the {@link Decorator} interface\n * so it can be identified\n */\nclass DecoratorWrapper {\n    constructor(decorator) {\n        this.decorator = decorator;\n    }\n}\nexports.DecoratorWrapper = DecoratorWrapper;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nconst models_2 = require(\"../models\");\nclass ContainerReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.ContainerReflection;\n    }\n    /**\n     * Will be run after {@link ReflectionSerializer} so will be passed the result of that serialization.\n     * @param container\n     * @param obj\n     */\n    toObject(container, obj) {\n        var _a;\n        return {\n            ...obj,\n            children: this.owner.toObject(container.children),\n            groups: this.owner.toObject(container.groups),\n            categories: this.owner.toObject(container.categories),\n            sources: this.owner.toObject((_a = container.sources) === null || _a === void 0 ? void 0 : _a.map((s) => new models_2.SourceReferenceWrapper(s))),\n        };\n    }\n}\nexports.ContainerReflectionSerializer = ContainerReflectionSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeclarationReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nconst container_1 = require(\"./container\");\nclass DeclarationReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.DeclarationReflection;\n    }\n    toObject(d, obj) {\n        const result = {\n            ...obj,\n            typeParameter: this.owner.toObject(d.typeParameters),\n            type: this.owner.toObject(d.type),\n            signatures: this.owner.toObject(d.signatures),\n            indexSignature: this.owner.toObject(d.indexSignature),\n        };\n        if (d.getSignature) {\n            result.getSignature = [this.owner.toObject(d.getSignature)];\n        }\n        if (d.setSignature) {\n            result.setSignature = [this.owner.toObject(d.setSignature)];\n        }\n        return Object.assign(result, {\n            defaultValue: this.owner.toObject(d.defaultValue),\n            overwrites: this.owner.toObject(d.overwrites),\n            inheritedFrom: this.owner.toObject(d.inheritedFrom),\n            implementationOf: this.owner.toObject(d.implementationOf),\n            extendedTypes: this.owner.toObject(d.extendedTypes),\n            extendedBy: this.owner.toObject(d.extendedBy),\n            implementedTypes: this.owner.toObject(d.implementedTypes),\n            implementedBy: this.owner.toObject(d.implementedBy),\n        });\n    }\n}\nexports.DeclarationReflectionSerializer = DeclarationReflectionSerializer;\nDeclarationReflectionSerializer.PRIORITY = container_1.ContainerReflectionSerializer.PRIORITY - 1; // mimic inheritance, run after parent\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParameterReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass ParameterReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.ParameterReflection;\n    }\n    toObject(parameter, obj) {\n        const result = {\n            ...obj,\n            type: this.owner.toObject(parameter.type),\n            defaultValue: this.owner.toObject(parameter.defaultValue),\n        };\n        return result;\n    }\n}\nexports.ParameterReflectionSerializer = ParameterReflectionSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReferenceReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nconst declaration_1 = require(\"./declaration\");\nclass ReferenceReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.ReferenceReflection;\n    }\n    toObject(ref, obj) {\n        var _a, _b;\n        return {\n            ...obj,\n            target: (_b = (_a = ref.tryGetTargetReflection()) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : -1,\n        };\n    }\n}\nexports.ReferenceReflectionSerializer = ReferenceReflectionSerializer;\nReferenceReflectionSerializer.PRIORITY = declaration_1.DeclarationReflectionSerializer.PRIORITY - 1;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SignatureReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass SignatureReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.SignatureReflection;\n    }\n    toObject(signature, obj) {\n        return {\n            ...obj,\n            typeParameter: this.owner.toObject(signature.typeParameters),\n            parameters: this.owner.toObject(signature.parameters),\n            type: this.owner.toObject(signature.type),\n            overwrites: this.owner.toObject(signature.overwrites),\n            inheritedFrom: this.owner.toObject(signature.inheritedFrom),\n            implementationOf: this.owner.toObject(signature.implementationOf),\n        };\n    }\n}\nexports.SignatureReflectionSerializer = SignatureReflectionSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeParameterReflectionSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass TypeParameterReflectionSerializer extends components_1.ReflectionSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.TypeParameterReflection;\n    }\n    toObject(typeParameter, obj) {\n        return {\n            ...obj,\n            type: this.owner.toObject(typeParameter.type),\n            default: this.owner.toObject(typeParameter.default),\n            varianceModifier: typeParameter.varianceModifier,\n        };\n    }\n}\nexports.TypeParameterReflectionSerializer = TypeParameterReflectionSerializer;\n","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./abstract\"), exports);\n__exportStar(require(\"./array\"), exports);\n__exportStar(require(\"./conditional\"), exports);\n__exportStar(require(\"./indexed-access\"), exports);\n__exportStar(require(\"./inferred\"), exports);\n__exportStar(require(\"./intersection\"), exports);\n__exportStar(require(\"./intrinsic\"), exports);\n__exportStar(require(\"./literal\"), exports);\n__exportStar(require(\"./mapped\"), exports);\n__exportStar(require(\"./optional\"), exports);\n__exportStar(require(\"./predicate\"), exports);\n__exportStar(require(\"./query\"), exports);\n__exportStar(require(\"./reference\"), exports);\n__exportStar(require(\"./reflection\"), exports);\n__exportStar(require(\"./rest\"), exports);\n__exportStar(require(\"./template-literal\"), exports);\n__exportStar(require(\"./tuple\"), exports);\n__exportStar(require(\"./type-operator\"), exports);\n__exportStar(require(\"./union\"), exports);\n__exportStar(require(\"./unknown\"), exports);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass TypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.Type;\n    }\n    toObject(type, obj) {\n        return {\n            ...obj,\n            type: type.type,\n        };\n    }\n}\nexports.TypeSerializer = TypeSerializer;\nTypeSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass ArrayTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.ArrayType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            elementType: this.owner.toObject(type.elementType),\n        };\n    }\n}\nexports.ArrayTypeSerializer = ArrayTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionalTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass ConditionalTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(item) {\n        return item instanceof models_1.ConditionalType;\n    }\n    toObject(conditional, obj) {\n        return {\n            ...obj,\n            checkType: this.owner.toObject(conditional.checkType),\n            extendsType: this.owner.toObject(conditional.extendsType),\n            trueType: this.owner.toObject(conditional.trueType),\n            falseType: this.owner.toObject(conditional.falseType),\n        };\n    }\n}\nexports.ConditionalTypeSerializer = ConditionalTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexedAccessTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass IndexedAccessTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(item) {\n        return item instanceof models_1.IndexedAccessType;\n    }\n    toObject(type, obj) {\n        return {\n            ...obj,\n            indexType: this.owner.toObject(type.indexType),\n            objectType: this.owner.toObject(type.objectType),\n        };\n    }\n}\nexports.IndexedAccessTypeSerializer = IndexedAccessTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InferredTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass InferredTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(item) {\n        return item instanceof models_1.InferredType;\n    }\n    toObject(inferred, obj) {\n        return {\n            ...obj,\n            name: inferred.name,\n            constraint: inferred.constraint\n                ? this.owner.toObject(inferred.constraint)\n                : undefined,\n        };\n    }\n}\nexports.InferredTypeSerializer = InferredTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IntersectionTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass IntersectionTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.IntersectionType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            types: type.types.map((t) => this.owner.toObject(t)),\n        };\n    }\n}\nexports.IntersectionTypeSerializer = IntersectionTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IntrinsicTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass IntrinsicTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.IntrinsicType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            name: type.name,\n        };\n    }\n}\nexports.IntrinsicTypeSerializer = IntrinsicTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiteralTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass LiteralTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.LiteralType;\n    }\n    toObject(type, obj) {\n        if (typeof type.value === \"bigint\") {\n            return {\n                ...obj,\n                value: {\n                    value: type.value.toString().replace(\"-\", \"\"),\n                    negative: type.value < BigInt(\"0\"),\n                },\n            };\n        }\n        return {\n            ...obj,\n            value: type.value,\n        };\n    }\n}\nexports.LiteralTypeSerializer = LiteralTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MappedTypeSerializer = void 0;\nconst components_1 = require(\"../../components\");\nconst models_1 = require(\"../../../models\");\nclass MappedTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.MappedType;\n    }\n    toObject(map, obj) {\n        return {\n            ...obj,\n            parameter: map.parameter,\n            parameterType: this.owner.toObject(map.parameterType),\n            templateType: this.owner.toObject(map.templateType),\n            readonlyModifier: map.readonlyModifier,\n            optionalModifier: map.optionalModifier,\n            nameType: this.owner.toObject(map.nameType),\n        };\n    }\n}\nexports.MappedTypeSerializer = MappedTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OptionalTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass OptionalTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.OptionalType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            elementType: this.owner.toObject(type.elementType),\n        };\n    }\n}\nexports.OptionalTypeSerializer = OptionalTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PredicateTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass PredicateTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.PredicateType;\n    }\n    toObject(type, obj) {\n        return {\n            ...obj,\n            name: type.name,\n            asserts: type.asserts,\n            targetType: type.targetType\n                ? this.owner.toObject(type.targetType)\n                : undefined,\n        };\n    }\n}\nexports.PredicateTypeSerializer = PredicateTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass QueryTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.QueryType;\n    }\n    toObject(type, obj) {\n        return {\n            ...obj,\n            queryType: this.owner.toObject(type.queryType),\n        };\n    }\n}\nexports.QueryTypeSerializer = QueryTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReferenceTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass ReferenceTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.ReferenceType;\n    }\n    toObject(type, obj) {\n        if (type.reflection) {\n            obj.id = type.reflection.id;\n        }\n        if (type.typeArguments && type.typeArguments.length > 0) {\n            obj.typeArguments = type.typeArguments.map((t) => this.owner.toObject(t));\n        }\n        if (type.qualifiedName && type.package) {\n            obj.qualifiedName = type.qualifiedName;\n            obj.package = type.package;\n        }\n        return {\n            ...obj,\n            name: type.name,\n        };\n    }\n}\nexports.ReferenceTypeSerializer = ReferenceTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass ReflectionTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.ReflectionType;\n    }\n    toObject(reference, obj) {\n        const result = {\n            ...obj,\n            declaration: this.owner.toObject(reference.declaration),\n        };\n        return result;\n    }\n}\nexports.ReflectionTypeSerializer = ReflectionTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RestTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass RestTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.RestType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            elementType: this.owner.toObject(type.elementType),\n        };\n    }\n}\nexports.RestTypeSerializer = RestTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TemplateLiteralTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass TemplateLiteralTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.TemplateLiteralType;\n    }\n    toObject(type, obj) {\n        return {\n            ...obj,\n            head: type.head,\n            tail: type.tail.map(([type, text]) => [\n                this.owner.toObject(type),\n                text,\n            ]),\n        };\n    }\n}\nexports.TemplateLiteralTypeSerializer = TemplateLiteralTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedTupleMemberTypeSerializer = exports.TupleTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass TupleTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.TupleType;\n    }\n    toObject(tuple, obj) {\n        const result = { ...obj };\n        if (tuple.elements && tuple.elements.length > 0) {\n            result.elements = tuple.elements.map((t) => this.owner.toObject(t));\n        }\n        return result;\n    }\n}\nexports.TupleTypeSerializer = TupleTypeSerializer;\nclass NamedTupleMemberTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.NamedTupleMember;\n    }\n    toObject(tuple, obj) {\n        return {\n            ...obj,\n            name: tuple.name,\n            isOptional: tuple.isOptional,\n            element: this.owner.toObject(tuple.element),\n        };\n    }\n}\nexports.NamedTupleMemberTypeSerializer = NamedTupleMemberTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeOperatorTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass TypeOperatorTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.TypeOperatorType;\n    }\n    toObject(type, obj) {\n        return {\n            ...obj,\n            operator: type.operator,\n            target: this.owner.toObject(type.target),\n        };\n    }\n}\nexports.TypeOperatorTypeSerializer = TypeOperatorTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnionTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass UnionTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.UnionType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            types: type.types.map((t) => this.owner.toObject(t)),\n        };\n    }\n}\nexports.UnionTypeSerializer = UnionTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnknownTypeSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass UnknownTypeSerializer extends components_1.TypeSerializerComponent {\n    supports(t) {\n        return t instanceof models_1.UnknownType;\n    }\n    /**\n     * Will be run after {@link TypeSerializer} so `type` will already be set.\n     * @param type\n     * @param obj\n     */\n    toObject(type, obj) {\n        return {\n            ...obj,\n            name: type.name,\n        };\n    }\n}\nexports.UnknownTypeSerializer = UnknownTypeSerializer;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentTagSerializer = exports.CommentSerializer = void 0;\nvar comment_1 = require(\"./comment\");\nObject.defineProperty(exports, \"CommentSerializer\", { enumerable: true, get: function () { return comment_1.CommentSerializer; } });\nvar comment_tag_1 = require(\"./comment-tag\");\nObject.defineProperty(exports, \"CommentTagSerializer\", { enumerable: true, get: function () { return comment_tag_1.CommentTagSerializer; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass CommentSerializer extends components_1.SerializerComponent {\n    /**\n     * Filter for instances of {@link Comment}\n     */\n    serializeGroup(instance) {\n        return instance instanceof models_1.Comment;\n    }\n    supports() {\n        return true;\n    }\n    toObject(comment, obj = {}) {\n        if (comment.shortText) {\n            obj.shortText = comment.shortText;\n        }\n        if (comment.text) {\n            obj.text = comment.text;\n        }\n        if (comment.returns) {\n            obj.returns = comment.returns;\n        }\n        if (comment.tags.length) {\n            obj.tags = comment.tags.map((tag) => this.owner.toObject(tag));\n        }\n        return obj;\n    }\n}\nexports.CommentSerializer = CommentSerializer;\nCommentSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentTagSerializer = void 0;\nconst models_1 = require(\"../../../models\");\nconst components_1 = require(\"../../components\");\nclass CommentTagSerializer extends components_1.SerializerComponent {\n    /**\n     * Filter for instances of {@link CommentTag}\n     */\n    serializeGroup(instance) {\n        return instance instanceof models_1.CommentTag;\n    }\n    supports(_t) {\n        return true;\n    }\n    toObject(tag, obj = {}) {\n        const result = {\n            tag: tag.tagName,\n            text: tag.text,\n        };\n        if (tag.paramName) {\n            result.param = tag.paramName;\n        }\n        return { ...obj, ...result };\n    }\n}\nexports.CommentTagSerializer = CommentTagSerializer;\nCommentTagSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceReferenceContainerSerializer = void 0;\nvar source_reference_1 = require(\"./source-reference\");\nObject.defineProperty(exports, \"SourceReferenceContainerSerializer\", { enumerable: true, get: function () { return source_reference_1.SourceReferenceContainerSerializer; } });\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceReferenceContainerSerializer = void 0;\nconst components_1 = require(\"../../components\");\nconst models_1 = require(\"../models\");\nclass SourceReferenceContainerSerializer extends components_1.SerializerComponent {\n    serializeGroup(instance) {\n        return instance instanceof models_1.SourceReferenceWrapper;\n    }\n    supports() {\n        return true;\n    }\n    toObject({ sourceReference: ref }, obj) {\n        return {\n            ...obj,\n            fileName: ref.fileName,\n            line: ref.line,\n            character: ref.character,\n        };\n    }\n}\nexports.SourceReferenceContainerSerializer = SourceReferenceContainerSerializer;\nSourceReferenceContainerSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DecoratorContainerSerializer = void 0;\nconst components_1 = require(\"../components\");\nconst decorator_wrapper_1 = require(\"./models/decorator-wrapper\");\nclass DecoratorContainerSerializer extends components_1.SerializerComponent {\n    /**\n     * Filter for instances of {@link DecoratorWrapper}\n     */\n    serializeGroup(instance) {\n        return instance instanceof decorator_wrapper_1.DecoratorWrapper;\n    }\n    supports() {\n        return true;\n    }\n    toObject({ decorator }, obj) {\n        const result = {\n            ...obj,\n            name: decorator.name,\n        };\n        if (decorator.type) {\n            result.type = this.owner.toObject(decorator.type);\n        }\n        if (decorator.arguments) {\n            result.arguments = decorator.arguments;\n        }\n        return result;\n    }\n}\nexports.DecoratorContainerSerializer = DecoratorContainerSerializer;\nDecoratorContainerSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionGroupSerializer = void 0;\nconst ReflectionGroup_1 = require(\"../../models/ReflectionGroup\");\nconst components_1 = require(\"../components\");\nclass ReflectionGroupSerializer extends components_1.SerializerComponent {\n    /**\n     * Filter for instances of {@link ReflectionGroup}\n     */\n    serializeGroup(instance) {\n        return instance instanceof ReflectionGroup_1.ReflectionGroup;\n    }\n    supports() {\n        return true;\n    }\n    toObject(group, obj) {\n        const result = {\n            ...obj,\n            title: group.title,\n            kind: group.kind,\n        };\n        if (group.children && group.children.length > 0) {\n            result.children = group.children.map((child) => child.id);\n        }\n        if (group.categories && group.categories.length > 0) {\n            result.categories = group.categories.map((category) => this.owner.toObject(category));\n        }\n        return result;\n    }\n}\nexports.ReflectionGroupSerializer = ReflectionGroupSerializer;\nReflectionGroupSerializer.PRIORITY = 1000;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReflectionCategorySerializer = void 0;\nconst ReflectionCategory_1 = require(\"../../models/ReflectionCategory\");\nconst components_1 = require(\"../components\");\nclass ReflectionCategorySerializer extends components_1.SerializerComponent {\n    /**\n     * Filter for instances of {@link ReflectionCategory}\n     */\n    serializeGroup(instance) {\n        return instance instanceof ReflectionCategory_1.ReflectionCategory;\n    }\n    supports(r) {\n        return r instanceof ReflectionCategory_1.ReflectionCategory;\n    }\n    toObject(category, obj) {\n        const result = {\n            ...obj,\n            title: category.title,\n        };\n        if (category.children && category.children.length > 0) {\n            result.children = category.children.map((child) => child.id);\n        }\n        return result;\n    }\n}\nexports.ReflectionCategorySerializer = ReflectionCategorySerializer;\nReflectionCategorySerializer.PRIORITY = 1000;\n","\n/**\n * Contains interfaces which describe the JSON output. Each interface is related to a specific type of serializer.\n *\n * ## Plugins\n * Plugins which modify the serialization process can use declaration merging\n * to add custom properties to the exported interfaces.\n * For example, if your custom serializer adds a property to all {@link Reflection} objects:\n * ```ts\n * declare module 'typedoc/dist/lib/serialization/schema' {\n *     export interface AbstractReflection {\n *         myCustomProp: boolean\n *     }\n * }\n * ```\n *\n * If a plugin defines a new Model type, {@link ModelToObject} will not pick up the serializer type and\n * the resulting type will not be included in the return type of {@link Serializer.toObject}.\n * To fix this, use declaration merging to augment the {@link Serializer} class.\n * ```ts\n * declare module 'typedoc/dist/lib/serialization/serializer' {\n *     export interface Serializer {\n *         toObject(value: CustomModel, obj?: Partial<CustomModel>): CustomOutput\n *     }\n * }\n * ```\n *\n * For documentation on the JSON output properties, view the corresponding model.\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"]}